/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./resources/js/admin/auto-complete-tag/mab-jquery-taginput.css":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/src??ref--6-2!./resources/js/admin/auto-complete-tag/mab-jquery-taginput.css ***!
  \******************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".mab-jquery-taginput input {\\r\\n  border: solid 1px #fff;\\r\\n  outline: none;\\r\\n  width: 6em;\\r\\n  height: 20.984375px;\\r\\n  padding: 1px 0;\\r\\n  font-size: 14px;\\r\\n  line-height: 1.21;\\r\\n  vertical-align: top;\\r\\n  margin-bottom: 6px; }\\r\\n  .mab-jquery-taginput input.h {\\r\\n    width: 1px; }\\r\\n  .mab-jquery-taginput input:-moz-placeholder {\\r\\n    color: #999999; }\\r\\n  .mab-jquery-taginput input::-moz-placeholder {\\r\\n    color: #999999;\\r\\n    opacity: 1; }\\r\\n  .mab-jquery-taginput input:-ms-input-placeholder {\\r\\n    color: #999999; }\\r\\n  .mab-jquery-taginput input::-webkit-input-placeholder {\\r\\n    color: #999999; }\\r\\n  .mab-jquery-taginput input::-ms-clear {\\r\\n    display: none; }\\r\\n\\r\\n.mab-jquery-taginput.form-control {\\r\\n  height: auto;\\r\\n  padding-bottom: 0; }\\r\\n\\r\\n.mab-jquery-taginput .label {\\r\\n  font-size: 1em;\\r\\n  padding-right: 0.5em;\\r\\n  margin-right: 5px;\\r\\n  display: inline-block;\\r\\n  margin-bottom: 6px; }\\r\\n\\r\\n.mab-jquery-taginput a {\\r\\n  text-decoration: none;\\r\\n  color: #fff; }\\r\\n\\r\\n.mab-jquery-taginput .glyphicon {\\r\\n  font-size: 0.85em;\\r\\n  vertical-align: -1px;\\r\\n  cursor: pointer; }\\r\\n\\r\\n.tt-query {\\r\\n  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075); }\\r\\n\\r\\n.tt-hint {\\r\\n  color: #999; }\\r\\n\\r\\n.tt-menu {\\r\\n  min-width: 160px;\\r\\n  padding: 5px 0;\\r\\n  margin: 2px 0 0;\\r\\n  background-color: #fff;\\r\\n  border: 1px solid #ccc;\\r\\n  border: 1px solid rgba(0, 0, 0, 0.2);\\r\\n  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);\\r\\n  border-radius: 6px;\\r\\n  background-clip: padding-box; }\\r\\n\\r\\n.tt-suggestion {\\r\\n  margin: 0;\\r\\n  padding: 3px 20px;\\r\\n  line-height: 20px;\\r\\n  clear: both;\\r\\n  white-space: nowrap; }\\r\\n\\r\\n.tt-suggestion.tt-cursor {\\r\\n  color: #fff;\\r\\n  background-color: #428bca; }\\r\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYWRtaW4vYXV0by1jb21wbGV0ZS10YWcvbWFiLWpxdWVyeS10YWdpbnB1dC5jc3M/NDNkZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBcUQ7QUFDeEY7OztBQUdBO0FBQ0EsY0FBYyxRQUFTLCtCQUErQiw2QkFBNkIsb0JBQW9CLGlCQUFpQiwwQkFBMEIscUJBQXFCLHNCQUFzQix3QkFBd0IsMEJBQTBCLHlCQUF5QixFQUFFLG9DQUFvQyxtQkFBbUIsRUFBRSxtREFBbUQsdUJBQXVCLEVBQUUsb0RBQW9ELHVCQUF1QixtQkFBbUIsRUFBRSx3REFBd0QsdUJBQXVCLEVBQUUsNkRBQTZELHVCQUF1QixFQUFFLDZDQUE2QyxzQkFBc0IsRUFBRSwyQ0FBMkMsbUJBQW1CLHdCQUF3QixFQUFFLHFDQUFxQyxxQkFBcUIsMkJBQTJCLHdCQUF3Qiw0QkFBNEIseUJBQXlCLEVBQUUsZ0NBQWdDLDRCQUE0QixrQkFBa0IsRUFBRSx5Q0FBeUMsd0JBQXdCLDJCQUEyQixzQkFBc0IsRUFBRSxtQkFBbUIsdURBQXVELEVBQUUsa0JBQWtCLGtCQUFrQixFQUFFLGtCQUFrQix1QkFBdUIscUJBQXFCLHNCQUFzQiw2QkFBNkIsNkJBQTZCLDJDQUEyQyxnREFBZ0QseUJBQXlCLG1DQUFtQyxFQUFFLHdCQUF3QixnQkFBZ0Isd0JBQXdCLHdCQUF3QixrQkFBa0IsMEJBQTBCLEVBQUUsa0NBQWtDLGtCQUFrQixnQ0FBZ0MsRUFBRTs7QUFFaHhEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/IS4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi9yZXNvdXJjZXMvanMvYWRtaW4vYXV0by1jb21wbGV0ZS10YWcvbWFiLWpxdWVyeS10YWdpbnB1dC5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5tYWItanF1ZXJ5LXRhZ2lucHV0IGlucHV0IHtcXHJcXG4gIGJvcmRlcjogc29saWQgMXB4ICNmZmY7XFxyXFxuICBvdXRsaW5lOiBub25lO1xcclxcbiAgd2lkdGg6IDZlbTtcXHJcXG4gIGhlaWdodDogMjAuOTg0Mzc1cHg7XFxyXFxuICBwYWRkaW5nOiAxcHggMDtcXHJcXG4gIGZvbnQtc2l6ZTogMTRweDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjIxO1xcclxcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDZweDsgfVxcclxcbiAgLm1hYi1qcXVlcnktdGFnaW5wdXQgaW5wdXQuaCB7XFxyXFxuICAgIHdpZHRoOiAxcHg7IH1cXHJcXG4gIC5tYWItanF1ZXJ5LXRhZ2lucHV0IGlucHV0Oi1tb3otcGxhY2Vob2xkZXIge1xcclxcbiAgICBjb2xvcjogIzk5OTk5OTsgfVxcclxcbiAgLm1hYi1qcXVlcnktdGFnaW5wdXQgaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXIge1xcclxcbiAgICBjb2xvcjogIzk5OTk5OTtcXHJcXG4gICAgb3BhY2l0eTogMTsgfVxcclxcbiAgLm1hYi1qcXVlcnktdGFnaW5wdXQgaW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcXHJcXG4gICAgY29sb3I6ICM5OTk5OTk7IH1cXHJcXG4gIC5tYWItanF1ZXJ5LXRhZ2lucHV0IGlucHV0Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyIHtcXHJcXG4gICAgY29sb3I6ICM5OTk5OTk7IH1cXHJcXG4gIC5tYWItanF1ZXJ5LXRhZ2lucHV0IGlucHV0OjotbXMtY2xlYXIge1xcclxcbiAgICBkaXNwbGF5OiBub25lOyB9XFxyXFxuXFxyXFxuLm1hYi1qcXVlcnktdGFnaW5wdXQuZm9ybS1jb250cm9sIHtcXHJcXG4gIGhlaWdodDogYXV0bztcXHJcXG4gIHBhZGRpbmctYm90dG9tOiAwOyB9XFxyXFxuXFxyXFxuLm1hYi1qcXVlcnktdGFnaW5wdXQgLmxhYmVsIHtcXHJcXG4gIGZvbnQtc2l6ZTogMWVtO1xcclxcbiAgcGFkZGluZy1yaWdodDogMC41ZW07XFxyXFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXHJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gIG1hcmdpbi1ib3R0b206IDZweDsgfVxcclxcblxcclxcbi5tYWItanF1ZXJ5LXRhZ2lucHV0IGEge1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbiAgY29sb3I6ICNmZmY7IH1cXHJcXG5cXHJcXG4ubWFiLWpxdWVyeS10YWdpbnB1dCAuZ2x5cGhpY29uIHtcXHJcXG4gIGZvbnQtc2l6ZTogMC44NWVtO1xcclxcbiAgdmVydGljYWwtYWxpZ246IC0xcHg7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7IH1cXHJcXG5cXHJcXG4udHQtcXVlcnkge1xcclxcbiAgYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4wNzUpOyB9XFxyXFxuXFxyXFxuLnR0LWhpbnQge1xcclxcbiAgY29sb3I6ICM5OTk7IH1cXHJcXG5cXHJcXG4udHQtbWVudSB7XFxyXFxuICBtaW4td2lkdGg6IDE2MHB4O1xcclxcbiAgcGFkZGluZzogNXB4IDA7XFxyXFxuICBtYXJnaW46IDJweCAwIDA7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcclxcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjYztcXHJcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4yKTtcXHJcXG4gIGJveC1zaGFkb3c6IDAgNXB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcclxcbiAgYmFja2dyb3VuZC1jbGlwOiBwYWRkaW5nLWJveDsgfVxcclxcblxcclxcbi50dC1zdWdnZXN0aW9uIHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHBhZGRpbmc6IDNweCAyMHB4O1xcclxcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxyXFxuICBjbGVhcjogYm90aDtcXHJcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7IH1cXHJcXG5cXHJcXG4udHQtc3VnZ2VzdGlvbi50dC1jdXJzb3Ige1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDI4YmNhOyB9XFxyXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./resources/js/admin/auto-complete-tag/mab-jquery-taginput.css\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/dropzone/dist/dropzone.js":
/*!************************************************!*\
  !*** ./node_modules/dropzone/dist/dropzone.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n *\n * More info at [www.dropzonejs.com](http://www.dropzonejs.com)\n *\n * Copyright (c) 2012, Matias Meno\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n */\n\n// The Emitter class provides the ability to call `.on()` on Dropzone to listen\n// to events.\n// It is strongly based on component's emitter class, and I removed the\n// functionality because of the dependency hell with different frameworks.\nvar Emitter = function () {\n  function Emitter() {\n    _classCallCheck(this, Emitter);\n  }\n\n  _createClass(Emitter, [{\n    key: \"on\",\n\n    // Add an event listener for given event\n    value: function on(event, fn) {\n      this._callbacks = this._callbacks || {};\n      // Create namespace for this event\n      if (!this._callbacks[event]) {\n        this._callbacks[event] = [];\n      }\n      this._callbacks[event].push(fn);\n      return this;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      this._callbacks = this._callbacks || {};\n      var callbacks = this._callbacks[event];\n\n      if (callbacks) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        for (var _iterator = callbacks, _isArray = true, _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var callback = _ref;\n\n          callback.apply(this, args);\n        }\n      }\n\n      return this;\n    }\n\n    // Remove event listener for given event. If fn is not provided, all event\n    // listeners for that event will be removed. If neither is provided, all\n    // event listeners will be removed.\n\n  }, {\n    key: \"off\",\n    value: function off(event, fn) {\n      if (!this._callbacks || arguments.length === 0) {\n        this._callbacks = {};\n        return this;\n      }\n\n      // specific event\n      var callbacks = this._callbacks[event];\n      if (!callbacks) {\n        return this;\n      }\n\n      // remove all handlers\n      if (arguments.length === 1) {\n        delete this._callbacks[event];\n        return this;\n      }\n\n      // remove specific handler\n      for (var i = 0; i < callbacks.length; i++) {\n        var callback = callbacks[i];\n        if (callback === fn) {\n          callbacks.splice(i, 1);\n          break;\n        }\n      }\n\n      return this;\n    }\n  }]);\n\n  return Emitter;\n}();\n\nvar Dropzone = function (_Emitter) {\n  _inherits(Dropzone, _Emitter);\n\n  _createClass(Dropzone, null, [{\n    key: \"initClass\",\n    value: function initClass() {\n\n      // Exposing the emitter class, mainly for tests\n      this.prototype.Emitter = Emitter;\n\n      /*\n       This is a list of all available events you can register on a dropzone object.\n        You can register an event handler like this:\n        dropzone.on(\"dragEnter\", function() { });\n        */\n      this.prototype.events = [\"drop\", \"dragstart\", \"dragend\", \"dragenter\", \"dragover\", \"dragleave\", \"addedfile\", \"addedfiles\", \"removedfile\", \"thumbnail\", \"error\", \"errormultiple\", \"processing\", \"processingmultiple\", \"uploadprogress\", \"totaluploadprogress\", \"sending\", \"sendingmultiple\", \"success\", \"successmultiple\", \"canceled\", \"canceledmultiple\", \"complete\", \"completemultiple\", \"reset\", \"maxfilesexceeded\", \"maxfilesreached\", \"queuecomplete\"];\n\n      this.prototype.defaultOptions = {\n        /**\n         * Has to be specified on elements other than form (or when the form\n         * doesn't have an `action` attribute). You can also\n         * provide a function that will be called with `files` and\n         * must return the url (since `v3.12.0`)\n         */\n        url: null,\n\n        /**\n         * Can be changed to `\"put\"` if necessary. You can also provide a function\n         * that will be called with `files` and must return the method (since `v3.12.0`).\n         */\n        method: \"post\",\n\n        /**\n         * Will be set on the XHRequest.\n         */\n        withCredentials: false,\n\n        /**\n         * The timeout for the XHR requests in milliseconds (since `v4.4.0`).\n         */\n        timeout: 30000,\n\n        /**\n         * How many file uploads to process in parallel (See the\n         * Enqueuing file uploads* documentation section for more info)\n         */\n        parallelUploads: 2,\n\n        /**\n         * Whether to send multiple files in one request. If\n         * this it set to true, then the fallback file input element will\n         * have the `multiple` attribute as well. This option will\n         * also trigger additional events (like `processingmultiple`). See the events\n         * documentation section for more information.\n         */\n        uploadMultiple: false,\n\n        /**\n         * Whether you want files to be uploaded in chunks to your server. This can't be\n         * used in combination with `uploadMultiple`.\n         *\n         * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.\n         */\n        chunking: false,\n\n        /**\n         * If `chunking` is enabled, this defines whether **every** file should be chunked,\n         * even if the file size is below chunkSize. This means, that the additional chunk\n         * form data will be submitted and the `chunksUploaded` callback will be invoked.\n         */\n        forceChunking: false,\n\n        /**\n         * If `chunking` is `true`, then this defines the chunk size in bytes.\n         */\n        chunkSize: 2000000,\n\n        /**\n         * If `true`, the individual chunks of a file are being uploaded simultaneously.\n         */\n        parallelChunkUploads: false,\n\n        /**\n         * Whether a chunk should be retried if it fails.\n         */\n        retryChunks: false,\n\n        /**\n         * If `retryChunks` is true, how many times should it be retried.\n         */\n        retryChunksLimit: 3,\n\n        /**\n         * If not `null` defines how many files this Dropzone handles. If it exceeds,\n         * the event `maxfilesexceeded` will be called. The dropzone element gets the\n         * class `dz-max-files-reached` accordingly so you can provide visual feedback.\n         */\n        maxFilesize: 256,\n\n        /**\n         * The name of the file param that gets transferred.\n         * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then\n         * Dropzone will append `[]` to the name.\n         */\n        paramName: \"file\",\n\n        /**\n         * Whether thumbnails for images should be generated\n         */\n        createImageThumbnails: true,\n\n        /**\n         * In MB. When the filename exceeds this limit, the thumbnail will not be generated.\n         */\n        maxThumbnailFilesize: 10,\n\n        /**\n         * If `null`, the ratio of the image will be used to calculate it.\n         */\n        thumbnailWidth: 120,\n\n        /**\n         * The same as `thumbnailWidth`. If both are null, images will not be resized.\n         */\n        thumbnailHeight: 120,\n\n        /**\n         * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.\n         * Can be either `contain` or `crop`.\n         */\n        thumbnailMethod: 'crop',\n\n        /**\n         * If set, images will be resized to these dimensions before being **uploaded**.\n         * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect\n         * ratio of the file will be preserved.\n         *\n         * The `options.transformFile` function uses these options, so if the `transformFile` function\n         * is overridden, these options don't do anything.\n         */\n        resizeWidth: null,\n\n        /**\n         * See `resizeWidth`.\n         */\n        resizeHeight: null,\n\n        /**\n         * The mime type of the resized image (before it gets uploaded to the server).\n         * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.\n         * See `resizeWidth` for more information.\n         */\n        resizeMimeType: null,\n\n        /**\n         * The quality of the resized images. See `resizeWidth`.\n         */\n        resizeQuality: 0.8,\n\n        /**\n         * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.\n         * Can be either `contain` or `crop`.\n         */\n        resizeMethod: 'contain',\n\n        /**\n         * The base that is used to calculate the filesize. You can change this to\n         * 1024 if you would rather display kibibytes, mebibytes, etc...\n         * 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte` not `1 kilobyte`.\n         * You can change this to `1024` if you don't care about validity.\n         */\n        filesizeBase: 1000,\n\n        /**\n         * Can be used to limit the maximum number of files that will be handled by this Dropzone\n         */\n        maxFiles: null,\n\n        /**\n         * An optional object to send additional headers to the server. Eg:\n         * `{ \"My-Awesome-Header\": \"header value\" }`\n         */\n        headers: null,\n\n        /**\n         * If `true`, the dropzone element itself will be clickable, if `false`\n         * nothing will be clickable.\n         *\n         * You can also pass an HTML element, a CSS selector (for multiple elements)\n         * or an array of those. In that case, all of those elements will trigger an\n         * upload when clicked.\n         */\n        clickable: true,\n\n        /**\n         * Whether hidden files in directories should be ignored.\n         */\n        ignoreHiddenFiles: true,\n\n        /**\n         * The default implementation of `accept` checks the file's mime type or\n         * extension against this list. This is a comma separated list of mime\n         * types or file extensions.\n         *\n         * Eg.: `image/*,application/pdf,.psd`\n         *\n         * If the Dropzone is `clickable` this option will also be used as\n         * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)\n         * parameter on the hidden file input as well.\n         */\n        acceptedFiles: null,\n\n        /**\n         * **Deprecated!**\n         * Use acceptedFiles instead.\n         */\n        acceptedMimeTypes: null,\n\n        /**\n         * If false, files will be added to the queue but the queue will not be\n         * processed automatically.\n         * This can be useful if you need some additional user input before sending\n         * files (or if you want want all files sent at once).\n         * If you're ready to send the file simply call `myDropzone.processQueue()`.\n         *\n         * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation\n         * section for more information.\n         */\n        autoProcessQueue: true,\n\n        /**\n         * If false, files added to the dropzone will not be queued by default.\n         * You'll have to call `enqueueFile(file)` manually.\n         */\n        autoQueue: true,\n\n        /**\n         * If `true`, this will add a link to every file preview to remove or cancel (if\n         * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`\n         * and `dictRemoveFile` options are used for the wording.\n         */\n        addRemoveLinks: false,\n\n        /**\n         * Defines where to display the file previews â€“ if `null` the\n         * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS\n         * selector. The element should have the `dropzone-previews` class so\n         * the previews are displayed properly.\n         */\n        previewsContainer: null,\n\n        /**\n         * This is the element the hidden input field (which is used when clicking on the\n         * dropzone to trigger file selection) will be appended to. This might\n         * be important in case you use frameworks to switch the content of your page.\n         *\n         * Can be a selector string, or an element directly.\n         */\n        hiddenInputContainer: \"body\",\n\n        /**\n         * If null, no capture type will be specified\n         * If camera, mobile devices will skip the file selection and choose camera\n         * If microphone, mobile devices will skip the file selection and choose the microphone\n         * If camcorder, mobile devices will skip the file selection and choose the camera in video mode\n         * On apple devices multiple must be set to false.  AcceptedFiles may need to\n         * be set to an appropriate mime type (e.g. \"image/*\", \"audio/*\", or \"video/*\").\n         */\n        capture: null,\n\n        /**\n         * **Deprecated**. Use `renameFile` instead.\n         */\n        renameFilename: null,\n\n        /**\n         * A function that is invoked before the file is uploaded to the server and renames the file.\n         * This function gets the `File` as argument and can use the `file.name`. The actual name of the\n         * file that gets used during the upload can be accessed through `file.upload.filename`.\n         */\n        renameFile: null,\n\n        /**\n         * If `true` the fallback will be forced. This is very useful to test your server\n         * implementations first and make sure that everything works as\n         * expected without dropzone if you experience problems, and to test\n         * how your fallbacks will look.\n         */\n        forceFallback: false,\n\n        /**\n         * The text used before any files are dropped.\n         */\n        dictDefaultMessage: \"Drop files here to upload\",\n\n        /**\n         * The text that replaces the default message text it the browser is not supported.\n         */\n        dictFallbackMessage: \"Your browser does not support drag'n'drop file uploads.\",\n\n        /**\n         * The text that will be added before the fallback form.\n         * If you provide a  fallback element yourself, or if this option is `null` this will\n         * be ignored.\n         */\n        dictFallbackText: \"Please use the fallback form below to upload your files like in the olden days.\",\n\n        /**\n         * If the filesize is too big.\n         * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.\n         */\n        dictFileTooBig: \"File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.\",\n\n        /**\n         * If the file doesn't match the file type.\n         */\n        dictInvalidFileType: \"You can't upload files of this type.\",\n\n        /**\n         * If the server response was invalid.\n         * `{{statusCode}}` will be replaced with the servers status code.\n         */\n        dictResponseError: \"Server responded with {{statusCode}} code.\",\n\n        /**\n         * If `addRemoveLinks` is true, the text to be used for the cancel upload link.\n         */\n        dictCancelUpload: \"Cancel upload\",\n\n        /**\n         * The text that is displayed if an upload was manually canceled\n         */\n        dictUploadCanceled: \"Upload canceled.\",\n\n        /**\n         * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.\n         */\n        dictCancelUploadConfirmation: \"Are you sure you want to cancel this upload?\",\n\n        /**\n         * If `addRemoveLinks` is true, the text to be used to remove a file.\n         */\n        dictRemoveFile: \"Remove file\",\n\n        /**\n         * If this is not null, then the user will be prompted before removing a file.\n         */\n        dictRemoveFileConfirmation: null,\n\n        /**\n         * Displayed if `maxFiles` is st and exceeded.\n         * The string `{{maxFiles}}` will be replaced by the configuration value.\n         */\n        dictMaxFilesExceeded: \"You can not upload any more files.\",\n\n        /**\n         * Allows you to translate the different units. Starting with `tb` for terabytes and going down to\n         * `b` for bytes.\n         */\n        dictFileSizeUnits: { tb: \"TB\", gb: \"GB\", mb: \"MB\", kb: \"KB\", b: \"b\" },\n        /**\n         * Called when dropzone initialized\n         * You can add event listeners here\n         */\n        init: function init() {},\n\n\n        /**\n         * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`\n         * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case\n         * of a function, this needs to return a map.\n         *\n         * The default implementation does nothing for normal uploads, but adds relevant information for\n         * chunked uploads.\n         *\n         * This is the same as adding hidden input fields in the form element.\n         */\n        params: function params(files, xhr, chunk) {\n          if (chunk) {\n            return {\n              dzuuid: chunk.file.upload.uuid,\n              dzchunkindex: chunk.index,\n              dztotalfilesize: chunk.file.size,\n              dzchunksize: this.options.chunkSize,\n              dztotalchunkcount: chunk.file.upload.totalChunkCount,\n              dzchunkbyteoffset: chunk.index * this.options.chunkSize\n            };\n          }\n        },\n\n\n        /**\n         * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)\n         * and a `done` function as parameters.\n         *\n         * If the done function is invoked without arguments, the file is \"accepted\" and will\n         * be processed. If you pass an error message, the file is rejected, and the error\n         * message will be displayed.\n         * This function will not be called if the file is too big or doesn't match the mime types.\n         */\n        accept: function accept(file, done) {\n          return done();\n        },\n\n\n        /**\n         * The callback that will be invoked when all chunks have been uploaded for a file.\n         * It gets the file for which the chunks have been uploaded as the first parameter,\n         * and the `done` function as second. `done()` needs to be invoked when everything\n         * needed to finish the upload process is done.\n         */\n        chunksUploaded: function chunksUploaded(file, done) {\n          done();\n        },\n\n        /**\n         * Gets called when the browser is not supported.\n         * The default implementation shows the fallback input field and adds\n         * a text.\n         */\n        fallback: function fallback() {\n          // This code should pass in IE7... :(\n          var messageElement = void 0;\n          this.element.className = this.element.className + \" dz-browser-not-supported\";\n\n          for (var _iterator2 = this.element.getElementsByTagName(\"div\"), _isArray2 = true, _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n            var _ref2;\n\n            if (_isArray2) {\n              if (_i2 >= _iterator2.length) break;\n              _ref2 = _iterator2[_i2++];\n            } else {\n              _i2 = _iterator2.next();\n              if (_i2.done) break;\n              _ref2 = _i2.value;\n            }\n\n            var child = _ref2;\n\n            if (/(^| )dz-message($| )/.test(child.className)) {\n              messageElement = child;\n              child.className = \"dz-message\"; // Removes the 'dz-default' class\n              break;\n            }\n          }\n          if (!messageElement) {\n            messageElement = Dropzone.createElement(\"<div class=\\\"dz-message\\\"><span></span></div>\");\n            this.element.appendChild(messageElement);\n          }\n\n          var span = messageElement.getElementsByTagName(\"span\")[0];\n          if (span) {\n            if (span.textContent != null) {\n              span.textContent = this.options.dictFallbackMessage;\n            } else if (span.innerText != null) {\n              span.innerText = this.options.dictFallbackMessage;\n            }\n          }\n\n          return this.element.appendChild(this.getFallbackForm());\n        },\n\n\n        /**\n         * Gets called to calculate the thumbnail dimensions.\n         *\n         * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:\n         *\n         *  - `srcWidth` & `srcHeight` (required)\n         *  - `trgWidth` & `trgHeight` (required)\n         *  - `srcX` & `srcY` (optional, default `0`)\n         *  - `trgX` & `trgY` (optional, default `0`)\n         *\n         * Those values are going to be used by `ctx.drawImage()`.\n         */\n        resize: function resize(file, width, height, resizeMethod) {\n          var info = {\n            srcX: 0,\n            srcY: 0,\n            srcWidth: file.width,\n            srcHeight: file.height\n          };\n\n          var srcRatio = file.width / file.height;\n\n          // Automatically calculate dimensions if not specified\n          if (width == null && height == null) {\n            width = info.srcWidth;\n            height = info.srcHeight;\n          } else if (width == null) {\n            width = height * srcRatio;\n          } else if (height == null) {\n            height = width / srcRatio;\n          }\n\n          // Make sure images aren't upscaled\n          width = Math.min(width, info.srcWidth);\n          height = Math.min(height, info.srcHeight);\n\n          var trgRatio = width / height;\n\n          if (info.srcWidth > width || info.srcHeight > height) {\n            // Image is bigger and needs rescaling\n            if (resizeMethod === 'crop') {\n              if (srcRatio > trgRatio) {\n                info.srcHeight = file.height;\n                info.srcWidth = info.srcHeight * trgRatio;\n              } else {\n                info.srcWidth = file.width;\n                info.srcHeight = info.srcWidth / trgRatio;\n              }\n            } else if (resizeMethod === 'contain') {\n              // Method 'contain'\n              if (srcRatio > trgRatio) {\n                height = width / srcRatio;\n              } else {\n                width = height * srcRatio;\n              }\n            } else {\n              throw new Error(\"Unknown resizeMethod '\" + resizeMethod + \"'\");\n            }\n          }\n\n          info.srcX = (file.width - info.srcWidth) / 2;\n          info.srcY = (file.height - info.srcHeight) / 2;\n\n          info.trgWidth = width;\n          info.trgHeight = height;\n\n          return info;\n        },\n\n\n        /**\n         * Can be used to transform the file (for example, resize an image if necessary).\n         *\n         * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes\n         * images according to those dimensions.\n         *\n         * Gets the `file` as the first parameter, and a `done()` function as the second, that needs\n         * to be invoked with the file when the transformation is done.\n         */\n        transformFile: function transformFile(file, done) {\n          if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) {\n            return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);\n          } else {\n            return done(file);\n          }\n        },\n\n\n        /**\n         * A string that contains the template used for each dropped\n         * file. Change it to fulfill your needs but make sure to properly\n         * provide all elements.\n         *\n         * If you want to use an actual HTML element instead of providing a String\n         * as a config option, you could create a div with the id `tpl`,\n         * put the template inside it and provide the element like this:\n         *\n         *     document\n         *       .querySelector('#tpl')\n         *       .innerHTML\n         *\n         */\n        previewTemplate: \"<div class=\\\"dz-preview dz-file-preview\\\">\\n  <div class=\\\"dz-image\\\"><img data-dz-thumbnail /></div>\\n  <div class=\\\"dz-details\\\">\\n    <div class=\\\"dz-size\\\"><span data-dz-size></span></div>\\n    <div class=\\\"dz-filename\\\"><span data-dz-name></span></div>\\n  </div>\\n  <div class=\\\"dz-progress\\\"><span class=\\\"dz-upload\\\" data-dz-uploadprogress></span></div>\\n  <div class=\\\"dz-error-message\\\"><span data-dz-errormessage></span></div>\\n  <div class=\\\"dz-success-mark\\\">\\n    <svg width=\\\"54px\\\" height=\\\"54px\\\" viewBox=\\\"0 0 54 54\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xmlns:sketch=\\\"http://www.bohemiancoding.com/sketch/ns\\\">\\n      <title>Check</title>\\n      <defs></defs>\\n      <g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\" sketch:type=\\\"MSPage\\\">\\n        <path d=\\\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\\\" id=\\\"Oval-2\\\" stroke-opacity=\\\"0.198794158\\\" stroke=\\\"#747474\\\" fill-opacity=\\\"0.816519475\\\" fill=\\\"#FFFFFF\\\" sketch:type=\\\"MSShapeGroup\\\"></path>\\n      </g>\\n    </svg>\\n  </div>\\n  <div class=\\\"dz-error-mark\\\">\\n    <svg width=\\\"54px\\\" height=\\\"54px\\\" viewBox=\\\"0 0 54 54\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" xmlns:sketch=\\\"http://www.bohemiancoding.com/sketch/ns\\\">\\n      <title>Error</title>\\n      <defs></defs>\\n      <g id=\\\"Page-1\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\" sketch:type=\\\"MSPage\\\">\\n        <g id=\\\"Check-+-Oval-2\\\" sketch:type=\\\"MSLayerGroup\\\" stroke=\\\"#747474\\\" stroke-opacity=\\\"0.198794158\\\" fill=\\\"#FFFFFF\\\" fill-opacity=\\\"0.816519475\\\">\\n          <path d=\\\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\\\" id=\\\"Oval-2\\\" sketch:type=\\\"MSShapeGroup\\\"></path>\\n        </g>\\n      </g>\\n    </svg>\\n  </div>\\n</div>\",\n\n        // END OPTIONS\n        // (Required by the dropzone documentation parser)\n\n\n        /*\n         Those functions register themselves to the events on init and handle all\n         the user interface specific stuff. Overwriting them won't break the upload\n         but can break the way it's displayed.\n         You can overwrite them if you don't like the default behavior. If you just\n         want to add an additional event handler, register it on the dropzone object\n         and don't overwrite those options.\n         */\n\n        // Those are self explanatory and simply concern the DragnDrop.\n        drop: function drop(e) {\n          return this.element.classList.remove(\"dz-drag-hover\");\n        },\n        dragstart: function dragstart(e) {},\n        dragend: function dragend(e) {\n          return this.element.classList.remove(\"dz-drag-hover\");\n        },\n        dragenter: function dragenter(e) {\n          return this.element.classList.add(\"dz-drag-hover\");\n        },\n        dragover: function dragover(e) {\n          return this.element.classList.add(\"dz-drag-hover\");\n        },\n        dragleave: function dragleave(e) {\n          return this.element.classList.remove(\"dz-drag-hover\");\n        },\n        paste: function paste(e) {},\n\n\n        // Called whenever there are no files left in the dropzone anymore, and the\n        // dropzone should be displayed as if in the initial state.\n        reset: function reset() {\n          return this.element.classList.remove(\"dz-started\");\n        },\n\n\n        // Called when a file is added to the queue\n        // Receives `file`\n        addedfile: function addedfile(file) {\n          var _this2 = this;\n\n          if (this.element === this.previewsContainer) {\n            this.element.classList.add(\"dz-started\");\n          }\n\n          if (this.previewsContainer) {\n            file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());\n            file.previewTemplate = file.previewElement; // Backwards compatibility\n\n            this.previewsContainer.appendChild(file.previewElement);\n            for (var _iterator3 = file.previewElement.querySelectorAll(\"[data-dz-name]\"), _isArray3 = true, _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n              var _ref3;\n\n              if (_isArray3) {\n                if (_i3 >= _iterator3.length) break;\n                _ref3 = _iterator3[_i3++];\n              } else {\n                _i3 = _iterator3.next();\n                if (_i3.done) break;\n                _ref3 = _i3.value;\n              }\n\n              var node = _ref3;\n\n              node.textContent = file.name;\n            }\n            for (var _iterator4 = file.previewElement.querySelectorAll(\"[data-dz-size]\"), _isArray4 = true, _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n              if (_isArray4) {\n                if (_i4 >= _iterator4.length) break;\n                node = _iterator4[_i4++];\n              } else {\n                _i4 = _iterator4.next();\n                if (_i4.done) break;\n                node = _i4.value;\n              }\n\n              node.innerHTML = this.filesize(file.size);\n            }\n\n            if (this.options.addRemoveLinks) {\n              file._removeLink = Dropzone.createElement(\"<a class=\\\"dz-remove\\\" href=\\\"javascript:undefined;\\\" data-dz-remove>\" + this.options.dictRemoveFile + \"</a>\");\n              file.previewElement.appendChild(file._removeLink);\n            }\n\n            var removeFileEvent = function removeFileEvent(e) {\n              e.preventDefault();\n              e.stopPropagation();\n              if (file.status === Dropzone.UPLOADING) {\n                return Dropzone.confirm(_this2.options.dictCancelUploadConfirmation, function () {\n                  return _this2.removeFile(file);\n                });\n              } else {\n                if (_this2.options.dictRemoveFileConfirmation) {\n                  return Dropzone.confirm(_this2.options.dictRemoveFileConfirmation, function () {\n                    return _this2.removeFile(file);\n                  });\n                } else {\n                  return _this2.removeFile(file);\n                }\n              }\n            };\n\n            for (var _iterator5 = file.previewElement.querySelectorAll(\"[data-dz-remove]\"), _isArray5 = true, _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n              var _ref4;\n\n              if (_isArray5) {\n                if (_i5 >= _iterator5.length) break;\n                _ref4 = _iterator5[_i5++];\n              } else {\n                _i5 = _iterator5.next();\n                if (_i5.done) break;\n                _ref4 = _i5.value;\n              }\n\n              var removeLink = _ref4;\n\n              removeLink.addEventListener(\"click\", removeFileEvent);\n            }\n          }\n        },\n\n\n        // Called whenever a file is removed.\n        removedfile: function removedfile(file) {\n          if (file.previewElement != null && file.previewElement.parentNode != null) {\n            file.previewElement.parentNode.removeChild(file.previewElement);\n          }\n          return this._updateMaxFilesReachedClass();\n        },\n\n\n        // Called when a thumbnail has been generated\n        // Receives `file` and `dataUrl`\n        thumbnail: function thumbnail(file, dataUrl) {\n          if (file.previewElement) {\n            file.previewElement.classList.remove(\"dz-file-preview\");\n            for (var _iterator6 = file.previewElement.querySelectorAll(\"[data-dz-thumbnail]\"), _isArray6 = true, _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n              var _ref5;\n\n              if (_isArray6) {\n                if (_i6 >= _iterator6.length) break;\n                _ref5 = _iterator6[_i6++];\n              } else {\n                _i6 = _iterator6.next();\n                if (_i6.done) break;\n                _ref5 = _i6.value;\n              }\n\n              var thumbnailElement = _ref5;\n\n              thumbnailElement.alt = file.name;\n              thumbnailElement.src = dataUrl;\n            }\n\n            return setTimeout(function () {\n              return file.previewElement.classList.add(\"dz-image-preview\");\n            }, 1);\n          }\n        },\n\n\n        // Called whenever an error occurs\n        // Receives `file` and `message`\n        error: function error(file, message) {\n          if (file.previewElement) {\n            file.previewElement.classList.add(\"dz-error\");\n            if (typeof message !== \"String\" && message.error) {\n              message = message.error;\n            }\n            for (var _iterator7 = file.previewElement.querySelectorAll(\"[data-dz-errormessage]\"), _isArray7 = true, _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\n              var _ref6;\n\n              if (_isArray7) {\n                if (_i7 >= _iterator7.length) break;\n                _ref6 = _iterator7[_i7++];\n              } else {\n                _i7 = _iterator7.next();\n                if (_i7.done) break;\n                _ref6 = _i7.value;\n              }\n\n              var node = _ref6;\n\n              node.textContent = message;\n            }\n          }\n        },\n        errormultiple: function errormultiple() {},\n\n\n        // Called when a file gets processed. Since there is a cue, not all added\n        // files are processed immediately.\n        // Receives `file`\n        processing: function processing(file) {\n          if (file.previewElement) {\n            file.previewElement.classList.add(\"dz-processing\");\n            if (file._removeLink) {\n              return file._removeLink.innerHTML = this.options.dictCancelUpload;\n            }\n          }\n        },\n        processingmultiple: function processingmultiple() {},\n\n\n        // Called whenever the upload progress gets updated.\n        // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.\n        // To get the total number of bytes of the file, use `file.size`\n        uploadprogress: function uploadprogress(file, progress, bytesSent) {\n          if (file.previewElement) {\n            for (var _iterator8 = file.previewElement.querySelectorAll(\"[data-dz-uploadprogress]\"), _isArray8 = true, _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {\n              var _ref7;\n\n              if (_isArray8) {\n                if (_i8 >= _iterator8.length) break;\n                _ref7 = _iterator8[_i8++];\n              } else {\n                _i8 = _iterator8.next();\n                if (_i8.done) break;\n                _ref7 = _i8.value;\n              }\n\n              var node = _ref7;\n\n              node.nodeName === 'PROGRESS' ? node.value = progress : node.style.width = progress + \"%\";\n            }\n          }\n        },\n\n\n        // Called whenever the total upload progress gets updated.\n        // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent\n        totaluploadprogress: function totaluploadprogress() {},\n\n\n        // Called just before the file is sent. Gets the `xhr` object as second\n        // parameter, so you can modify it (for example to add a CSRF token) and a\n        // `formData` object to add additional information.\n        sending: function sending() {},\n        sendingmultiple: function sendingmultiple() {},\n\n\n        // When the complete upload is finished and successful\n        // Receives `file`\n        success: function success(file) {\n          if (file.previewElement) {\n            return file.previewElement.classList.add(\"dz-success\");\n          }\n        },\n        successmultiple: function successmultiple() {},\n\n\n        // When the upload is canceled.\n        canceled: function canceled(file) {\n          return this.emit(\"error\", file, this.options.dictUploadCanceled);\n        },\n        canceledmultiple: function canceledmultiple() {},\n\n\n        // When the upload is finished, either with success or an error.\n        // Receives `file`\n        complete: function complete(file) {\n          if (file._removeLink) {\n            file._removeLink.innerHTML = this.options.dictRemoveFile;\n          }\n          if (file.previewElement) {\n            return file.previewElement.classList.add(\"dz-complete\");\n          }\n        },\n        completemultiple: function completemultiple() {},\n        maxfilesexceeded: function maxfilesexceeded() {},\n        maxfilesreached: function maxfilesreached() {},\n        queuecomplete: function queuecomplete() {},\n        addedfiles: function addedfiles() {}\n      };\n\n      this.prototype._thumbnailQueue = [];\n      this.prototype._processingThumbnail = false;\n    }\n\n    // global utility\n\n  }, {\n    key: \"extend\",\n    value: function extend(target) {\n      for (var _len2 = arguments.length, objects = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        objects[_key2 - 1] = arguments[_key2];\n      }\n\n      for (var _iterator9 = objects, _isArray9 = true, _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {\n        var _ref8;\n\n        if (_isArray9) {\n          if (_i9 >= _iterator9.length) break;\n          _ref8 = _iterator9[_i9++];\n        } else {\n          _i9 = _iterator9.next();\n          if (_i9.done) break;\n          _ref8 = _i9.value;\n        }\n\n        var object = _ref8;\n\n        for (var key in object) {\n          var val = object[key];\n          target[key] = val;\n        }\n      }\n      return target;\n    }\n  }]);\n\n  function Dropzone(el, options) {\n    _classCallCheck(this, Dropzone);\n\n    var _this = _possibleConstructorReturn(this, (Dropzone.__proto__ || Object.getPrototypeOf(Dropzone)).call(this));\n\n    var fallback = void 0,\n        left = void 0;\n    _this.element = el;\n    // For backwards compatibility since the version was in the prototype previously\n    _this.version = Dropzone.version;\n\n    _this.defaultOptions.previewTemplate = _this.defaultOptions.previewTemplate.replace(/\\n*/g, \"\");\n\n    _this.clickableElements = [];\n    _this.listeners = [];\n    _this.files = []; // All files\n\n    if (typeof _this.element === \"string\") {\n      _this.element = document.querySelector(_this.element);\n    }\n\n    // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.\n    if (!_this.element || _this.element.nodeType == null) {\n      throw new Error(\"Invalid dropzone element.\");\n    }\n\n    if (_this.element.dropzone) {\n      throw new Error(\"Dropzone already attached.\");\n    }\n\n    // Now add this dropzone to the instances.\n    Dropzone.instances.push(_this);\n\n    // Put the dropzone inside the element itself.\n    _this.element.dropzone = _this;\n\n    var elementOptions = (left = Dropzone.optionsForElement(_this.element)) != null ? left : {};\n\n    _this.options = Dropzone.extend({}, _this.defaultOptions, elementOptions, options != null ? options : {});\n\n    // If the browser failed, just call the fallback and leave\n    if (_this.options.forceFallback || !Dropzone.isBrowserSupported()) {\n      var _ret;\n\n      return _ret = _this.options.fallback.call(_this), _possibleConstructorReturn(_this, _ret);\n    }\n\n    // @options.url = @element.getAttribute \"action\" unless @options.url?\n    if (_this.options.url == null) {\n      _this.options.url = _this.element.getAttribute(\"action\");\n    }\n\n    if (!_this.options.url) {\n      throw new Error(\"No URL provided.\");\n    }\n\n    if (_this.options.acceptedFiles && _this.options.acceptedMimeTypes) {\n      throw new Error(\"You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.\");\n    }\n\n    if (_this.options.uploadMultiple && _this.options.chunking) {\n      throw new Error('You cannot set both: uploadMultiple and chunking.');\n    }\n\n    // Backwards compatibility\n    if (_this.options.acceptedMimeTypes) {\n      _this.options.acceptedFiles = _this.options.acceptedMimeTypes;\n      delete _this.options.acceptedMimeTypes;\n    }\n\n    // Backwards compatibility\n    if (_this.options.renameFilename != null) {\n      _this.options.renameFile = function (file) {\n        return _this.options.renameFilename.call(_this, file.name, file);\n      };\n    }\n\n    _this.options.method = _this.options.method.toUpperCase();\n\n    if ((fallback = _this.getExistingFallback()) && fallback.parentNode) {\n      // Remove the fallback\n      fallback.parentNode.removeChild(fallback);\n    }\n\n    // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false\n    if (_this.options.previewsContainer !== false) {\n      if (_this.options.previewsContainer) {\n        _this.previewsContainer = Dropzone.getElement(_this.options.previewsContainer, \"previewsContainer\");\n      } else {\n        _this.previewsContainer = _this.element;\n      }\n    }\n\n    if (_this.options.clickable) {\n      if (_this.options.clickable === true) {\n        _this.clickableElements = [_this.element];\n      } else {\n        _this.clickableElements = Dropzone.getElements(_this.options.clickable, \"clickable\");\n      }\n    }\n\n    _this.init();\n    return _this;\n  }\n\n  // Returns all files that have been accepted\n\n\n  _createClass(Dropzone, [{\n    key: \"getAcceptedFiles\",\n    value: function getAcceptedFiles() {\n      return this.files.filter(function (file) {\n        return file.accepted;\n      }).map(function (file) {\n        return file;\n      });\n    }\n\n    // Returns all files that have been rejected\n    // Not sure when that's going to be useful, but added for completeness.\n\n  }, {\n    key: \"getRejectedFiles\",\n    value: function getRejectedFiles() {\n      return this.files.filter(function (file) {\n        return !file.accepted;\n      }).map(function (file) {\n        return file;\n      });\n    }\n  }, {\n    key: \"getFilesWithStatus\",\n    value: function getFilesWithStatus(status) {\n      return this.files.filter(function (file) {\n        return file.status === status;\n      }).map(function (file) {\n        return file;\n      });\n    }\n\n    // Returns all files that are in the queue\n\n  }, {\n    key: \"getQueuedFiles\",\n    value: function getQueuedFiles() {\n      return this.getFilesWithStatus(Dropzone.QUEUED);\n    }\n  }, {\n    key: \"getUploadingFiles\",\n    value: function getUploadingFiles() {\n      return this.getFilesWithStatus(Dropzone.UPLOADING);\n    }\n  }, {\n    key: \"getAddedFiles\",\n    value: function getAddedFiles() {\n      return this.getFilesWithStatus(Dropzone.ADDED);\n    }\n\n    // Files that are either queued or uploading\n\n  }, {\n    key: \"getActiveFiles\",\n    value: function getActiveFiles() {\n      return this.files.filter(function (file) {\n        return file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED;\n      }).map(function (file) {\n        return file;\n      });\n    }\n\n    // The function that gets called when Dropzone is initialized. You\n    // can (and should) setup event listeners inside this function.\n\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this3 = this;\n\n      // In case it isn't set already\n      if (this.element.tagName === \"form\") {\n        this.element.setAttribute(\"enctype\", \"multipart/form-data\");\n      }\n\n      if (this.element.classList.contains(\"dropzone\") && !this.element.querySelector(\".dz-message\")) {\n        this.element.appendChild(Dropzone.createElement(\"<div class=\\\"dz-default dz-message\\\"><span>\" + this.options.dictDefaultMessage + \"</span></div>\"));\n      }\n\n      if (this.clickableElements.length) {\n        var setupHiddenFileInput = function setupHiddenFileInput() {\n          if (_this3.hiddenFileInput) {\n            _this3.hiddenFileInput.parentNode.removeChild(_this3.hiddenFileInput);\n          }\n          _this3.hiddenFileInput = document.createElement(\"input\");\n          _this3.hiddenFileInput.setAttribute(\"type\", \"file\");\n          if (_this3.options.maxFiles === null || _this3.options.maxFiles > 1) {\n            _this3.hiddenFileInput.setAttribute(\"multiple\", \"multiple\");\n          }\n          _this3.hiddenFileInput.className = \"dz-hidden-input\";\n\n          if (_this3.options.acceptedFiles !== null) {\n            _this3.hiddenFileInput.setAttribute(\"accept\", _this3.options.acceptedFiles);\n          }\n          if (_this3.options.capture !== null) {\n            _this3.hiddenFileInput.setAttribute(\"capture\", _this3.options.capture);\n          }\n\n          // Not setting `display=\"none\"` because some browsers don't accept clicks\n          // on elements that aren't displayed.\n          _this3.hiddenFileInput.style.visibility = \"hidden\";\n          _this3.hiddenFileInput.style.position = \"absolute\";\n          _this3.hiddenFileInput.style.top = \"0\";\n          _this3.hiddenFileInput.style.left = \"0\";\n          _this3.hiddenFileInput.style.height = \"0\";\n          _this3.hiddenFileInput.style.width = \"0\";\n          Dropzone.getElement(_this3.options.hiddenInputContainer, 'hiddenInputContainer').appendChild(_this3.hiddenFileInput);\n          return _this3.hiddenFileInput.addEventListener(\"change\", function () {\n            var files = _this3.hiddenFileInput.files;\n\n            if (files.length) {\n              for (var _iterator10 = files, _isArray10 = true, _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {\n                var _ref9;\n\n                if (_isArray10) {\n                  if (_i10 >= _iterator10.length) break;\n                  _ref9 = _iterator10[_i10++];\n                } else {\n                  _i10 = _iterator10.next();\n                  if (_i10.done) break;\n                  _ref9 = _i10.value;\n                }\n\n                var file = _ref9;\n\n                _this3.addFile(file);\n              }\n            }\n            _this3.emit(\"addedfiles\", files);\n            return setupHiddenFileInput();\n          });\n        };\n        setupHiddenFileInput();\n      }\n\n      this.URL = window.URL !== null ? window.URL : window.webkitURL;\n\n      // Setup all event listeners on the Dropzone object itself.\n      // They're not in @setupEventListeners() because they shouldn't be removed\n      // again when the dropzone gets disabled.\n      for (var _iterator11 = this.events, _isArray11 = true, _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {\n        var _ref10;\n\n        if (_isArray11) {\n          if (_i11 >= _iterator11.length) break;\n          _ref10 = _iterator11[_i11++];\n        } else {\n          _i11 = _iterator11.next();\n          if (_i11.done) break;\n          _ref10 = _i11.value;\n        }\n\n        var eventName = _ref10;\n\n        this.on(eventName, this.options[eventName]);\n      }\n\n      this.on(\"uploadprogress\", function () {\n        return _this3.updateTotalUploadProgress();\n      });\n\n      this.on(\"removedfile\", function () {\n        return _this3.updateTotalUploadProgress();\n      });\n\n      this.on(\"canceled\", function (file) {\n        return _this3.emit(\"complete\", file);\n      });\n\n      // Emit a `queuecomplete` event if all files finished uploading.\n      this.on(\"complete\", function (file) {\n        if (_this3.getAddedFiles().length === 0 && _this3.getUploadingFiles().length === 0 && _this3.getQueuedFiles().length === 0) {\n          // This needs to be deferred so that `queuecomplete` really triggers after `complete`\n          return setTimeout(function () {\n            return _this3.emit(\"queuecomplete\");\n          }, 0);\n        }\n      });\n\n      var noPropagation = function noPropagation(e) {\n        e.stopPropagation();\n        if (e.preventDefault) {\n          return e.preventDefault();\n        } else {\n          return e.returnValue = false;\n        }\n      };\n\n      // Create the listeners\n      this.listeners = [{\n        element: this.element,\n        events: {\n          \"dragstart\": function dragstart(e) {\n            return _this3.emit(\"dragstart\", e);\n          },\n          \"dragenter\": function dragenter(e) {\n            noPropagation(e);\n            return _this3.emit(\"dragenter\", e);\n          },\n          \"dragover\": function dragover(e) {\n            // Makes it possible to drag files from chrome's download bar\n            // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar\n            // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)\n            var efct = void 0;\n            try {\n              efct = e.dataTransfer.effectAllowed;\n            } catch (error) {}\n            e.dataTransfer.dropEffect = 'move' === efct || 'linkMove' === efct ? 'move' : 'copy';\n\n            noPropagation(e);\n            return _this3.emit(\"dragover\", e);\n          },\n          \"dragleave\": function dragleave(e) {\n            return _this3.emit(\"dragleave\", e);\n          },\n          \"drop\": function drop(e) {\n            noPropagation(e);\n            return _this3.drop(e);\n          },\n          \"dragend\": function dragend(e) {\n            return _this3.emit(\"dragend\", e);\n          }\n\n          // This is disabled right now, because the browsers don't implement it properly.\n          // \"paste\": (e) =>\n          //   noPropagation e\n          //   @paste e\n        } }];\n\n      this.clickableElements.forEach(function (clickableElement) {\n        return _this3.listeners.push({\n          element: clickableElement,\n          events: {\n            \"click\": function click(evt) {\n              // Only the actual dropzone or the message element should trigger file selection\n              if (clickableElement !== _this3.element || evt.target === _this3.element || Dropzone.elementInside(evt.target, _this3.element.querySelector(\".dz-message\"))) {\n                _this3.hiddenFileInput.click(); // Forward the click\n              }\n              return true;\n            }\n          }\n        });\n      });\n\n      this.enable();\n\n      return this.options.init.call(this);\n    }\n\n    // Not fully tested yet\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.disable();\n      this.removeAllFiles(true);\n      if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {\n        this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);\n        this.hiddenFileInput = null;\n      }\n      delete this.element.dropzone;\n      return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);\n    }\n  }, {\n    key: \"updateTotalUploadProgress\",\n    value: function updateTotalUploadProgress() {\n      var totalUploadProgress = void 0;\n      var totalBytesSent = 0;\n      var totalBytes = 0;\n\n      var activeFiles = this.getActiveFiles();\n\n      if (activeFiles.length) {\n        for (var _iterator12 = this.getActiveFiles(), _isArray12 = true, _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator]();;) {\n          var _ref11;\n\n          if (_isArray12) {\n            if (_i12 >= _iterator12.length) break;\n            _ref11 = _iterator12[_i12++];\n          } else {\n            _i12 = _iterator12.next();\n            if (_i12.done) break;\n            _ref11 = _i12.value;\n          }\n\n          var file = _ref11;\n\n          totalBytesSent += file.upload.bytesSent;\n          totalBytes += file.upload.total;\n        }\n        totalUploadProgress = 100 * totalBytesSent / totalBytes;\n      } else {\n        totalUploadProgress = 100;\n      }\n\n      return this.emit(\"totaluploadprogress\", totalUploadProgress, totalBytes, totalBytesSent);\n    }\n\n    // @options.paramName can be a function taking one parameter rather than a string.\n    // A parameter name for a file is obtained simply by calling this with an index number.\n\n  }, {\n    key: \"_getParamName\",\n    value: function _getParamName(n) {\n      if (typeof this.options.paramName === \"function\") {\n        return this.options.paramName(n);\n      } else {\n        return \"\" + this.options.paramName + (this.options.uploadMultiple ? \"[\" + n + \"]\" : \"\");\n      }\n    }\n\n    // If @options.renameFile is a function,\n    // the function will be used to rename the file.name before appending it to the formData\n\n  }, {\n    key: \"_renameFile\",\n    value: function _renameFile(file) {\n      if (typeof this.options.renameFile !== \"function\") {\n        return file.name;\n      }\n      return this.options.renameFile(file);\n    }\n\n    // Returns a form that can be used as fallback if the browser does not support DragnDrop\n    //\n    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.\n    // This code has to pass in IE7 :(\n\n  }, {\n    key: \"getFallbackForm\",\n    value: function getFallbackForm() {\n      var existingFallback = void 0,\n          form = void 0;\n      if (existingFallback = this.getExistingFallback()) {\n        return existingFallback;\n      }\n\n      var fieldsString = \"<div class=\\\"dz-fallback\\\">\";\n      if (this.options.dictFallbackText) {\n        fieldsString += \"<p>\" + this.options.dictFallbackText + \"</p>\";\n      }\n      fieldsString += \"<input type=\\\"file\\\" name=\\\"\" + this._getParamName(0) + \"\\\" \" + (this.options.uploadMultiple ? 'multiple=\"multiple\"' : undefined) + \" /><input type=\\\"submit\\\" value=\\\"Upload!\\\"></div>\";\n\n      var fields = Dropzone.createElement(fieldsString);\n      if (this.element.tagName !== \"FORM\") {\n        form = Dropzone.createElement(\"<form action=\\\"\" + this.options.url + \"\\\" enctype=\\\"multipart/form-data\\\" method=\\\"\" + this.options.method + \"\\\"></form>\");\n        form.appendChild(fields);\n      } else {\n        // Make sure that the enctype and method attributes are set properly\n        this.element.setAttribute(\"enctype\", \"multipart/form-data\");\n        this.element.setAttribute(\"method\", this.options.method);\n      }\n      return form != null ? form : fields;\n    }\n\n    // Returns the fallback elements if they exist already\n    //\n    // This code has to pass in IE7 :(\n\n  }, {\n    key: \"getExistingFallback\",\n    value: function getExistingFallback() {\n      var getFallback = function getFallback(elements) {\n        for (var _iterator13 = elements, _isArray13 = true, _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator]();;) {\n          var _ref12;\n\n          if (_isArray13) {\n            if (_i13 >= _iterator13.length) break;\n            _ref12 = _iterator13[_i13++];\n          } else {\n            _i13 = _iterator13.next();\n            if (_i13.done) break;\n            _ref12 = _i13.value;\n          }\n\n          var el = _ref12;\n\n          if (/(^| )fallback($| )/.test(el.className)) {\n            return el;\n          }\n        }\n      };\n\n      var _arr = [\"div\", \"form\"];\n      for (var _i14 = 0; _i14 < _arr.length; _i14++) {\n        var tagName = _arr[_i14];\n        var fallback;\n        if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {\n          return fallback;\n        }\n      }\n    }\n\n    // Activates all listeners stored in @listeners\n\n  }, {\n    key: \"setupEventListeners\",\n    value: function setupEventListeners() {\n      return this.listeners.map(function (elementListeners) {\n        return function () {\n          var result = [];\n          for (var event in elementListeners.events) {\n            var listener = elementListeners.events[event];\n            result.push(elementListeners.element.addEventListener(event, listener, false));\n          }\n          return result;\n        }();\n      });\n    }\n\n    // Deactivates all listeners stored in @listeners\n\n  }, {\n    key: \"removeEventListeners\",\n    value: function removeEventListeners() {\n      return this.listeners.map(function (elementListeners) {\n        return function () {\n          var result = [];\n          for (var event in elementListeners.events) {\n            var listener = elementListeners.events[event];\n            result.push(elementListeners.element.removeEventListener(event, listener, false));\n          }\n          return result;\n        }();\n      });\n    }\n\n    // Removes all event listeners and cancels all files in the queue or being processed.\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      var _this4 = this;\n\n      this.clickableElements.forEach(function (element) {\n        return element.classList.remove(\"dz-clickable\");\n      });\n      this.removeEventListeners();\n      this.disabled = true;\n\n      return this.files.map(function (file) {\n        return _this4.cancelUpload(file);\n      });\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      delete this.disabled;\n      this.clickableElements.forEach(function (element) {\n        return element.classList.add(\"dz-clickable\");\n      });\n      return this.setupEventListeners();\n    }\n\n    // Returns a nicely formatted filesize\n\n  }, {\n    key: \"filesize\",\n    value: function filesize(size) {\n      var selectedSize = 0;\n      var selectedUnit = \"b\";\n\n      if (size > 0) {\n        var units = ['tb', 'gb', 'mb', 'kb', 'b'];\n\n        for (var i = 0; i < units.length; i++) {\n          var unit = units[i];\n          var cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;\n\n          if (size >= cutoff) {\n            selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);\n            selectedUnit = unit;\n            break;\n          }\n        }\n\n        selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits\n      }\n\n      return \"<strong>\" + selectedSize + \"</strong> \" + this.options.dictFileSizeUnits[selectedUnit];\n    }\n\n    // Adds or removes the `dz-max-files-reached` class from the form.\n\n  }, {\n    key: \"_updateMaxFilesReachedClass\",\n    value: function _updateMaxFilesReachedClass() {\n      if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {\n        if (this.getAcceptedFiles().length === this.options.maxFiles) {\n          this.emit('maxfilesreached', this.files);\n        }\n        return this.element.classList.add(\"dz-max-files-reached\");\n      } else {\n        return this.element.classList.remove(\"dz-max-files-reached\");\n      }\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(e) {\n      if (!e.dataTransfer) {\n        return;\n      }\n      this.emit(\"drop\", e);\n\n      // Convert the FileList to an Array\n      // This is necessary for IE11\n      var files = [];\n      for (var i = 0; i < e.dataTransfer.files.length; i++) {\n        files[i] = e.dataTransfer.files[i];\n      }\n\n      this.emit(\"addedfiles\", files);\n\n      // Even if it's a folder, files.length will contain the folders.\n      if (files.length) {\n        var items = e.dataTransfer.items;\n\n        if (items && items.length && items[0].webkitGetAsEntry != null) {\n          // The browser supports dropping of folders, so handle items instead of files\n          this._addFilesFromItems(items);\n        } else {\n          this.handleFiles(files);\n        }\n      }\n    }\n  }, {\n    key: \"paste\",\n    value: function paste(e) {\n      if (__guard__(e != null ? e.clipboardData : undefined, function (x) {\n        return x.items;\n      }) == null) {\n        return;\n      }\n\n      this.emit(\"paste\", e);\n      var items = e.clipboardData.items;\n\n\n      if (items.length) {\n        return this._addFilesFromItems(items);\n      }\n    }\n  }, {\n    key: \"handleFiles\",\n    value: function handleFiles(files) {\n      for (var _iterator14 = files, _isArray14 = true, _i15 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator]();;) {\n        var _ref13;\n\n        if (_isArray14) {\n          if (_i15 >= _iterator14.length) break;\n          _ref13 = _iterator14[_i15++];\n        } else {\n          _i15 = _iterator14.next();\n          if (_i15.done) break;\n          _ref13 = _i15.value;\n        }\n\n        var file = _ref13;\n\n        this.addFile(file);\n      }\n    }\n\n    // When a folder is dropped (or files are pasted), items must be handled\n    // instead of files.\n\n  }, {\n    key: \"_addFilesFromItems\",\n    value: function _addFilesFromItems(items) {\n      var _this5 = this;\n\n      return function () {\n        var result = [];\n        for (var _iterator15 = items, _isArray15 = true, _i16 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator]();;) {\n          var _ref14;\n\n          if (_isArray15) {\n            if (_i16 >= _iterator15.length) break;\n            _ref14 = _iterator15[_i16++];\n          } else {\n            _i16 = _iterator15.next();\n            if (_i16.done) break;\n            _ref14 = _i16.value;\n          }\n\n          var item = _ref14;\n\n          var entry;\n          if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {\n            if (entry.isFile) {\n              result.push(_this5.addFile(item.getAsFile()));\n            } else if (entry.isDirectory) {\n              // Append all files from that directory to files\n              result.push(_this5._addFilesFromDirectory(entry, entry.name));\n            } else {\n              result.push(undefined);\n            }\n          } else if (item.getAsFile != null) {\n            if (item.kind == null || item.kind === \"file\") {\n              result.push(_this5.addFile(item.getAsFile()));\n            } else {\n              result.push(undefined);\n            }\n          } else {\n            result.push(undefined);\n          }\n        }\n        return result;\n      }();\n    }\n\n    // Goes through the directory, and adds each file it finds recursively\n\n  }, {\n    key: \"_addFilesFromDirectory\",\n    value: function _addFilesFromDirectory(directory, path) {\n      var _this6 = this;\n\n      var dirReader = directory.createReader();\n\n      var errorHandler = function errorHandler(error) {\n        return __guardMethod__(console, 'log', function (o) {\n          return o.log(error);\n        });\n      };\n\n      var readEntries = function readEntries() {\n        return dirReader.readEntries(function (entries) {\n          if (entries.length > 0) {\n            for (var _iterator16 = entries, _isArray16 = true, _i17 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator]();;) {\n              var _ref15;\n\n              if (_isArray16) {\n                if (_i17 >= _iterator16.length) break;\n                _ref15 = _iterator16[_i17++];\n              } else {\n                _i17 = _iterator16.next();\n                if (_i17.done) break;\n                _ref15 = _i17.value;\n              }\n\n              var entry = _ref15;\n\n              if (entry.isFile) {\n                entry.file(function (file) {\n                  if (_this6.options.ignoreHiddenFiles && file.name.substring(0, 1) === '.') {\n                    return;\n                  }\n                  file.fullPath = path + \"/\" + file.name;\n                  return _this6.addFile(file);\n                });\n              } else if (entry.isDirectory) {\n                _this6._addFilesFromDirectory(entry, path + \"/\" + entry.name);\n              }\n            }\n\n            // Recursively call readEntries() again, since browser only handle\n            // the first 100 entries.\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries\n            readEntries();\n          }\n          return null;\n        }, errorHandler);\n      };\n\n      return readEntries();\n    }\n\n    // If `done()` is called without argument the file is accepted\n    // If you call it with an error message, the file is rejected\n    // (This allows for asynchronous validation)\n    //\n    // This function checks the filesize, and if the file.type passes the\n    // `acceptedFiles` check.\n\n  }, {\n    key: \"accept\",\n    value: function accept(file, done) {\n      if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1024 * 1024) {\n        return done(this.options.dictFileTooBig.replace(\"{{filesize}}\", Math.round(file.size / 1024 / 10.24) / 100).replace(\"{{maxFilesize}}\", this.options.maxFilesize));\n      } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {\n        return done(this.options.dictInvalidFileType);\n      } else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {\n        done(this.options.dictMaxFilesExceeded.replace(\"{{maxFiles}}\", this.options.maxFiles));\n        return this.emit(\"maxfilesexceeded\", file);\n      } else {\n        return this.options.accept.call(this, file, done);\n      }\n    }\n  }, {\n    key: \"addFile\",\n    value: function addFile(file) {\n      var _this7 = this;\n\n      file.upload = {\n        uuid: Dropzone.uuidv4(),\n        progress: 0,\n        // Setting the total upload size to file.size for the beginning\n        // It's actual different than the size to be transmitted.\n        total: file.size,\n        bytesSent: 0,\n        filename: this._renameFile(file),\n        chunked: this.options.chunking && (this.options.forceChunking || file.size > this.options.chunkSize),\n        totalChunkCount: Math.ceil(file.size / this.options.chunkSize)\n      };\n      this.files.push(file);\n\n      file.status = Dropzone.ADDED;\n\n      this.emit(\"addedfile\", file);\n\n      this._enqueueThumbnail(file);\n\n      return this.accept(file, function (error) {\n        if (error) {\n          file.accepted = false;\n          _this7._errorProcessing([file], error); // Will set the file.status\n        } else {\n          file.accepted = true;\n          if (_this7.options.autoQueue) {\n            _this7.enqueueFile(file);\n          } // Will set .accepted = true\n        }\n        return _this7._updateMaxFilesReachedClass();\n      });\n    }\n\n    // Wrapper for enqueueFile\n\n  }, {\n    key: \"enqueueFiles\",\n    value: function enqueueFiles(files) {\n      for (var _iterator17 = files, _isArray17 = true, _i18 = 0, _iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator]();;) {\n        var _ref16;\n\n        if (_isArray17) {\n          if (_i18 >= _iterator17.length) break;\n          _ref16 = _iterator17[_i18++];\n        } else {\n          _i18 = _iterator17.next();\n          if (_i18.done) break;\n          _ref16 = _i18.value;\n        }\n\n        var file = _ref16;\n\n        this.enqueueFile(file);\n      }\n      return null;\n    }\n  }, {\n    key: \"enqueueFile\",\n    value: function enqueueFile(file) {\n      var _this8 = this;\n\n      if (file.status === Dropzone.ADDED && file.accepted === true) {\n        file.status = Dropzone.QUEUED;\n        if (this.options.autoProcessQueue) {\n          return setTimeout(function () {\n            return _this8.processQueue();\n          }, 0); // Deferring the call\n        }\n      } else {\n        throw new Error(\"This file can't be queued because it has already been processed or was rejected.\");\n      }\n    }\n  }, {\n    key: \"_enqueueThumbnail\",\n    value: function _enqueueThumbnail(file) {\n      var _this9 = this;\n\n      if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {\n        this._thumbnailQueue.push(file);\n        return setTimeout(function () {\n          return _this9._processThumbnailQueue();\n        }, 0); // Deferring the call\n      }\n    }\n  }, {\n    key: \"_processThumbnailQueue\",\n    value: function _processThumbnailQueue() {\n      var _this10 = this;\n\n      if (this._processingThumbnail || this._thumbnailQueue.length === 0) {\n        return;\n      }\n\n      this._processingThumbnail = true;\n      var file = this._thumbnailQueue.shift();\n      return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, function (dataUrl) {\n        _this10.emit(\"thumbnail\", file, dataUrl);\n        _this10._processingThumbnail = false;\n        return _this10._processThumbnailQueue();\n      });\n    }\n\n    // Can be called by the user to remove a file\n\n  }, {\n    key: \"removeFile\",\n    value: function removeFile(file) {\n      if (file.status === Dropzone.UPLOADING) {\n        this.cancelUpload(file);\n      }\n      this.files = without(this.files, file);\n\n      this.emit(\"removedfile\", file);\n      if (this.files.length === 0) {\n        return this.emit(\"reset\");\n      }\n    }\n\n    // Removes all files that aren't currently processed from the list\n\n  }, {\n    key: \"removeAllFiles\",\n    value: function removeAllFiles(cancelIfNecessary) {\n      // Create a copy of files since removeFile() changes the @files array.\n      if (cancelIfNecessary == null) {\n        cancelIfNecessary = false;\n      }\n      for (var _iterator18 = this.files.slice(), _isArray18 = true, _i19 = 0, _iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator]();;) {\n        var _ref17;\n\n        if (_isArray18) {\n          if (_i19 >= _iterator18.length) break;\n          _ref17 = _iterator18[_i19++];\n        } else {\n          _i19 = _iterator18.next();\n          if (_i19.done) break;\n          _ref17 = _i19.value;\n        }\n\n        var file = _ref17;\n\n        if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {\n          this.removeFile(file);\n        }\n      }\n      return null;\n    }\n\n    // Resizes an image before it gets sent to the server. This function is the default behavior of\n    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with\n    // the resized blob.\n\n  }, {\n    key: \"resizeImage\",\n    value: function resizeImage(file, width, height, resizeMethod, callback) {\n      var _this11 = this;\n\n      return this.createThumbnail(file, width, height, resizeMethod, true, function (dataUrl, canvas) {\n        if (canvas == null) {\n          // The image has not been resized\n          return callback(file);\n        } else {\n          var resizeMimeType = _this11.options.resizeMimeType;\n\n          if (resizeMimeType == null) {\n            resizeMimeType = file.type;\n          }\n          var resizedDataURL = canvas.toDataURL(resizeMimeType, _this11.options.resizeQuality);\n          if (resizeMimeType === 'image/jpeg' || resizeMimeType === 'image/jpg') {\n            // Now add the original EXIF information\n            resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);\n          }\n          return callback(Dropzone.dataURItoBlob(resizedDataURL));\n        }\n      });\n    }\n  }, {\n    key: \"createThumbnail\",\n    value: function createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {\n      var _this12 = this;\n\n      var fileReader = new FileReader();\n\n      fileReader.onload = function () {\n\n        file.dataURL = fileReader.result;\n\n        // Don't bother creating a thumbnail for SVG images since they're vector\n        if (file.type === \"image/svg+xml\") {\n          if (callback != null) {\n            callback(fileReader.result);\n          }\n          return;\n        }\n\n        return _this12.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);\n      };\n\n      return fileReader.readAsDataURL(file);\n    }\n  }, {\n    key: \"createThumbnailFromUrl\",\n    value: function createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {\n      var _this13 = this;\n\n      // Not using `new Image` here because of a bug in latest Chrome versions.\n      // See https://github.com/enyo/dropzone/pull/226\n      var img = document.createElement(\"img\");\n\n      if (crossOrigin) {\n        img.crossOrigin = crossOrigin;\n      }\n\n      img.onload = function () {\n        var loadExif = function loadExif(callback) {\n          return callback(1);\n        };\n        if (typeof EXIF !== 'undefined' && EXIF !== null && fixOrientation) {\n          loadExif = function loadExif(callback) {\n            return EXIF.getData(img, function () {\n              return callback(EXIF.getTag(this, 'Orientation'));\n            });\n          };\n        }\n\n        return loadExif(function (orientation) {\n          file.width = img.width;\n          file.height = img.height;\n\n          var resizeInfo = _this13.options.resize.call(_this13, file, width, height, resizeMethod);\n\n          var canvas = document.createElement(\"canvas\");\n          var ctx = canvas.getContext(\"2d\");\n\n          canvas.width = resizeInfo.trgWidth;\n          canvas.height = resizeInfo.trgHeight;\n\n          if (orientation > 4) {\n            canvas.width = resizeInfo.trgHeight;\n            canvas.height = resizeInfo.trgWidth;\n          }\n\n          switch (orientation) {\n            case 2:\n              // horizontal flip\n              ctx.translate(canvas.width, 0);\n              ctx.scale(-1, 1);\n              break;\n            case 3:\n              // 180Â° rotate left\n              ctx.translate(canvas.width, canvas.height);\n              ctx.rotate(Math.PI);\n              break;\n            case 4:\n              // vertical flip\n              ctx.translate(0, canvas.height);\n              ctx.scale(1, -1);\n              break;\n            case 5:\n              // vertical flip + 90 rotate right\n              ctx.rotate(0.5 * Math.PI);\n              ctx.scale(1, -1);\n              break;\n            case 6:\n              // 90Â° rotate right\n              ctx.rotate(0.5 * Math.PI);\n              ctx.translate(0, -canvas.width);\n              break;\n            case 7:\n              // horizontal flip + 90 rotate right\n              ctx.rotate(0.5 * Math.PI);\n              ctx.translate(canvas.height, -canvas.width);\n              ctx.scale(-1, 1);\n              break;\n            case 8:\n              // 90Â° rotate left\n              ctx.rotate(-0.5 * Math.PI);\n              ctx.translate(-canvas.height, 0);\n              break;\n          }\n\n          // This is a bugfix for iOS' scaling bug.\n          drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);\n\n          var thumbnail = canvas.toDataURL(\"image/png\");\n\n          if (callback != null) {\n            return callback(thumbnail, canvas);\n          }\n        });\n      };\n\n      if (callback != null) {\n        img.onerror = callback;\n      }\n\n      return img.src = file.dataURL;\n    }\n\n    // Goes through the queue and processes files if there aren't too many already.\n\n  }, {\n    key: \"processQueue\",\n    value: function processQueue() {\n      var parallelUploads = this.options.parallelUploads;\n\n      var processingLength = this.getUploadingFiles().length;\n      var i = processingLength;\n\n      // There are already at least as many files uploading than should be\n      if (processingLength >= parallelUploads) {\n        return;\n      }\n\n      var queuedFiles = this.getQueuedFiles();\n\n      if (!(queuedFiles.length > 0)) {\n        return;\n      }\n\n      if (this.options.uploadMultiple) {\n        // The files should be uploaded in one request\n        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));\n      } else {\n        while (i < parallelUploads) {\n          if (!queuedFiles.length) {\n            return;\n          } // Nothing left to process\n          this.processFile(queuedFiles.shift());\n          i++;\n        }\n      }\n    }\n\n    // Wrapper for `processFiles`\n\n  }, {\n    key: \"processFile\",\n    value: function processFile(file) {\n      return this.processFiles([file]);\n    }\n\n    // Loads the file, then calls finishedLoading()\n\n  }, {\n    key: \"processFiles\",\n    value: function processFiles(files) {\n      for (var _iterator19 = files, _isArray19 = true, _i20 = 0, _iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator]();;) {\n        var _ref18;\n\n        if (_isArray19) {\n          if (_i20 >= _iterator19.length) break;\n          _ref18 = _iterator19[_i20++];\n        } else {\n          _i20 = _iterator19.next();\n          if (_i20.done) break;\n          _ref18 = _i20.value;\n        }\n\n        var file = _ref18;\n\n        file.processing = true; // Backwards compatibility\n        file.status = Dropzone.UPLOADING;\n\n        this.emit(\"processing\", file);\n      }\n\n      if (this.options.uploadMultiple) {\n        this.emit(\"processingmultiple\", files);\n      }\n\n      return this.uploadFiles(files);\n    }\n  }, {\n    key: \"_getFilesWithXhr\",\n    value: function _getFilesWithXhr(xhr) {\n      var files = void 0;\n      return files = this.files.filter(function (file) {\n        return file.xhr === xhr;\n      }).map(function (file) {\n        return file;\n      });\n    }\n\n    // Cancels the file upload and sets the status to CANCELED\n    // **if** the file is actually being uploaded.\n    // If it's still in the queue, the file is being removed from it and the status\n    // set to CANCELED.\n\n  }, {\n    key: \"cancelUpload\",\n    value: function cancelUpload(file) {\n      if (file.status === Dropzone.UPLOADING) {\n        var groupedFiles = this._getFilesWithXhr(file.xhr);\n        for (var _iterator20 = groupedFiles, _isArray20 = true, _i21 = 0, _iterator20 = _isArray20 ? _iterator20 : _iterator20[Symbol.iterator]();;) {\n          var _ref19;\n\n          if (_isArray20) {\n            if (_i21 >= _iterator20.length) break;\n            _ref19 = _iterator20[_i21++];\n          } else {\n            _i21 = _iterator20.next();\n            if (_i21.done) break;\n            _ref19 = _i21.value;\n          }\n\n          var groupedFile = _ref19;\n\n          groupedFile.status = Dropzone.CANCELED;\n        }\n        if (typeof file.xhr !== 'undefined') {\n          file.xhr.abort();\n        }\n        for (var _iterator21 = groupedFiles, _isArray21 = true, _i22 = 0, _iterator21 = _isArray21 ? _iterator21 : _iterator21[Symbol.iterator]();;) {\n          var _ref20;\n\n          if (_isArray21) {\n            if (_i22 >= _iterator21.length) break;\n            _ref20 = _iterator21[_i22++];\n          } else {\n            _i22 = _iterator21.next();\n            if (_i22.done) break;\n            _ref20 = _i22.value;\n          }\n\n          var _groupedFile = _ref20;\n\n          this.emit(\"canceled\", _groupedFile);\n        }\n        if (this.options.uploadMultiple) {\n          this.emit(\"canceledmultiple\", groupedFiles);\n        }\n      } else if (file.status === Dropzone.ADDED || file.status === Dropzone.QUEUED) {\n        file.status = Dropzone.CANCELED;\n        this.emit(\"canceled\", file);\n        if (this.options.uploadMultiple) {\n          this.emit(\"canceledmultiple\", [file]);\n        }\n      }\n\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    }\n  }, {\n    key: \"resolveOption\",\n    value: function resolveOption(option) {\n      if (typeof option === 'function') {\n        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          args[_key3 - 1] = arguments[_key3];\n        }\n\n        return option.apply(this, args);\n      }\n      return option;\n    }\n  }, {\n    key: \"uploadFile\",\n    value: function uploadFile(file) {\n      return this.uploadFiles([file]);\n    }\n  }, {\n    key: \"uploadFiles\",\n    value: function uploadFiles(files) {\n      var _this14 = this;\n\n      this._transformFiles(files, function (transformedFiles) {\n        if (files[0].upload.chunked) {\n          // This file should be sent in chunks!\n\n          // If the chunking option is set, we **know** that there can only be **one** file, since\n          // uploadMultiple is not allowed with this option.\n          var file = files[0];\n          var transformedFile = transformedFiles[0];\n          var startedChunkCount = 0;\n\n          file.upload.chunks = [];\n\n          var handleNextChunk = function handleNextChunk() {\n            var chunkIndex = 0;\n\n            // Find the next item in file.upload.chunks that is not defined yet.\n            while (file.upload.chunks[chunkIndex] !== undefined) {\n              chunkIndex++;\n            }\n\n            // This means, that all chunks have already been started.\n            if (chunkIndex >= file.upload.totalChunkCount) return;\n\n            startedChunkCount++;\n\n            var start = chunkIndex * _this14.options.chunkSize;\n            var end = Math.min(start + _this14.options.chunkSize, file.size);\n\n            var dataBlock = {\n              name: _this14._getParamName(0),\n              data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start, end) : transformedFile.slice(start, end),\n              filename: file.upload.filename,\n              chunkIndex: chunkIndex\n            };\n\n            file.upload.chunks[chunkIndex] = {\n              file: file,\n              index: chunkIndex,\n              dataBlock: dataBlock, // In case we want to retry.\n              status: Dropzone.UPLOADING,\n              progress: 0,\n              retries: 0 // The number of times this block has been retried.\n            };\n\n            _this14._uploadData(files, [dataBlock]);\n          };\n\n          file.upload.finishedChunkUpload = function (chunk) {\n            var allFinished = true;\n            chunk.status = Dropzone.SUCCESS;\n\n            // Clear the data from the chunk\n            chunk.dataBlock = null;\n            // Leaving this reference to xhr intact here will cause memory leaks in some browsers\n            chunk.xhr = null;\n\n            for (var i = 0; i < file.upload.totalChunkCount; i++) {\n              if (file.upload.chunks[i] === undefined) {\n                return handleNextChunk();\n              }\n              if (file.upload.chunks[i].status !== Dropzone.SUCCESS) {\n                allFinished = false;\n              }\n            }\n\n            if (allFinished) {\n              _this14.options.chunksUploaded(file, function () {\n                _this14._finished(files, '', null);\n              });\n            }\n          };\n\n          if (_this14.options.parallelChunkUploads) {\n            for (var i = 0; i < file.upload.totalChunkCount; i++) {\n              handleNextChunk();\n            }\n          } else {\n            handleNextChunk();\n          }\n        } else {\n          var dataBlocks = [];\n          for (var _i23 = 0; _i23 < files.length; _i23++) {\n            dataBlocks[_i23] = {\n              name: _this14._getParamName(_i23),\n              data: transformedFiles[_i23],\n              filename: files[_i23].upload.filename\n            };\n          }\n          _this14._uploadData(files, dataBlocks);\n        }\n      });\n    }\n\n    /// Returns the right chunk for given file and xhr\n\n  }, {\n    key: \"_getChunk\",\n    value: function _getChunk(file, xhr) {\n      for (var i = 0; i < file.upload.totalChunkCount; i++) {\n        if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) {\n          return file.upload.chunks[i];\n        }\n      }\n    }\n\n    // This function actually uploads the file(s) to the server.\n    // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed\n    // files, or individual chunks for chunked upload).\n\n  }, {\n    key: \"_uploadData\",\n    value: function _uploadData(files, dataBlocks) {\n      var _this15 = this;\n\n      var xhr = new XMLHttpRequest();\n\n      // Put the xhr object in the file objects to be able to reference it later.\n      for (var _iterator22 = files, _isArray22 = true, _i24 = 0, _iterator22 = _isArray22 ? _iterator22 : _iterator22[Symbol.iterator]();;) {\n        var _ref21;\n\n        if (_isArray22) {\n          if (_i24 >= _iterator22.length) break;\n          _ref21 = _iterator22[_i24++];\n        } else {\n          _i24 = _iterator22.next();\n          if (_i24.done) break;\n          _ref21 = _i24.value;\n        }\n\n        var file = _ref21;\n\n        file.xhr = xhr;\n      }\n      if (files[0].upload.chunked) {\n        // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk\n        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;\n      }\n\n      var method = this.resolveOption(this.options.method, files);\n      var url = this.resolveOption(this.options.url, files);\n      xhr.open(method, url, true);\n\n      // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8\n      xhr.timeout = this.resolveOption(this.options.timeout, files);\n\n      // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179\n      xhr.withCredentials = !!this.options.withCredentials;\n\n      xhr.onload = function (e) {\n        _this15._finishedUploading(files, xhr, e);\n      };\n\n      xhr.onerror = function () {\n        _this15._handleUploadError(files, xhr);\n      };\n\n      // Some browsers do not have the .upload property\n      var progressObj = xhr.upload != null ? xhr.upload : xhr;\n      progressObj.onprogress = function (e) {\n        return _this15._updateFilesUploadProgress(files, xhr, e);\n      };\n\n      var headers = {\n        \"Accept\": \"application/json\",\n        \"Cache-Control\": \"no-cache\",\n        \"X-Requested-With\": \"XMLHttpRequest\"\n      };\n\n      if (this.options.headers) {\n        Dropzone.extend(headers, this.options.headers);\n      }\n\n      for (var headerName in headers) {\n        var headerValue = headers[headerName];\n        if (headerValue) {\n          xhr.setRequestHeader(headerName, headerValue);\n        }\n      }\n\n      var formData = new FormData();\n\n      // Adding all @options parameters\n      if (this.options.params) {\n        var additionalParams = this.options.params;\n        if (typeof additionalParams === 'function') {\n          additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);\n        }\n\n        for (var key in additionalParams) {\n          var value = additionalParams[key];\n          formData.append(key, value);\n        }\n      }\n\n      // Let the user add additional data if necessary\n      for (var _iterator23 = files, _isArray23 = true, _i25 = 0, _iterator23 = _isArray23 ? _iterator23 : _iterator23[Symbol.iterator]();;) {\n        var _ref22;\n\n        if (_isArray23) {\n          if (_i25 >= _iterator23.length) break;\n          _ref22 = _iterator23[_i25++];\n        } else {\n          _i25 = _iterator23.next();\n          if (_i25.done) break;\n          _ref22 = _i25.value;\n        }\n\n        var _file = _ref22;\n\n        this.emit(\"sending\", _file, xhr, formData);\n      }\n      if (this.options.uploadMultiple) {\n        this.emit(\"sendingmultiple\", files, xhr, formData);\n      }\n\n      this._addFormElementData(formData);\n\n      // Finally add the files\n      // Has to be last because some servers (eg: S3) expect the file to be the last parameter\n      for (var i = 0; i < dataBlocks.length; i++) {\n        var dataBlock = dataBlocks[i];\n        formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);\n      }\n\n      this.submitRequest(xhr, formData, files);\n    }\n\n    // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.\n\n  }, {\n    key: \"_transformFiles\",\n    value: function _transformFiles(files, done) {\n      var _this16 = this;\n\n      var transformedFiles = [];\n      // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.\n      var doneCounter = 0;\n\n      var _loop = function _loop(i) {\n        _this16.options.transformFile.call(_this16, files[i], function (transformedFile) {\n          transformedFiles[i] = transformedFile;\n          if (++doneCounter === files.length) {\n            done(transformedFiles);\n          }\n        });\n      };\n\n      for (var i = 0; i < files.length; i++) {\n        _loop(i);\n      }\n    }\n\n    // Takes care of adding other input elements of the form to the AJAX request\n\n  }, {\n    key: \"_addFormElementData\",\n    value: function _addFormElementData(formData) {\n      // Take care of other input elements\n      if (this.element.tagName === \"FORM\") {\n        for (var _iterator24 = this.element.querySelectorAll(\"input, textarea, select, button\"), _isArray24 = true, _i26 = 0, _iterator24 = _isArray24 ? _iterator24 : _iterator24[Symbol.iterator]();;) {\n          var _ref23;\n\n          if (_isArray24) {\n            if (_i26 >= _iterator24.length) break;\n            _ref23 = _iterator24[_i26++];\n          } else {\n            _i26 = _iterator24.next();\n            if (_i26.done) break;\n            _ref23 = _i26.value;\n          }\n\n          var input = _ref23;\n\n          var inputName = input.getAttribute(\"name\");\n          var inputType = input.getAttribute(\"type\");\n          if (inputType) inputType = inputType.toLowerCase();\n\n          // If the input doesn't have a name, we can't use it.\n          if (typeof inputName === 'undefined' || inputName === null) continue;\n\n          if (input.tagName === \"SELECT\" && input.hasAttribute(\"multiple\")) {\n            // Possibly multiple values\n            for (var _iterator25 = input.options, _isArray25 = true, _i27 = 0, _iterator25 = _isArray25 ? _iterator25 : _iterator25[Symbol.iterator]();;) {\n              var _ref24;\n\n              if (_isArray25) {\n                if (_i27 >= _iterator25.length) break;\n                _ref24 = _iterator25[_i27++];\n              } else {\n                _i27 = _iterator25.next();\n                if (_i27.done) break;\n                _ref24 = _i27.value;\n              }\n\n              var option = _ref24;\n\n              if (option.selected) {\n                formData.append(inputName, option.value);\n              }\n            }\n          } else if (!inputType || inputType !== \"checkbox\" && inputType !== \"radio\" || input.checked) {\n            formData.append(inputName, input.value);\n          }\n        }\n      }\n    }\n\n    // Invoked when there is new progress information about given files.\n    // If e is not provided, it is assumed that the upload is finished.\n\n  }, {\n    key: \"_updateFilesUploadProgress\",\n    value: function _updateFilesUploadProgress(files, xhr, e) {\n      var progress = void 0;\n      if (typeof e !== 'undefined') {\n        progress = 100 * e.loaded / e.total;\n\n        if (files[0].upload.chunked) {\n          var file = files[0];\n          // Since this is a chunked upload, we need to update the appropriate chunk progress.\n          var chunk = this._getChunk(file, xhr);\n          chunk.progress = progress;\n          chunk.total = e.total;\n          chunk.bytesSent = e.loaded;\n          var fileProgress = 0,\n              fileTotal = void 0,\n              fileBytesSent = void 0;\n          file.upload.progress = 0;\n          file.upload.total = 0;\n          file.upload.bytesSent = 0;\n          for (var i = 0; i < file.upload.totalChunkCount; i++) {\n            if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].progress !== undefined) {\n              file.upload.progress += file.upload.chunks[i].progress;\n              file.upload.total += file.upload.chunks[i].total;\n              file.upload.bytesSent += file.upload.chunks[i].bytesSent;\n            }\n          }\n          file.upload.progress = file.upload.progress / file.upload.totalChunkCount;\n        } else {\n          for (var _iterator26 = files, _isArray26 = true, _i28 = 0, _iterator26 = _isArray26 ? _iterator26 : _iterator26[Symbol.iterator]();;) {\n            var _ref25;\n\n            if (_isArray26) {\n              if (_i28 >= _iterator26.length) break;\n              _ref25 = _iterator26[_i28++];\n            } else {\n              _i28 = _iterator26.next();\n              if (_i28.done) break;\n              _ref25 = _i28.value;\n            }\n\n            var _file2 = _ref25;\n\n            _file2.upload.progress = progress;\n            _file2.upload.total = e.total;\n            _file2.upload.bytesSent = e.loaded;\n          }\n        }\n        for (var _iterator27 = files, _isArray27 = true, _i29 = 0, _iterator27 = _isArray27 ? _iterator27 : _iterator27[Symbol.iterator]();;) {\n          var _ref26;\n\n          if (_isArray27) {\n            if (_i29 >= _iterator27.length) break;\n            _ref26 = _iterator27[_i29++];\n          } else {\n            _i29 = _iterator27.next();\n            if (_i29.done) break;\n            _ref26 = _i29.value;\n          }\n\n          var _file3 = _ref26;\n\n          this.emit(\"uploadprogress\", _file3, _file3.upload.progress, _file3.upload.bytesSent);\n        }\n      } else {\n        // Called when the file finished uploading\n\n        var allFilesFinished = true;\n\n        progress = 100;\n\n        for (var _iterator28 = files, _isArray28 = true, _i30 = 0, _iterator28 = _isArray28 ? _iterator28 : _iterator28[Symbol.iterator]();;) {\n          var _ref27;\n\n          if (_isArray28) {\n            if (_i30 >= _iterator28.length) break;\n            _ref27 = _iterator28[_i30++];\n          } else {\n            _i30 = _iterator28.next();\n            if (_i30.done) break;\n            _ref27 = _i30.value;\n          }\n\n          var _file4 = _ref27;\n\n          if (_file4.upload.progress !== 100 || _file4.upload.bytesSent !== _file4.upload.total) {\n            allFilesFinished = false;\n          }\n          _file4.upload.progress = progress;\n          _file4.upload.bytesSent = _file4.upload.total;\n        }\n\n        // Nothing to do, all files already at 100%\n        if (allFilesFinished) {\n          return;\n        }\n\n        for (var _iterator29 = files, _isArray29 = true, _i31 = 0, _iterator29 = _isArray29 ? _iterator29 : _iterator29[Symbol.iterator]();;) {\n          var _ref28;\n\n          if (_isArray29) {\n            if (_i31 >= _iterator29.length) break;\n            _ref28 = _iterator29[_i31++];\n          } else {\n            _i31 = _iterator29.next();\n            if (_i31.done) break;\n            _ref28 = _i31.value;\n          }\n\n          var _file5 = _ref28;\n\n          this.emit(\"uploadprogress\", _file5, progress, _file5.upload.bytesSent);\n        }\n      }\n    }\n  }, {\n    key: \"_finishedUploading\",\n    value: function _finishedUploading(files, xhr, e) {\n      var response = void 0;\n\n      if (files[0].status === Dropzone.CANCELED) {\n        return;\n      }\n\n      if (xhr.readyState !== 4) {\n        return;\n      }\n\n      if (xhr.responseType !== 'arraybuffer' && xhr.responseType !== 'blob') {\n        response = xhr.responseText;\n\n        if (xhr.getResponseHeader(\"content-type\") && ~xhr.getResponseHeader(\"content-type\").indexOf(\"application/json\")) {\n          try {\n            response = JSON.parse(response);\n          } catch (error) {\n            e = error;\n            response = \"Invalid JSON response from server.\";\n          }\n        }\n      }\n\n      this._updateFilesUploadProgress(files);\n\n      if (!(200 <= xhr.status && xhr.status < 300)) {\n        this._handleUploadError(files, xhr, response);\n      } else {\n        if (files[0].upload.chunked) {\n          files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr));\n        } else {\n          this._finished(files, response, e);\n        }\n      }\n    }\n  }, {\n    key: \"_handleUploadError\",\n    value: function _handleUploadError(files, xhr, response) {\n      if (files[0].status === Dropzone.CANCELED) {\n        return;\n      }\n\n      if (files[0].upload.chunked && this.options.retryChunks) {\n        var chunk = this._getChunk(files[0], xhr);\n        if (chunk.retries++ < this.options.retryChunksLimit) {\n          this._uploadData(files, [chunk.dataBlock]);\n          return;\n        } else {\n          console.warn('Retried this chunk too often. Giving up.');\n        }\n      }\n\n      for (var _iterator30 = files, _isArray30 = true, _i32 = 0, _iterator30 = _isArray30 ? _iterator30 : _iterator30[Symbol.iterator]();;) {\n        var _ref29;\n\n        if (_isArray30) {\n          if (_i32 >= _iterator30.length) break;\n          _ref29 = _iterator30[_i32++];\n        } else {\n          _i32 = _iterator30.next();\n          if (_i32.done) break;\n          _ref29 = _i32.value;\n        }\n\n        var file = _ref29;\n\n        this._errorProcessing(files, response || this.options.dictResponseError.replace(\"{{statusCode}}\", xhr.status), xhr);\n      }\n    }\n  }, {\n    key: \"submitRequest\",\n    value: function submitRequest(xhr, formData, files) {\n      xhr.send(formData);\n    }\n\n    // Called internally when processing is finished.\n    // Individual callbacks have to be called in the appropriate sections.\n\n  }, {\n    key: \"_finished\",\n    value: function _finished(files, responseText, e) {\n      for (var _iterator31 = files, _isArray31 = true, _i33 = 0, _iterator31 = _isArray31 ? _iterator31 : _iterator31[Symbol.iterator]();;) {\n        var _ref30;\n\n        if (_isArray31) {\n          if (_i33 >= _iterator31.length) break;\n          _ref30 = _iterator31[_i33++];\n        } else {\n          _i33 = _iterator31.next();\n          if (_i33.done) break;\n          _ref30 = _i33.value;\n        }\n\n        var file = _ref30;\n\n        file.status = Dropzone.SUCCESS;\n        this.emit(\"success\", file, responseText, e);\n        this.emit(\"complete\", file);\n      }\n      if (this.options.uploadMultiple) {\n        this.emit(\"successmultiple\", files, responseText, e);\n        this.emit(\"completemultiple\", files);\n      }\n\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    }\n\n    // Called internally when processing is finished.\n    // Individual callbacks have to be called in the appropriate sections.\n\n  }, {\n    key: \"_errorProcessing\",\n    value: function _errorProcessing(files, message, xhr) {\n      for (var _iterator32 = files, _isArray32 = true, _i34 = 0, _iterator32 = _isArray32 ? _iterator32 : _iterator32[Symbol.iterator]();;) {\n        var _ref31;\n\n        if (_isArray32) {\n          if (_i34 >= _iterator32.length) break;\n          _ref31 = _iterator32[_i34++];\n        } else {\n          _i34 = _iterator32.next();\n          if (_i34.done) break;\n          _ref31 = _i34.value;\n        }\n\n        var file = _ref31;\n\n        file.status = Dropzone.ERROR;\n        this.emit(\"error\", file, message, xhr);\n        this.emit(\"complete\", file);\n      }\n      if (this.options.uploadMultiple) {\n        this.emit(\"errormultiple\", files, message, xhr);\n        this.emit(\"completemultiple\", files);\n      }\n\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    }\n  }], [{\n    key: \"uuidv4\",\n    value: function uuidv4() {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0,\n            v = c === 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    }\n  }]);\n\n  return Dropzone;\n}(Emitter);\n\nDropzone.initClass();\n\nDropzone.version = \"5.5.1\";\n\n// This is a map of options for your different dropzones. Add configurations\n// to this object for your different dropzone elemens.\n//\n// Example:\n//\n//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };\n//\n// To disable autoDiscover for a specific element, you can set `false` as an option:\n//\n//     Dropzone.options.myDisabledElementId = false;\n//\n// And in html:\n//\n//     <form action=\"/upload\" id=\"my-dropzone-element-id\" class=\"dropzone\"></form>\nDropzone.options = {};\n\n// Returns the options for an element or undefined if none available.\nDropzone.optionsForElement = function (element) {\n  // Get the `Dropzone.options.elementId` for this element if it exists\n  if (element.getAttribute(\"id\")) {\n    return Dropzone.options[camelize(element.getAttribute(\"id\"))];\n  } else {\n    return undefined;\n  }\n};\n\n// Holds a list of all dropzone instances\nDropzone.instances = [];\n\n// Returns the dropzone for given element if any\nDropzone.forElement = function (element) {\n  if (typeof element === \"string\") {\n    element = document.querySelector(element);\n  }\n  if ((element != null ? element.dropzone : undefined) == null) {\n    throw new Error(\"No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.\");\n  }\n  return element.dropzone;\n};\n\n// Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.\nDropzone.autoDiscover = true;\n\n// Looks for all .dropzone elements and creates a dropzone for them\nDropzone.discover = function () {\n  var dropzones = void 0;\n  if (document.querySelectorAll) {\n    dropzones = document.querySelectorAll(\".dropzone\");\n  } else {\n    dropzones = [];\n    // IE :(\n    var checkElements = function checkElements(elements) {\n      return function () {\n        var result = [];\n        for (var _iterator33 = elements, _isArray33 = true, _i35 = 0, _iterator33 = _isArray33 ? _iterator33 : _iterator33[Symbol.iterator]();;) {\n          var _ref32;\n\n          if (_isArray33) {\n            if (_i35 >= _iterator33.length) break;\n            _ref32 = _iterator33[_i35++];\n          } else {\n            _i35 = _iterator33.next();\n            if (_i35.done) break;\n            _ref32 = _i35.value;\n          }\n\n          var el = _ref32;\n\n          if (/(^| )dropzone($| )/.test(el.className)) {\n            result.push(dropzones.push(el));\n          } else {\n            result.push(undefined);\n          }\n        }\n        return result;\n      }();\n    };\n    checkElements(document.getElementsByTagName(\"div\"));\n    checkElements(document.getElementsByTagName(\"form\"));\n  }\n\n  return function () {\n    var result = [];\n    for (var _iterator34 = dropzones, _isArray34 = true, _i36 = 0, _iterator34 = _isArray34 ? _iterator34 : _iterator34[Symbol.iterator]();;) {\n      var _ref33;\n\n      if (_isArray34) {\n        if (_i36 >= _iterator34.length) break;\n        _ref33 = _iterator34[_i36++];\n      } else {\n        _i36 = _iterator34.next();\n        if (_i36.done) break;\n        _ref33 = _i36.value;\n      }\n\n      var dropzone = _ref33;\n\n      // Create a dropzone unless auto discover has been disabled for specific element\n      if (Dropzone.optionsForElement(dropzone) !== false) {\n        result.push(new Dropzone(dropzone));\n      } else {\n        result.push(undefined);\n      }\n    }\n    return result;\n  }();\n};\n\n// Since the whole Drag'n'Drop API is pretty new, some browsers implement it,\n// but not correctly.\n// So I created a blacklist of userAgents. Yes, yes. Browser sniffing, I know.\n// But what to do when browsers *theoretically* support an API, but crash\n// when using it.\n//\n// This is a list of regular expressions tested against navigator.userAgent\n//\n// ** It should only be used on browser that *do* support the API, but\n// incorrectly **\n//\nDropzone.blacklistedBrowsers = [\n// The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.\n/opera.*(Macintosh|Windows Phone).*version\\/12/i];\n\n// Checks if the browser is supported\nDropzone.isBrowserSupported = function () {\n  var capableBrowser = true;\n\n  if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {\n    if (!(\"classList\" in document.createElement(\"a\"))) {\n      capableBrowser = false;\n    } else {\n      // The browser supports the API, but may be blacklisted.\n      for (var _iterator35 = Dropzone.blacklistedBrowsers, _isArray35 = true, _i37 = 0, _iterator35 = _isArray35 ? _iterator35 : _iterator35[Symbol.iterator]();;) {\n        var _ref34;\n\n        if (_isArray35) {\n          if (_i37 >= _iterator35.length) break;\n          _ref34 = _iterator35[_i37++];\n        } else {\n          _i37 = _iterator35.next();\n          if (_i37.done) break;\n          _ref34 = _i37.value;\n        }\n\n        var regex = _ref34;\n\n        if (regex.test(navigator.userAgent)) {\n          capableBrowser = false;\n          continue;\n        }\n      }\n    }\n  } else {\n    capableBrowser = false;\n  }\n\n  return capableBrowser;\n};\n\nDropzone.dataURItoBlob = function (dataURI) {\n  // convert base64 to raw binary data held in a string\n  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\n  var byteString = atob(dataURI.split(',')[1]);\n\n  // separate out the mime component\n  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];\n\n  // write the bytes of the string to an ArrayBuffer\n  var ab = new ArrayBuffer(byteString.length);\n  var ia = new Uint8Array(ab);\n  for (var i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {\n    ia[i] = byteString.charCodeAt(i);\n  }\n\n  // write the ArrayBuffer to a blob\n  return new Blob([ab], { type: mimeString });\n};\n\n// Returns an array without the rejected item\nvar without = function without(list, rejectedItem) {\n  return list.filter(function (item) {\n    return item !== rejectedItem;\n  }).map(function (item) {\n    return item;\n  });\n};\n\n// abc-def_ghi -> abcDefGhi\nvar camelize = function camelize(str) {\n  return str.replace(/[\\-_](\\w)/g, function (match) {\n    return match.charAt(1).toUpperCase();\n  });\n};\n\n// Creates an element from string\nDropzone.createElement = function (string) {\n  var div = document.createElement(\"div\");\n  div.innerHTML = string;\n  return div.childNodes[0];\n};\n\n// Tests if given element is inside (or simply is) the container\nDropzone.elementInside = function (element, container) {\n  if (element === container) {\n    return true;\n  } // Coffeescript doesn't support do/while loops\n  while (element = element.parentNode) {\n    if (element === container) {\n      return true;\n    }\n  }\n  return false;\n};\n\nDropzone.getElement = function (el, name) {\n  var element = void 0;\n  if (typeof el === \"string\") {\n    element = document.querySelector(el);\n  } else if (el.nodeType != null) {\n    element = el;\n  }\n  if (element == null) {\n    throw new Error(\"Invalid `\" + name + \"` option provided. Please provide a CSS selector or a plain HTML element.\");\n  }\n  return element;\n};\n\nDropzone.getElements = function (els, name) {\n  var el = void 0,\n      elements = void 0;\n  if (els instanceof Array) {\n    elements = [];\n    try {\n      for (var _iterator36 = els, _isArray36 = true, _i38 = 0, _iterator36 = _isArray36 ? _iterator36 : _iterator36[Symbol.iterator]();;) {\n        if (_isArray36) {\n          if (_i38 >= _iterator36.length) break;\n          el = _iterator36[_i38++];\n        } else {\n          _i38 = _iterator36.next();\n          if (_i38.done) break;\n          el = _i38.value;\n        }\n\n        elements.push(this.getElement(el, name));\n      }\n    } catch (e) {\n      elements = null;\n    }\n  } else if (typeof els === \"string\") {\n    elements = [];\n    for (var _iterator37 = document.querySelectorAll(els), _isArray37 = true, _i39 = 0, _iterator37 = _isArray37 ? _iterator37 : _iterator37[Symbol.iterator]();;) {\n      if (_isArray37) {\n        if (_i39 >= _iterator37.length) break;\n        el = _iterator37[_i39++];\n      } else {\n        _i39 = _iterator37.next();\n        if (_i39.done) break;\n        el = _i39.value;\n      }\n\n      elements.push(el);\n    }\n  } else if (els.nodeType != null) {\n    elements = [els];\n  }\n\n  if (elements == null || !elements.length) {\n    throw new Error(\"Invalid `\" + name + \"` option provided. Please provide a CSS selector, a plain HTML element or a list of those.\");\n  }\n\n  return elements;\n};\n\n// Asks the user the question and calls accepted or rejected accordingly\n//\n// The default implementation just uses `window.confirm` and then calls the\n// appropriate callback.\nDropzone.confirm = function (question, accepted, rejected) {\n  if (window.confirm(question)) {\n    return accepted();\n  } else if (rejected != null) {\n    return rejected();\n  }\n};\n\n// Validates the mime type like this:\n//\n// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept\nDropzone.isValidFile = function (file, acceptedFiles) {\n  if (!acceptedFiles) {\n    return true;\n  } // If there are no accepted mime types, it's OK\n  acceptedFiles = acceptedFiles.split(\",\");\n\n  var mimeType = file.type;\n  var baseMimeType = mimeType.replace(/\\/.*$/, \"\");\n\n  for (var _iterator38 = acceptedFiles, _isArray38 = true, _i40 = 0, _iterator38 = _isArray38 ? _iterator38 : _iterator38[Symbol.iterator]();;) {\n    var _ref35;\n\n    if (_isArray38) {\n      if (_i40 >= _iterator38.length) break;\n      _ref35 = _iterator38[_i40++];\n    } else {\n      _i40 = _iterator38.next();\n      if (_i40.done) break;\n      _ref35 = _i40.value;\n    }\n\n    var validType = _ref35;\n\n    validType = validType.trim();\n    if (validType.charAt(0) === \".\") {\n      if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {\n        return true;\n      }\n    } else if (/\\/\\*$/.test(validType)) {\n      // This is something like a image/* mime type\n      if (baseMimeType === validType.replace(/\\/.*$/, \"\")) {\n        return true;\n      }\n    } else {\n      if (mimeType === validType) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// Augment jQuery\nif (typeof jQuery !== 'undefined' && jQuery !== null) {\n  jQuery.fn.dropzone = function (options) {\n    return this.each(function () {\n      return new Dropzone(this, options);\n    });\n  };\n}\n\nif ( true && module !== null) {\n  module.exports = Dropzone;\n} else {\n  window.Dropzone = Dropzone;\n}\n\n// Dropzone file status codes\nDropzone.ADDED = \"added\";\n\nDropzone.QUEUED = \"queued\";\n// For backwards compatibility. Now, if a file is accepted, it's either queued\n// or uploading.\nDropzone.ACCEPTED = Dropzone.QUEUED;\n\nDropzone.UPLOADING = \"uploading\";\nDropzone.PROCESSING = Dropzone.UPLOADING; // alias\n\nDropzone.CANCELED = \"canceled\";\nDropzone.ERROR = \"error\";\nDropzone.SUCCESS = \"success\";\n\n/*\n\n Bugfix for iOS 6 and 7\n Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios\n based on the work of https://github.com/stomita/ios-imagefile-megapixel\n\n */\n\n// Detecting vertical squash in loaded image.\n// Fixes a bug which squash image vertically while drawing into canvas for some images.\n// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel\nvar detectVerticalSquash = function detectVerticalSquash(img) {\n  var iw = img.naturalWidth;\n  var ih = img.naturalHeight;\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = ih;\n  var ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(img, 0, 0);\n\n  var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih),\n      data = _ctx$getImageData.data;\n\n  // search image edge pixel position in case it is squashed vertically.\n\n\n  var sy = 0;\n  var ey = ih;\n  var py = ih;\n  while (py > sy) {\n    var alpha = data[(py - 1) * 4 + 3];\n\n    if (alpha === 0) {\n      ey = py;\n    } else {\n      sy = py;\n    }\n\n    py = ey + sy >> 1;\n  }\n  var ratio = py / ih;\n\n  if (ratio === 0) {\n    return 1;\n  } else {\n    return ratio;\n  }\n};\n\n// A replacement for context.drawImage\n// (args are for source and destination).\nvar drawImageIOSFix = function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {\n  var vertSquashRatio = detectVerticalSquash(img);\n  return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);\n};\n\n// Based on MinifyJpeg\n// Source: http://www.perry.cz/files/ExifRestorer.js\n// http://elicon.blog57.fc2.com/blog-entry-206.html\n\nvar ExifRestore = function () {\n  function ExifRestore() {\n    _classCallCheck(this, ExifRestore);\n  }\n\n  _createClass(ExifRestore, null, [{\n    key: \"initClass\",\n    value: function initClass() {\n      this.KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    }\n  }, {\n    key: \"encode64\",\n    value: function encode64(input) {\n      var output = '';\n      var chr1 = undefined;\n      var chr2 = undefined;\n      var chr3 = '';\n      var enc1 = undefined;\n      var enc2 = undefined;\n      var enc3 = undefined;\n      var enc4 = '';\n      var i = 0;\n      while (true) {\n        chr1 = input[i++];\n        chr2 = input[i++];\n        chr3 = input[i++];\n        enc1 = chr1 >> 2;\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n        enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n        enc4 = chr3 & 63;\n        if (isNaN(chr2)) {\n          enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n          enc4 = 64;\n        }\n        output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n        chr1 = chr2 = chr3 = '';\n        enc1 = enc2 = enc3 = enc4 = '';\n        if (!(i < input.length)) {\n          break;\n        }\n      }\n      return output;\n    }\n  }, {\n    key: \"restore\",\n    value: function restore(origFileBase64, resizedFileBase64) {\n      if (!origFileBase64.match('data:image/jpeg;base64,')) {\n        return resizedFileBase64;\n      }\n      var rawImage = this.decode64(origFileBase64.replace('data:image/jpeg;base64,', ''));\n      var segments = this.slice2Segments(rawImage);\n      var image = this.exifManipulation(resizedFileBase64, segments);\n      return \"data:image/jpeg;base64,\" + this.encode64(image);\n    }\n  }, {\n    key: \"exifManipulation\",\n    value: function exifManipulation(resizedFileBase64, segments) {\n      var exifArray = this.getExifArray(segments);\n      var newImageArray = this.insertExif(resizedFileBase64, exifArray);\n      var aBuffer = new Uint8Array(newImageArray);\n      return aBuffer;\n    }\n  }, {\n    key: \"getExifArray\",\n    value: function getExifArray(segments) {\n      var seg = undefined;\n      var x = 0;\n      while (x < segments.length) {\n        seg = segments[x];\n        if (seg[0] === 255 & seg[1] === 225) {\n          return seg;\n        }\n        x++;\n      }\n      return [];\n    }\n  }, {\n    key: \"insertExif\",\n    value: function insertExif(resizedFileBase64, exifArray) {\n      var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', '');\n      var buf = this.decode64(imageData);\n      var separatePoint = buf.indexOf(255, 3);\n      var mae = buf.slice(0, separatePoint);\n      var ato = buf.slice(separatePoint);\n      var array = mae;\n      array = array.concat(exifArray);\n      array = array.concat(ato);\n      return array;\n    }\n  }, {\n    key: \"slice2Segments\",\n    value: function slice2Segments(rawImageArray) {\n      var head = 0;\n      var segments = [];\n      while (true) {\n        var length;\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {\n          break;\n        }\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {\n          head += 2;\n        } else {\n          length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];\n          var endPoint = head + length + 2;\n          var seg = rawImageArray.slice(head, endPoint);\n          segments.push(seg);\n          head = endPoint;\n        }\n        if (head > rawImageArray.length) {\n          break;\n        }\n      }\n      return segments;\n    }\n  }, {\n    key: \"decode64\",\n    value: function decode64(input) {\n      var output = '';\n      var chr1 = undefined;\n      var chr2 = undefined;\n      var chr3 = '';\n      var enc1 = undefined;\n      var enc2 = undefined;\n      var enc3 = undefined;\n      var enc4 = '';\n      var i = 0;\n      var buf = [];\n      // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n      var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n      if (base64test.exec(input)) {\n        console.warn('There were invalid base64 characters in the input text.\\nValid base64 characters are A-Z, a-z, 0-9, \\'+\\', \\'/\\',and \\'=\\'\\nExpect errors in decoding.');\n      }\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n      while (true) {\n        enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        buf.push(chr1);\n        if (enc3 !== 64) {\n          buf.push(chr2);\n        }\n        if (enc4 !== 64) {\n          buf.push(chr3);\n        }\n        chr1 = chr2 = chr3 = '';\n        enc1 = enc2 = enc3 = enc4 = '';\n        if (!(i < input.length)) {\n          break;\n        }\n      }\n      return buf;\n    }\n  }]);\n\n  return ExifRestore;\n}();\n\nExifRestore.initClass();\n\n/*\n * contentloaded.js\n *\n * Author: Diego Perini (diego.perini at gmail.com)\n * Summary: cross-browser wrapper for DOMContentLoaded\n * Updated: 20101020\n * License: MIT\n * Version: 1.2\n *\n * URL:\n * http://javascript.nwbox.com/ContentLoaded/\n * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE\n */\n\n// @win window reference\n// @fn function reference\nvar contentLoaded = function contentLoaded(win, fn) {\n  var done = false;\n  var top = true;\n  var doc = win.document;\n  var root = doc.documentElement;\n  var add = doc.addEventListener ? \"addEventListener\" : \"attachEvent\";\n  var rem = doc.addEventListener ? \"removeEventListener\" : \"detachEvent\";\n  var pre = doc.addEventListener ? \"\" : \"on\";\n  var init = function init(e) {\n    if (e.type === \"readystatechange\" && doc.readyState !== \"complete\") {\n      return;\n    }\n    (e.type === \"load\" ? win : doc)[rem](pre + e.type, init, false);\n    if (!done && (done = true)) {\n      return fn.call(win, e.type || e);\n    }\n  };\n\n  var poll = function poll() {\n    try {\n      root.doScroll(\"left\");\n    } catch (e) {\n      setTimeout(poll, 50);\n      return;\n    }\n    return init(\"poll\");\n  };\n\n  if (doc.readyState !== \"complete\") {\n    if (doc.createEventObject && root.doScroll) {\n      try {\n        top = !win.frameElement;\n      } catch (error) {}\n      if (top) {\n        poll();\n      }\n    }\n    doc[add](pre + \"DOMContentLoaded\", init, false);\n    doc[add](pre + \"readystatechange\", init, false);\n    return win[add](pre + \"load\", init, false);\n  }\n};\n\n// As a single function to be able to write tests.\nDropzone._autoDiscoverFunction = function () {\n  if (Dropzone.autoDiscover) {\n    return Dropzone.discover();\n  }\n};\ncontentLoaded(window, Dropzone._autoDiscoverFunction);\n\nfunction __guard__(value, transform) {\n  return typeof value !== 'undefined' && value !== null ? transform(value) : undefined;\n}\nfunction __guardMethod__(obj, methodName, transform) {\n  if (typeof obj !== 'undefined' && obj !== null && typeof obj[methodName] === 'function') {\n    return transform(obj, methodName);\n  } else {\n    return undefined;\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJvcHpvbmUvZGlzdC9kcm9wem9uZS5qcz83OWUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDhDQUFhOztBQUViLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQixpREFBaUQsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRTlPLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTVlLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7O0FBRUEsa0lBQWtJO0FBQ2xJOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsc0NBQXNDO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxVQUFVLFNBQVMsYUFBYTtBQUM5QztBQUNBLDRDQUE0QyxVQUFVLHNCQUFzQixhQUFhOztBQUV6RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0Esb0RBQW9ELFlBQVk7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlEQUFpRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7O0FBR2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEtBQTBLO0FBQzFLOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0Msc0VBQXNFOztBQUU1RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBJQUEwSTtBQUMxSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSkFBbUo7QUFDbko7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSkFBbUo7QUFDbko7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixlQUFlO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsaUNBQWlDO0FBQzVEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBJQUEwSTtBQUMxSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBJQUEwSTtBQUMxSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdU1BQXVNO0FBQ3ZNOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0pBQXdKO0FBQ3hKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUNBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhJQUE4STtBQUM5STs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0STtBQUM1STs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTs7QUFFQSw0SUFBNEk7QUFDNUk7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0SUFBNEk7QUFDNUk7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsMElBQTBJO0FBQzFJOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyRkFBMkYsWUFBWTtBQUN2RztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQSwwSUFBMEk7QUFDMUk7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBJQUEwSTtBQUMxSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0lBQStJO0FBQy9JOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0SUFBNEk7QUFDNUk7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpS0FBaUs7QUFDaks7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwyQkFBMkI7QUFDckY7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3STtBQUN4STtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUtBQWlLO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLDhJQUE4STtBQUM5STs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLElBQUksS0FBNkI7QUFDakM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZHJvcHpvbmUvZGlzdC9kcm9wem9uZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qXG4gKlxuICogTW9yZSBpbmZvIGF0IFt3d3cuZHJvcHpvbmVqcy5jb21dKGh0dHA6Ly93d3cuZHJvcHpvbmVqcy5jb20pXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyLCBNYXRpYXMgTWVub1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICovXG5cbi8vIFRoZSBFbWl0dGVyIGNsYXNzIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIGNhbGwgYC5vbigpYCBvbiBEcm9wem9uZSB0byBsaXN0ZW5cbi8vIHRvIGV2ZW50cy5cbi8vIEl0IGlzIHN0cm9uZ2x5IGJhc2VkIG9uIGNvbXBvbmVudCdzIGVtaXR0ZXIgY2xhc3MsIGFuZCBJIHJlbW92ZWQgdGhlXG4vLyBmdW5jdGlvbmFsaXR5IGJlY2F1c2Ugb2YgdGhlIGRlcGVuZGVuY3kgaGVsbCB3aXRoIGRpZmZlcmVudCBmcmFtZXdvcmtzLlxudmFyIEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtaXR0ZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIsIFt7XG4gICAga2V5OiBcIm9uXCIsXG5cbiAgICAvLyBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGdpdmVuIGV2ZW50XG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbikge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgLy8gQ3JlYXRlIG5hbWVzcGFjZSBmb3IgdGhpcyBldmVudFxuICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3NbZXZlbnRdKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGxiYWNrc1tldmVudF0ucHVzaChmbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGNhbGxiYWNrcywgX2lzQXJyYXkgPSB0cnVlLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgdmFyIF9yZWY7XG5cbiAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfcmVmO1xuXG4gICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZvciBnaXZlbiBldmVudC4gSWYgZm4gaXMgbm90IHByb3ZpZGVkLCBhbGwgZXZlbnRcbiAgICAvLyBsaXN0ZW5lcnMgZm9yIHRoYXQgZXZlbnQgd2lsbCBiZSByZW1vdmVkLiBJZiBuZWl0aGVyIGlzIHByb3ZpZGVkLCBhbGxcbiAgICAvLyBldmVudCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwib2ZmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudCwgZm4pIHtcbiAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IGZuKSB7XG4gICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRW1pdHRlcjtcbn0oKTtcblxudmFyIERyb3B6b25lID0gZnVuY3Rpb24gKF9FbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhEcm9wem9uZSwgX0VtaXR0ZXIpO1xuXG4gIF9jcmVhdGVDbGFzcyhEcm9wem9uZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiaW5pdENsYXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRDbGFzcygpIHtcblxuICAgICAgLy8gRXhwb3NpbmcgdGhlIGVtaXR0ZXIgY2xhc3MsIG1haW5seSBmb3IgdGVzdHNcbiAgICAgIHRoaXMucHJvdG90eXBlLkVtaXR0ZXIgPSBFbWl0dGVyO1xuXG4gICAgICAvKlxuICAgICAgIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgZXZlbnRzIHlvdSBjYW4gcmVnaXN0ZXIgb24gYSBkcm9wem9uZSBvYmplY3QuXG4gICAgICAgIFlvdSBjYW4gcmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlciBsaWtlIHRoaXM6XG4gICAgICAgIGRyb3B6b25lLm9uKFwiZHJhZ0VudGVyXCIsIGZ1bmN0aW9uKCkgeyB9KTtcbiAgICAgICAgKi9cbiAgICAgIHRoaXMucHJvdG90eXBlLmV2ZW50cyA9IFtcImRyb3BcIiwgXCJkcmFnc3RhcnRcIiwgXCJkcmFnZW5kXCIsIFwiZHJhZ2VudGVyXCIsIFwiZHJhZ292ZXJcIiwgXCJkcmFnbGVhdmVcIiwgXCJhZGRlZGZpbGVcIiwgXCJhZGRlZGZpbGVzXCIsIFwicmVtb3ZlZGZpbGVcIiwgXCJ0aHVtYm5haWxcIiwgXCJlcnJvclwiLCBcImVycm9ybXVsdGlwbGVcIiwgXCJwcm9jZXNzaW5nXCIsIFwicHJvY2Vzc2luZ211bHRpcGxlXCIsIFwidXBsb2FkcHJvZ3Jlc3NcIiwgXCJ0b3RhbHVwbG9hZHByb2dyZXNzXCIsIFwic2VuZGluZ1wiLCBcInNlbmRpbmdtdWx0aXBsZVwiLCBcInN1Y2Nlc3NcIiwgXCJzdWNjZXNzbXVsdGlwbGVcIiwgXCJjYW5jZWxlZFwiLCBcImNhbmNlbGVkbXVsdGlwbGVcIiwgXCJjb21wbGV0ZVwiLCBcImNvbXBsZXRlbXVsdGlwbGVcIiwgXCJyZXNldFwiLCBcIm1heGZpbGVzZXhjZWVkZWRcIiwgXCJtYXhmaWxlc3JlYWNoZWRcIiwgXCJxdWV1ZWNvbXBsZXRlXCJdO1xuXG4gICAgICB0aGlzLnByb3RvdHlwZS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhcyB0byBiZSBzcGVjaWZpZWQgb24gZWxlbWVudHMgb3RoZXIgdGhhbiBmb3JtIChvciB3aGVuIHRoZSBmb3JtXG4gICAgICAgICAqIGRvZXNuJ3QgaGF2ZSBhbiBgYWN0aW9uYCBhdHRyaWJ1dGUpLiBZb3UgY2FuIGFsc29cbiAgICAgICAgICogcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgZmlsZXNgIGFuZFxuICAgICAgICAgKiBtdXN0IHJldHVybiB0aGUgdXJsIChzaW5jZSBgdjMuMTIuMGApXG4gICAgICAgICAqL1xuICAgICAgICB1cmw6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiBiZSBjaGFuZ2VkIHRvIGBcInB1dFwiYCBpZiBuZWNlc3NhcnkuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgZnVuY3Rpb25cbiAgICAgICAgICogdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBmaWxlc2AgYW5kIG11c3QgcmV0dXJuIHRoZSBtZXRob2QgKHNpbmNlIGB2My4xMi4wYCkuXG4gICAgICAgICAqL1xuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIGJlIHNldCBvbiB0aGUgWEhSZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWVvdXQgZm9yIHRoZSBYSFIgcmVxdWVzdHMgaW4gbWlsbGlzZWNvbmRzIChzaW5jZSBgdjQuNC4wYCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aW1lb3V0OiAzMDAwMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG93IG1hbnkgZmlsZSB1cGxvYWRzIHRvIHByb2Nlc3MgaW4gcGFyYWxsZWwgKFNlZSB0aGVcbiAgICAgICAgICogRW5xdWV1aW5nIGZpbGUgdXBsb2FkcyogZG9jdW1lbnRhdGlvbiBzZWN0aW9uIGZvciBtb3JlIGluZm8pXG4gICAgICAgICAqL1xuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gc2VuZCBtdWx0aXBsZSBmaWxlcyBpbiBvbmUgcmVxdWVzdC4gSWZcbiAgICAgICAgICogdGhpcyBpdCBzZXQgdG8gdHJ1ZSwgdGhlbiB0aGUgZmFsbGJhY2sgZmlsZSBpbnB1dCBlbGVtZW50IHdpbGxcbiAgICAgICAgICogaGF2ZSB0aGUgYG11bHRpcGxlYCBhdHRyaWJ1dGUgYXMgd2VsbC4gVGhpcyBvcHRpb24gd2lsbFxuICAgICAgICAgKiBhbHNvIHRyaWdnZXIgYWRkaXRpb25hbCBldmVudHMgKGxpa2UgYHByb2Nlc3NpbmdtdWx0aXBsZWApLiBTZWUgdGhlIGV2ZW50c1xuICAgICAgICAgKiBkb2N1bWVudGF0aW9uIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB1cGxvYWRNdWx0aXBsZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgeW91IHdhbnQgZmlsZXMgdG8gYmUgdXBsb2FkZWQgaW4gY2h1bmtzIHRvIHlvdXIgc2VydmVyLiBUaGlzIGNhbid0IGJlXG4gICAgICAgICAqIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgdXBsb2FkTXVsdGlwbGVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUgW2NodW5rc1VwbG9hZGVkXSgjY29uZmlnLWNodW5rc1VwbG9hZGVkKSBmb3IgdGhlIGNhbGxiYWNrIHRvIGZpbmFsaXNlIGFuIHVwbG9hZC5cbiAgICAgICAgICovXG4gICAgICAgIGNodW5raW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYGNodW5raW5nYCBpcyBlbmFibGVkLCB0aGlzIGRlZmluZXMgd2hldGhlciAqKmV2ZXJ5KiogZmlsZSBzaG91bGQgYmUgY2h1bmtlZCxcbiAgICAgICAgICogZXZlbiBpZiB0aGUgZmlsZSBzaXplIGlzIGJlbG93IGNodW5rU2l6ZS4gVGhpcyBtZWFucywgdGhhdCB0aGUgYWRkaXRpb25hbCBjaHVua1xuICAgICAgICAgKiBmb3JtIGRhdGEgd2lsbCBiZSBzdWJtaXR0ZWQgYW5kIHRoZSBgY2h1bmtzVXBsb2FkZWRgIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIGZvcmNlQ2h1bmtpbmc6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBgY2h1bmtpbmdgIGlzIGB0cnVlYCwgdGhlbiB0aGlzIGRlZmluZXMgdGhlIGNodW5rIHNpemUgaW4gYnl0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjaHVua1NpemU6IDIwMDAwMDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGhlIGluZGl2aWR1YWwgY2h1bmtzIG9mIGEgZmlsZSBhcmUgYmVpbmcgdXBsb2FkZWQgc2ltdWx0YW5lb3VzbHkuXG4gICAgICAgICAqL1xuICAgICAgICBwYXJhbGxlbENodW5rVXBsb2FkczogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgYSBjaHVuayBzaG91bGQgYmUgcmV0cmllZCBpZiBpdCBmYWlscy5cbiAgICAgICAgICovXG4gICAgICAgIHJldHJ5Q2h1bmtzOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYHJldHJ5Q2h1bmtzYCBpcyB0cnVlLCBob3cgbWFueSB0aW1lcyBzaG91bGQgaXQgYmUgcmV0cmllZC5cbiAgICAgICAgICovXG4gICAgICAgIHJldHJ5Q2h1bmtzTGltaXQ6IDMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5vdCBgbnVsbGAgZGVmaW5lcyBob3cgbWFueSBmaWxlcyB0aGlzIERyb3B6b25lIGhhbmRsZXMuIElmIGl0IGV4Y2VlZHMsXG4gICAgICAgICAqIHRoZSBldmVudCBgbWF4ZmlsZXNleGNlZWRlZGAgd2lsbCBiZSBjYWxsZWQuIFRoZSBkcm9wem9uZSBlbGVtZW50IGdldHMgdGhlXG4gICAgICAgICAqIGNsYXNzIGBkei1tYXgtZmlsZXMtcmVhY2hlZGAgYWNjb3JkaW5nbHkgc28geW91IGNhbiBwcm92aWRlIHZpc3VhbCBmZWVkYmFjay5cbiAgICAgICAgICovXG4gICAgICAgIG1heEZpbGVzaXplOiAyNTYsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHBhcmFtIHRoYXQgZ2V0cyB0cmFuc2ZlcnJlZC5cbiAgICAgICAgICogKipOT1RFKio6IElmIHlvdSBoYXZlIHRoZSBvcHRpb24gIGB1cGxvYWRNdWx0aXBsZWAgc2V0IHRvIGB0cnVlYCwgdGhlblxuICAgICAgICAgKiBEcm9wem9uZSB3aWxsIGFwcGVuZCBgW11gIHRvIHRoZSBuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgcGFyYW1OYW1lOiBcImZpbGVcIixcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aHVtYm5haWxzIGZvciBpbWFnZXMgc2hvdWxkIGJlIGdlbmVyYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlSW1hZ2VUaHVtYm5haWxzOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbiBNQi4gV2hlbiB0aGUgZmlsZW5hbWUgZXhjZWVkcyB0aGlzIGxpbWl0LCB0aGUgdGh1bWJuYWlsIHdpbGwgbm90IGJlIGdlbmVyYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIG1heFRodW1ibmFpbEZpbGVzaXplOiAxMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYG51bGxgLCB0aGUgcmF0aW8gb2YgdGhlIGltYWdlIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgaXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aHVtYm5haWxXaWR0aDogMTIwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2FtZSBhcyBgdGh1bWJuYWlsV2lkdGhgLiBJZiBib3RoIGFyZSBudWxsLCBpbWFnZXMgd2lsbCBub3QgYmUgcmVzaXplZC5cbiAgICAgICAgICovXG4gICAgICAgIHRodW1ibmFpbEhlaWdodDogMTIwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb3cgdGhlIGltYWdlcyBzaG91bGQgYmUgc2NhbGVkIGRvd24gaW4gY2FzZSBib3RoLCBgdGh1bWJuYWlsV2lkdGhgIGFuZCBgdGh1bWJuYWlsSGVpZ2h0YCBhcmUgcHJvdmlkZWQuXG4gICAgICAgICAqIENhbiBiZSBlaXRoZXIgYGNvbnRhaW5gIG9yIGBjcm9wYC5cbiAgICAgICAgICovXG4gICAgICAgIHRodW1ibmFpbE1ldGhvZDogJ2Nyb3AnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQsIGltYWdlcyB3aWxsIGJlIHJlc2l6ZWQgdG8gdGhlc2UgZGltZW5zaW9ucyBiZWZvcmUgYmVpbmcgKip1cGxvYWRlZCoqLlxuICAgICAgICAgKiBJZiBvbmx5IG9uZSwgYHJlc2l6ZVdpZHRoYCAqKm9yKiogYHJlc2l6ZUhlaWdodGAgaXMgcHJvdmlkZWQsIHRoZSBvcmlnaW5hbCBhc3BlY3RcbiAgICAgICAgICogcmF0aW8gb2YgdGhlIGZpbGUgd2lsbCBiZSBwcmVzZXJ2ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBgb3B0aW9ucy50cmFuc2Zvcm1GaWxlYCBmdW5jdGlvbiB1c2VzIHRoZXNlIG9wdGlvbnMsIHNvIGlmIHRoZSBgdHJhbnNmb3JtRmlsZWAgZnVuY3Rpb25cbiAgICAgICAgICogaXMgb3ZlcnJpZGRlbiwgdGhlc2Ugb3B0aW9ucyBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZVdpZHRoOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgYHJlc2l6ZVdpZHRoYC5cbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZUhlaWdodDogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbWUgdHlwZSBvZiB0aGUgcmVzaXplZCBpbWFnZSAoYmVmb3JlIGl0IGdldHMgdXBsb2FkZWQgdG8gdGhlIHNlcnZlcikuXG4gICAgICAgICAqIElmIGBudWxsYCB0aGUgb3JpZ2luYWwgbWltZSB0eXBlIHdpbGwgYmUgdXNlZC4gVG8gZm9yY2UganBlZywgZm9yIGV4YW1wbGUsIHVzZSBgaW1hZ2UvanBlZ2AuXG4gICAgICAgICAqIFNlZSBgcmVzaXplV2lkdGhgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplTWltZVR5cGU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBxdWFsaXR5IG9mIHRoZSByZXNpemVkIGltYWdlcy4gU2VlIGByZXNpemVXaWR0aGAuXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemVRdWFsaXR5OiAwLjgsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyB0aGUgaW1hZ2VzIHNob3VsZCBiZSBzY2FsZWQgZG93biBpbiBjYXNlIGJvdGgsIGByZXNpemVXaWR0aGAgYW5kIGByZXNpemVIZWlnaHRgIGFyZSBwcm92aWRlZC5cbiAgICAgICAgICogQ2FuIGJlIGVpdGhlciBgY29udGFpbmAgb3IgYGNyb3BgLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplTWV0aG9kOiAnY29udGFpbicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYXNlIHRoYXQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGZpbGVzaXplLiBZb3UgY2FuIGNoYW5nZSB0aGlzIHRvXG4gICAgICAgICAqIDEwMjQgaWYgeW91IHdvdWxkIHJhdGhlciBkaXNwbGF5IGtpYmlieXRlcywgbWViaWJ5dGVzLCBldGMuLi5cbiAgICAgICAgICogMTAyNCBpcyB0ZWNobmljYWxseSBpbmNvcnJlY3QsIGJlY2F1c2UgYDEwMjQgYnl0ZXNgIGFyZSBgMSBraWJpYnl0ZWAgbm90IGAxIGtpbG9ieXRlYC5cbiAgICAgICAgICogWW91IGNhbiBjaGFuZ2UgdGhpcyB0byBgMTAyNGAgaWYgeW91IGRvbid0IGNhcmUgYWJvdXQgdmFsaWRpdHkuXG4gICAgICAgICAqL1xuICAgICAgICBmaWxlc2l6ZUJhc2U6IDEwMDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbiBiZSB1c2VkIHRvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBmaWxlcyB0aGF0IHdpbGwgYmUgaGFuZGxlZCBieSB0aGlzIERyb3B6b25lXG4gICAgICAgICAqL1xuICAgICAgICBtYXhGaWxlczogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgb2JqZWN0IHRvIHNlbmQgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHRoZSBzZXJ2ZXIuIEVnOlxuICAgICAgICAgKiBgeyBcIk15LUF3ZXNvbWUtSGVhZGVyXCI6IFwiaGVhZGVyIHZhbHVlXCIgfWBcbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcnM6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGhlIGRyb3B6b25lIGVsZW1lbnQgaXRzZWxmIHdpbGwgYmUgY2xpY2thYmxlLCBpZiBgZmFsc2VgXG4gICAgICAgICAqIG5vdGhpbmcgd2lsbCBiZSBjbGlja2FibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIEhUTUwgZWxlbWVudCwgYSBDU1Mgc2VsZWN0b3IgKGZvciBtdWx0aXBsZSBlbGVtZW50cylcbiAgICAgICAgICogb3IgYW4gYXJyYXkgb2YgdGhvc2UuIEluIHRoYXQgY2FzZSwgYWxsIG9mIHRob3NlIGVsZW1lbnRzIHdpbGwgdHJpZ2dlciBhblxuICAgICAgICAgKiB1cGxvYWQgd2hlbiBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xpY2thYmxlOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGhpZGRlbiBmaWxlcyBpbiBkaXJlY3RvcmllcyBzaG91bGQgYmUgaWdub3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlnbm9yZUhpZGRlbkZpbGVzOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgYWNjZXB0YCBjaGVja3MgdGhlIGZpbGUncyBtaW1lIHR5cGUgb3JcbiAgICAgICAgICogZXh0ZW5zaW9uIGFnYWluc3QgdGhpcyBsaXN0LiBUaGlzIGlzIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgbWltZVxuICAgICAgICAgKiB0eXBlcyBvciBmaWxlIGV4dGVuc2lvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEVnLjogYGltYWdlLyosYXBwbGljYXRpb24vcGRmLC5wc2RgXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBEcm9wem9uZSBpcyBgY2xpY2thYmxlYCB0aGlzIG9wdGlvbiB3aWxsIGFsc28gYmUgdXNlZCBhc1xuICAgICAgICAgKiBbYGFjY2VwdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9FbGVtZW50L2lucHV0I2F0dHItYWNjZXB0KVxuICAgICAgICAgKiBwYXJhbWV0ZXIgb24gdGhlIGhpZGRlbiBmaWxlIGlucHV0IGFzIHdlbGwuXG4gICAgICAgICAqL1xuICAgICAgICBhY2NlcHRlZEZpbGVzOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAqKkRlcHJlY2F0ZWQhKipcbiAgICAgICAgICogVXNlIGFjY2VwdGVkRmlsZXMgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIGFjY2VwdGVkTWltZVR5cGVzOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBmYWxzZSwgZmlsZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgcXVldWUgYnV0IHRoZSBxdWV1ZSB3aWxsIG5vdCBiZVxuICAgICAgICAgKiBwcm9jZXNzZWQgYXV0b21hdGljYWxseS5cbiAgICAgICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdSBuZWVkIHNvbWUgYWRkaXRpb25hbCB1c2VyIGlucHV0IGJlZm9yZSBzZW5kaW5nXG4gICAgICAgICAqIGZpbGVzIChvciBpZiB5b3Ugd2FudCB3YW50IGFsbCBmaWxlcyBzZW50IGF0IG9uY2UpLlxuICAgICAgICAgKiBJZiB5b3UncmUgcmVhZHkgdG8gc2VuZCB0aGUgZmlsZSBzaW1wbHkgY2FsbCBgbXlEcm9wem9uZS5wcm9jZXNzUXVldWUoKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSB0aGUgW2VucXVldWluZyBmaWxlIHVwbG9hZHNdKCNlbnF1ZXVpbmctZmlsZS11cGxvYWRzKSBkb2N1bWVudGF0aW9uXG4gICAgICAgICAqIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvUHJvY2Vzc1F1ZXVlOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBmYWxzZSwgZmlsZXMgYWRkZWQgdG8gdGhlIGRyb3B6b25lIHdpbGwgbm90IGJlIHF1ZXVlZCBieSBkZWZhdWx0LlxuICAgICAgICAgKiBZb3UnbGwgaGF2ZSB0byBjYWxsIGBlbnF1ZXVlRmlsZShmaWxlKWAgbWFudWFsbHkuXG4gICAgICAgICAqL1xuICAgICAgICBhdXRvUXVldWU6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGhpcyB3aWxsIGFkZCBhIGxpbmsgdG8gZXZlcnkgZmlsZSBwcmV2aWV3IHRvIHJlbW92ZSBvciBjYW5jZWwgKGlmXG4gICAgICAgICAqIGFscmVhZHkgdXBsb2FkaW5nKSB0aGUgZmlsZS4gVGhlIGBkaWN0Q2FuY2VsVXBsb2FkYCwgYGRpY3RDYW5jZWxVcGxvYWRDb25maXJtYXRpb25gXG4gICAgICAgICAqIGFuZCBgZGljdFJlbW92ZUZpbGVgIG9wdGlvbnMgYXJlIHVzZWQgZm9yIHRoZSB3b3JkaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUmVtb3ZlTGlua3M6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHdoZXJlIHRvIGRpc3BsYXkgdGhlIGZpbGUgcHJldmlld3Mg4oCTIGlmIGBudWxsYCB0aGVcbiAgICAgICAgICogRHJvcHpvbmUgZWxlbWVudCBpdHNlbGYgaXMgdXNlZC4gQ2FuIGJlIGEgcGxhaW4gYEhUTUxFbGVtZW50YCBvciBhIENTU1xuICAgICAgICAgKiBzZWxlY3Rvci4gVGhlIGVsZW1lbnQgc2hvdWxkIGhhdmUgdGhlIGBkcm9wem9uZS1wcmV2aWV3c2AgY2xhc3Mgc29cbiAgICAgICAgICogdGhlIHByZXZpZXdzIGFyZSBkaXNwbGF5ZWQgcHJvcGVybHkuXG4gICAgICAgICAqL1xuICAgICAgICBwcmV2aWV3c0NvbnRhaW5lcjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgZWxlbWVudCB0aGUgaGlkZGVuIGlucHV0IGZpZWxkICh3aGljaCBpcyB1c2VkIHdoZW4gY2xpY2tpbmcgb24gdGhlXG4gICAgICAgICAqIGRyb3B6b25lIHRvIHRyaWdnZXIgZmlsZSBzZWxlY3Rpb24pIHdpbGwgYmUgYXBwZW5kZWQgdG8uIFRoaXMgbWlnaHRcbiAgICAgICAgICogYmUgaW1wb3J0YW50IGluIGNhc2UgeW91IHVzZSBmcmFtZXdvcmtzIHRvIHN3aXRjaCB0aGUgY29udGVudCBvZiB5b3VyIHBhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIENhbiBiZSBhIHNlbGVjdG9yIHN0cmluZywgb3IgYW4gZWxlbWVudCBkaXJlY3RseS5cbiAgICAgICAgICovXG4gICAgICAgIGhpZGRlbklucHV0Q29udGFpbmVyOiBcImJvZHlcIixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbnVsbCwgbm8gY2FwdHVyZSB0eXBlIHdpbGwgYmUgc3BlY2lmaWVkXG4gICAgICAgICAqIElmIGNhbWVyYSwgbW9iaWxlIGRldmljZXMgd2lsbCBza2lwIHRoZSBmaWxlIHNlbGVjdGlvbiBhbmQgY2hvb3NlIGNhbWVyYVxuICAgICAgICAgKiBJZiBtaWNyb3Bob25lLCBtb2JpbGUgZGV2aWNlcyB3aWxsIHNraXAgdGhlIGZpbGUgc2VsZWN0aW9uIGFuZCBjaG9vc2UgdGhlIG1pY3JvcGhvbmVcbiAgICAgICAgICogSWYgY2FtY29yZGVyLCBtb2JpbGUgZGV2aWNlcyB3aWxsIHNraXAgdGhlIGZpbGUgc2VsZWN0aW9uIGFuZCBjaG9vc2UgdGhlIGNhbWVyYSBpbiB2aWRlbyBtb2RlXG4gICAgICAgICAqIE9uIGFwcGxlIGRldmljZXMgbXVsdGlwbGUgbXVzdCBiZSBzZXQgdG8gZmFsc2UuICBBY2NlcHRlZEZpbGVzIG1heSBuZWVkIHRvXG4gICAgICAgICAqIGJlIHNldCB0byBhbiBhcHByb3ByaWF0ZSBtaW1lIHR5cGUgKGUuZy4gXCJpbWFnZS8qXCIsIFwiYXVkaW8vKlwiLCBvciBcInZpZGVvLypcIikuXG4gICAgICAgICAqL1xuICAgICAgICBjYXB0dXJlOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAqKkRlcHJlY2F0ZWQqKi4gVXNlIGByZW5hbWVGaWxlYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVuYW1lRmlsZW5hbWU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIGJlZm9yZSB0aGUgZmlsZSBpcyB1cGxvYWRlZCB0byB0aGUgc2VydmVyIGFuZCByZW5hbWVzIHRoZSBmaWxlLlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGdldHMgdGhlIGBGaWxlYCBhcyBhcmd1bWVudCBhbmQgY2FuIHVzZSB0aGUgYGZpbGUubmFtZWAuIFRoZSBhY3R1YWwgbmFtZSBvZiB0aGVcbiAgICAgICAgICogZmlsZSB0aGF0IGdldHMgdXNlZCBkdXJpbmcgdGhlIHVwbG9hZCBjYW4gYmUgYWNjZXNzZWQgdGhyb3VnaCBgZmlsZS51cGxvYWQuZmlsZW5hbWVgLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVuYW1lRmlsZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYHRydWVgIHRoZSBmYWxsYmFjayB3aWxsIGJlIGZvcmNlZC4gVGhpcyBpcyB2ZXJ5IHVzZWZ1bCB0byB0ZXN0IHlvdXIgc2VydmVyXG4gICAgICAgICAqIGltcGxlbWVudGF0aW9ucyBmaXJzdCBhbmQgbWFrZSBzdXJlIHRoYXQgZXZlcnl0aGluZyB3b3JrcyBhc1xuICAgICAgICAgKiBleHBlY3RlZCB3aXRob3V0IGRyb3B6b25lIGlmIHlvdSBleHBlcmllbmNlIHByb2JsZW1zLCBhbmQgdG8gdGVzdFxuICAgICAgICAgKiBob3cgeW91ciBmYWxsYmFja3Mgd2lsbCBsb29rLlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yY2VGYWxsYmFjazogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IHVzZWQgYmVmb3JlIGFueSBmaWxlcyBhcmUgZHJvcHBlZC5cbiAgICAgICAgICovXG4gICAgICAgIGRpY3REZWZhdWx0TWVzc2FnZTogXCJEcm9wIGZpbGVzIGhlcmUgdG8gdXBsb2FkXCIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IHRoYXQgcmVwbGFjZXMgdGhlIGRlZmF1bHQgbWVzc2FnZSB0ZXh0IGl0IHRoZSBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBkaWN0RmFsbGJhY2tNZXNzYWdlOiBcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGRyYWcnbidkcm9wIGZpbGUgdXBsb2Fkcy5cIixcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHQgdGhhdCB3aWxsIGJlIGFkZGVkIGJlZm9yZSB0aGUgZmFsbGJhY2sgZm9ybS5cbiAgICAgICAgICogSWYgeW91IHByb3ZpZGUgYSAgZmFsbGJhY2sgZWxlbWVudCB5b3Vyc2VsZiwgb3IgaWYgdGhpcyBvcHRpb24gaXMgYG51bGxgIHRoaXMgd2lsbFxuICAgICAgICAgKiBiZSBpZ25vcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZGljdEZhbGxiYWNrVGV4dDogXCJQbGVhc2UgdXNlIHRoZSBmYWxsYmFjayBmb3JtIGJlbG93IHRvIHVwbG9hZCB5b3VyIGZpbGVzIGxpa2UgaW4gdGhlIG9sZGVuIGRheXMuXCIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBmaWxlc2l6ZSBpcyB0b28gYmlnLlxuICAgICAgICAgKiBge3tmaWxlc2l6ZX19YCBhbmQgYHt7bWF4RmlsZXNpemV9fWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSByZXNwZWN0aXZlIGNvbmZpZ3VyYXRpb24gdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgZGljdEZpbGVUb29CaWc6IFwiRmlsZSBpcyB0b28gYmlnICh7e2ZpbGVzaXplfX1NaUIpLiBNYXggZmlsZXNpemU6IHt7bWF4RmlsZXNpemV9fU1pQi5cIixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGZpbGUgZG9lc24ndCBtYXRjaCB0aGUgZmlsZSB0eXBlLlxuICAgICAgICAgKi9cbiAgICAgICAgZGljdEludmFsaWRGaWxlVHlwZTogXCJZb3UgY2FuJ3QgdXBsb2FkIGZpbGVzIG9mIHRoaXMgdHlwZS5cIixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHNlcnZlciByZXNwb25zZSB3YXMgaW52YWxpZC5cbiAgICAgICAgICogYHt7c3RhdHVzQ29kZX19YCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIHNlcnZlcnMgc3RhdHVzIGNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICBkaWN0UmVzcG9uc2VFcnJvcjogXCJTZXJ2ZXIgcmVzcG9uZGVkIHdpdGgge3tzdGF0dXNDb2RlfX0gY29kZS5cIixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYGFkZFJlbW92ZUxpbmtzYCBpcyB0cnVlLCB0aGUgdGV4dCB0byBiZSB1c2VkIGZvciB0aGUgY2FuY2VsIHVwbG9hZCBsaW5rLlxuICAgICAgICAgKi9cbiAgICAgICAgZGljdENhbmNlbFVwbG9hZDogXCJDYW5jZWwgdXBsb2FkXCIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIGlmIGFuIHVwbG9hZCB3YXMgbWFudWFsbHkgY2FuY2VsZWRcbiAgICAgICAgICovXG4gICAgICAgIGRpY3RVcGxvYWRDYW5jZWxlZDogXCJVcGxvYWQgY2FuY2VsZWQuXCIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGBhZGRSZW1vdmVMaW5rc2AgaXMgdHJ1ZSwgdGhlIHRleHQgdG8gYmUgdXNlZCBmb3IgY29uZmlybWF0aW9uIHdoZW4gY2FuY2VsbGluZyB1cGxvYWQuXG4gICAgICAgICAqL1xuICAgICAgICBkaWN0Q2FuY2VsVXBsb2FkQ29uZmlybWF0aW9uOiBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBjYW5jZWwgdGhpcyB1cGxvYWQ/XCIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGBhZGRSZW1vdmVMaW5rc2AgaXMgdHJ1ZSwgdGhlIHRleHQgdG8gYmUgdXNlZCB0byByZW1vdmUgYSBmaWxlLlxuICAgICAgICAgKi9cbiAgICAgICAgZGljdFJlbW92ZUZpbGU6IFwiUmVtb3ZlIGZpbGVcIixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhpcyBpcyBub3QgbnVsbCwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIHByb21wdGVkIGJlZm9yZSByZW1vdmluZyBhIGZpbGUuXG4gICAgICAgICAqL1xuICAgICAgICBkaWN0UmVtb3ZlRmlsZUNvbmZpcm1hdGlvbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGxheWVkIGlmIGBtYXhGaWxlc2AgaXMgc3QgYW5kIGV4Y2VlZGVkLlxuICAgICAgICAgKiBUaGUgc3RyaW5nIGB7e21heEZpbGVzfX1gIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBkaWN0TWF4RmlsZXNFeGNlZWRlZDogXCJZb3UgY2FuIG5vdCB1cGxvYWQgYW55IG1vcmUgZmlsZXMuXCIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyB5b3UgdG8gdHJhbnNsYXRlIHRoZSBkaWZmZXJlbnQgdW5pdHMuIFN0YXJ0aW5nIHdpdGggYHRiYCBmb3IgdGVyYWJ5dGVzIGFuZCBnb2luZyBkb3duIHRvXG4gICAgICAgICAqIGBiYCBmb3IgYnl0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBkaWN0RmlsZVNpemVVbml0czogeyB0YjogXCJUQlwiLCBnYjogXCJHQlwiLCBtYjogXCJNQlwiLCBrYjogXCJLQlwiLCBiOiBcImJcIiB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gZHJvcHpvbmUgaW5pdGlhbGl6ZWRcbiAgICAgICAgICogWW91IGNhbiBhZGQgZXZlbnQgbGlzdGVuZXJzIGhlcmVcbiAgICAgICAgICovXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7fSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW4gYmUgYW4gKipvYmplY3QqKiBvZiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gdHJhbnNmZXIgdG8gdGhlIHNlcnZlciwgKipvcioqIGEgYEZ1bmN0aW9uYFxuICAgICAgICAgKiB0aGF0IGdldHMgaW52b2tlZCB3aXRoIHRoZSBgZmlsZXNgLCBgeGhyYCBhbmQsIGlmIGl0J3MgYSBjaHVua2VkIHVwbG9hZCwgYGNodW5rYCBhcmd1bWVudHMuIEluIGNhc2VcbiAgICAgICAgICogb2YgYSBmdW5jdGlvbiwgdGhpcyBuZWVkcyB0byByZXR1cm4gYSBtYXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGRvZXMgbm90aGluZyBmb3Igbm9ybWFsIHVwbG9hZHMsIGJ1dCBhZGRzIHJlbGV2YW50IGluZm9ybWF0aW9uIGZvclxuICAgICAgICAgKiBjaHVua2VkIHVwbG9hZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgYWRkaW5nIGhpZGRlbiBpbnB1dCBmaWVsZHMgaW4gdGhlIGZvcm0gZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHBhcmFtczogZnVuY3Rpb24gcGFyYW1zKGZpbGVzLCB4aHIsIGNodW5rKSB7XG4gICAgICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkenV1aWQ6IGNodW5rLmZpbGUudXBsb2FkLnV1aWQsXG4gICAgICAgICAgICAgIGR6Y2h1bmtpbmRleDogY2h1bmsuaW5kZXgsXG4gICAgICAgICAgICAgIGR6dG90YWxmaWxlc2l6ZTogY2h1bmsuZmlsZS5zaXplLFxuICAgICAgICAgICAgICBkemNodW5rc2l6ZTogdGhpcy5vcHRpb25zLmNodW5rU2l6ZSxcbiAgICAgICAgICAgICAgZHp0b3RhbGNodW5rY291bnQ6IGNodW5rLmZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudCxcbiAgICAgICAgICAgICAgZHpjaHVua2J5dGVvZmZzZXQ6IGNodW5rLmluZGV4ICogdGhpcy5vcHRpb25zLmNodW5rU2l6ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGdldHMgYSBbZmlsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vRmlsZSlcbiAgICAgICAgICogYW5kIGEgYGRvbmVgIGZ1bmN0aW9uIGFzIHBhcmFtZXRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBkb25lIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIHRoZSBmaWxlIGlzIFwiYWNjZXB0ZWRcIiBhbmQgd2lsbFxuICAgICAgICAgKiBiZSBwcm9jZXNzZWQuIElmIHlvdSBwYXNzIGFuIGVycm9yIG1lc3NhZ2UsIHRoZSBmaWxlIGlzIHJlamVjdGVkLCBhbmQgdGhlIGVycm9yXG4gICAgICAgICAqIG1lc3NhZ2Ugd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBub3QgYmUgY2FsbGVkIGlmIHRoZSBmaWxlIGlzIHRvbyBiaWcgb3IgZG9lc24ndCBtYXRjaCB0aGUgbWltZSB0eXBlcy5cbiAgICAgICAgICovXG4gICAgICAgIGFjY2VwdDogZnVuY3Rpb24gYWNjZXB0KGZpbGUsIGRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGFsbCBjaHVua3MgaGF2ZSBiZWVuIHVwbG9hZGVkIGZvciBhIGZpbGUuXG4gICAgICAgICAqIEl0IGdldHMgdGhlIGZpbGUgZm9yIHdoaWNoIHRoZSBjaHVua3MgaGF2ZSBiZWVuIHVwbG9hZGVkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsXG4gICAgICAgICAqIGFuZCB0aGUgYGRvbmVgIGZ1bmN0aW9uIGFzIHNlY29uZC4gYGRvbmUoKWAgbmVlZHMgdG8gYmUgaW52b2tlZCB3aGVuIGV2ZXJ5dGhpbmdcbiAgICAgICAgICogbmVlZGVkIHRvIGZpbmlzaCB0aGUgdXBsb2FkIHByb2Nlc3MgaXMgZG9uZS5cbiAgICAgICAgICovXG4gICAgICAgIGNodW5rc1VwbG9hZGVkOiBmdW5jdGlvbiBjaHVua3NVcGxvYWRlZChmaWxlLCBkb25lKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNob3dzIHRoZSBmYWxsYmFjayBpbnB1dCBmaWVsZCBhbmQgYWRkc1xuICAgICAgICAgKiBhIHRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBmYWxsYmFjazogZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb2RlIHNob3VsZCBwYXNzIGluIElFNy4uLiA6KFxuICAgICAgICAgIHZhciBtZXNzYWdlRWxlbWVudCA9IHZvaWQgMDtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5lbGVtZW50LmNsYXNzTmFtZSArIFwiIGR6LWJyb3dzZXItbm90LXN1cHBvcnRlZFwiO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoaXMuZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKSwgX2lzQXJyYXkyID0gdHJ1ZSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgICB2YXIgX3JlZjI7XG5cbiAgICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgICAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9yZWYyO1xuXG4gICAgICAgICAgICBpZiAoLyhefCApZHotbWVzc2FnZSgkfCApLy50ZXN0KGNoaWxkLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgY2hpbGQuY2xhc3NOYW1lID0gXCJkei1tZXNzYWdlXCI7IC8vIFJlbW92ZXMgdGhlICdkei1kZWZhdWx0JyBjbGFzc1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFtZXNzYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSBEcm9wem9uZS5jcmVhdGVFbGVtZW50KFwiPGRpdiBjbGFzcz1cXFwiZHotbWVzc2FnZVxcXCI+PHNwYW4+PC9zcGFuPjwvZGl2PlwiKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChtZXNzYWdlRWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNwYW4gPSBtZXNzYWdlRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNwYW5cIilbMF07XG4gICAgICAgICAgaWYgKHNwYW4pIHtcbiAgICAgICAgICAgIGlmIChzcGFuLnRleHRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHRoaXMub3B0aW9ucy5kaWN0RmFsbGJhY2tNZXNzYWdlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzcGFuLmlubmVyVGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNwYW4uaW5uZXJUZXh0ID0gdGhpcy5vcHRpb25zLmRpY3RGYWxsYmFja01lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmdldEZhbGxiYWNrRm9ybSgpKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGNhbGxlZCB0byBjYWxjdWxhdGUgdGhlIHRodW1ibmFpbCBkaW1lbnNpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCBnZXRzIGBmaWxlYCwgYHdpZHRoYCBhbmQgYGhlaWdodGAgKGJvdGggbWF5IGJlIGBudWxsYCkgYXMgcGFyYW1ldGVycyBhbmQgbXVzdCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmc6XG4gICAgICAgICAqXG4gICAgICAgICAqICAtIGBzcmNXaWR0aGAgJiBgc3JjSGVpZ2h0YCAocmVxdWlyZWQpXG4gICAgICAgICAqICAtIGB0cmdXaWR0aGAgJiBgdHJnSGVpZ2h0YCAocmVxdWlyZWQpXG4gICAgICAgICAqICAtIGBzcmNYYCAmIGBzcmNZYCAob3B0aW9uYWwsIGRlZmF1bHQgYDBgKVxuICAgICAgICAgKiAgLSBgdHJnWGAgJiBgdHJnWWAgKG9wdGlvbmFsLCBkZWZhdWx0IGAwYClcbiAgICAgICAgICpcbiAgICAgICAgICogVGhvc2UgdmFsdWVzIGFyZSBnb2luZyB0byBiZSB1c2VkIGJ5IGBjdHguZHJhd0ltYWdlKClgLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoZmlsZSwgd2lkdGgsIGhlaWdodCwgcmVzaXplTWV0aG9kKSB7XG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICBzcmNYOiAwLFxuICAgICAgICAgICAgc3JjWTogMCxcbiAgICAgICAgICAgIHNyY1dpZHRoOiBmaWxlLndpZHRoLFxuICAgICAgICAgICAgc3JjSGVpZ2h0OiBmaWxlLmhlaWdodFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgc3JjUmF0aW8gPSBmaWxlLndpZHRoIC8gZmlsZS5oZWlnaHQ7XG5cbiAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSBkaW1lbnNpb25zIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgd2lkdGggPSBpbmZvLnNyY1dpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gaW5mby5zcmNIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIHNyY1JhdGlvO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gc3JjUmF0aW87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGltYWdlcyBhcmVuJ3QgdXBzY2FsZWRcbiAgICAgICAgICB3aWR0aCA9IE1hdGgubWluKHdpZHRoLCBpbmZvLnNyY1dpZHRoKTtcbiAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIGluZm8uc3JjSGVpZ2h0KTtcblxuICAgICAgICAgIHZhciB0cmdSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKGluZm8uc3JjV2lkdGggPiB3aWR0aCB8fCBpbmZvLnNyY0hlaWdodCA+IGhlaWdodCkge1xuICAgICAgICAgICAgLy8gSW1hZ2UgaXMgYmlnZ2VyIGFuZCBuZWVkcyByZXNjYWxpbmdcbiAgICAgICAgICAgIGlmIChyZXNpemVNZXRob2QgPT09ICdjcm9wJykge1xuICAgICAgICAgICAgICBpZiAoc3JjUmF0aW8gPiB0cmdSYXRpbykge1xuICAgICAgICAgICAgICAgIGluZm8uc3JjSGVpZ2h0ID0gZmlsZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaW5mby5zcmNXaWR0aCA9IGluZm8uc3JjSGVpZ2h0ICogdHJnUmF0aW87XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5mby5zcmNXaWR0aCA9IGZpbGUud2lkdGg7XG4gICAgICAgICAgICAgICAgaW5mby5zcmNIZWlnaHQgPSBpbmZvLnNyY1dpZHRoIC8gdHJnUmF0aW87XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzaXplTWV0aG9kID09PSAnY29udGFpbicpIHtcbiAgICAgICAgICAgICAgLy8gTWV0aG9kICdjb250YWluJ1xuICAgICAgICAgICAgICBpZiAoc3JjUmF0aW8gPiB0cmdSYXRpbykge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gc3JjUmF0aW87XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBzcmNSYXRpbztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByZXNpemVNZXRob2QgJ1wiICsgcmVzaXplTWV0aG9kICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZm8uc3JjWCA9IChmaWxlLndpZHRoIC0gaW5mby5zcmNXaWR0aCkgLyAyO1xuICAgICAgICAgIGluZm8uc3JjWSA9IChmaWxlLmhlaWdodCAtIGluZm8uc3JjSGVpZ2h0KSAvIDI7XG5cbiAgICAgICAgICBpbmZvLnRyZ1dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgaW5mby50cmdIZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGZpbGUgKGZvciBleGFtcGxlLCByZXNpemUgYW4gaW1hZ2UgaWYgbmVjZXNzYXJ5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gdXNlcyBgcmVzaXplV2lkdGhgIGFuZCBgcmVzaXplSGVpZ2h0YCAoaWYgcHJvdmlkZWQpIGFuZCByZXNpemVzXG4gICAgICAgICAqIGltYWdlcyBhY2NvcmRpbmcgdG8gdGhvc2UgZGltZW5zaW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogR2V0cyB0aGUgYGZpbGVgIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIGFuZCBhIGBkb25lKClgIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQsIHRoYXQgbmVlZHNcbiAgICAgICAgICogdG8gYmUgaW52b2tlZCB3aXRoIHRoZSBmaWxlIHdoZW4gdGhlIHRyYW5zZm9ybWF0aW9uIGlzIGRvbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2Zvcm1GaWxlOiBmdW5jdGlvbiB0cmFuc2Zvcm1GaWxlKGZpbGUsIGRvbmUpIHtcbiAgICAgICAgICBpZiAoKHRoaXMub3B0aW9ucy5yZXNpemVXaWR0aCB8fCB0aGlzLm9wdGlvbnMucmVzaXplSGVpZ2h0KSAmJiBmaWxlLnR5cGUubWF0Y2goL2ltYWdlLiovKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplSW1hZ2UoZmlsZSwgdGhpcy5vcHRpb25zLnJlc2l6ZVdpZHRoLCB0aGlzLm9wdGlvbnMucmVzaXplSGVpZ2h0LCB0aGlzLm9wdGlvbnMucmVzaXplTWV0aG9kLCBkb25lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoZmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIHRlbXBsYXRlIHVzZWQgZm9yIGVhY2ggZHJvcHBlZFxuICAgICAgICAgKiBmaWxlLiBDaGFuZ2UgaXQgdG8gZnVsZmlsbCB5b3VyIG5lZWRzIGJ1dCBtYWtlIHN1cmUgdG8gcHJvcGVybHlcbiAgICAgICAgICogcHJvdmlkZSBhbGwgZWxlbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHVzZSBhbiBhY3R1YWwgSFRNTCBlbGVtZW50IGluc3RlYWQgb2YgcHJvdmlkaW5nIGEgU3RyaW5nXG4gICAgICAgICAqIGFzIGEgY29uZmlnIG9wdGlvbiwgeW91IGNvdWxkIGNyZWF0ZSBhIGRpdiB3aXRoIHRoZSBpZCBgdHBsYCxcbiAgICAgICAgICogcHV0IHRoZSB0ZW1wbGF0ZSBpbnNpZGUgaXQgYW5kIHByb3ZpZGUgdGhlIGVsZW1lbnQgbGlrZSB0aGlzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgZG9jdW1lbnRcbiAgICAgICAgICogICAgICAgLnF1ZXJ5U2VsZWN0b3IoJyN0cGwnKVxuICAgICAgICAgKiAgICAgICAuaW5uZXJIVE1MXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBwcmV2aWV3VGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwiZHotcHJldmlldyBkei1maWxlLXByZXZpZXdcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiZHotaW1hZ2VcXFwiPjxpbWcgZGF0YS1kei10aHVtYm5haWwgLz48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImR6LWRldGFpbHNcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJkei1zaXplXFxcIj48c3BhbiBkYXRhLWR6LXNpemU+PC9zcGFuPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJkei1maWxlbmFtZVxcXCI+PHNwYW4gZGF0YS1kei1uYW1lPjwvc3Bhbj48L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiZHotcHJvZ3Jlc3NcXFwiPjxzcGFuIGNsYXNzPVxcXCJkei11cGxvYWRcXFwiIGRhdGEtZHotdXBsb2FkcHJvZ3Jlc3M+PC9zcGFuPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiZHotZXJyb3ItbWVzc2FnZVxcXCI+PHNwYW4gZGF0YS1kei1lcnJvcm1lc3NhZ2U+PC9zcGFuPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiZHotc3VjY2Vzcy1tYXJrXFxcIj5cXG4gICAgPHN2ZyB3aWR0aD1cXFwiNTRweFxcXCIgaGVpZ2h0PVxcXCI1NHB4XFxcIiB2aWV3Qm94PVxcXCIwIDAgNTQgNTRcXFwiIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgeG1sbnM6c2tldGNoPVxcXCJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnNcXFwiPlxcbiAgICAgIDx0aXRsZT5DaGVjazwvdGl0bGU+XFxuICAgICAgPGRlZnM+PC9kZWZzPlxcbiAgICAgIDxnIGlkPVxcXCJQYWdlLTFcXFwiIHN0cm9rZT1cXFwibm9uZVxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxXFxcIiBmaWxsPVxcXCJub25lXFxcIiBmaWxsLXJ1bGU9XFxcImV2ZW5vZGRcXFwiIHNrZXRjaDp0eXBlPVxcXCJNU1BhZ2VcXFwiPlxcbiAgICAgICAgPHBhdGggZD1cXFwiTTIzLjUsMzEuODQzMTQ1OCBMMTcuNTg1MjQxOSwyNS45MjgzODc3IEMxNi4wMjQ4MjUzLDI0LjM2Nzk3MTEgMTMuNDkxMDI5NCwyNC4zNjY4MzUgMTEuOTI4OTMyMiwyNS45Mjg5MzIyIEMxMC4zNzAwMTM2LDI3LjQ4Nzg1MDggMTAuMzY2NTkxMiwzMC4wMjM0NDU1IDExLjkyODM4NzcsMzEuNTg1MjQxOSBMMjAuNDE0NzU4MSw0MC4wNzE2MTIzIEMyMC41MTMzOTk5LDQwLjE3MDI1NDEgMjAuNjE1OTMxNSw0MC4yNjI2NjQ5IDIwLjcyMTg2MTUsNDAuMzQ4ODQzNSBDMjIuMjgzNTY2OSw0MS44NzI1NjUxIDI0Ljc5NDIzNCw0MS44NjI2MjAyIDI2LjM0NjE1NjQsNDAuMzEwNjk3OCBMNDMuMzEwNjk3OCwyMy4zNDYxNTY0IEM0NC44NzcxMDIxLDIxLjc3OTc1MjEgNDQuODc1ODA1NywxOS4yNDgzODg3IDQzLjMxMzcwODUsMTcuNjg2MjkxNSBDNDEuNzU0Nzg5OSwxNi4xMjczNzI5IDM5LjIxNzYwMzUsMTYuMTI1NTQyMiAzNy42NTM4NDM2LDE3LjY4OTMwMjIgTDIzLjUsMzEuODQzMTQ1OCBaIE0yNyw1MyBDNDEuMzU5NDAzNSw1MyA1Myw0MS4zNTk0MDM1IDUzLDI3IEM1MywxMi42NDA1OTY1IDQxLjM1OTQwMzUsMSAyNywxIEMxMi42NDA1OTY1LDEgMSwxMi42NDA1OTY1IDEsMjcgQzEsNDEuMzU5NDAzNSAxMi42NDA1OTY1LDUzIDI3LDUzIFpcXFwiIGlkPVxcXCJPdmFsLTJcXFwiIHN0cm9rZS1vcGFjaXR5PVxcXCIwLjE5ODc5NDE1OFxcXCIgc3Ryb2tlPVxcXCIjNzQ3NDc0XFxcIiBmaWxsLW9wYWNpdHk9XFxcIjAuODE2NTE5NDc1XFxcIiBmaWxsPVxcXCIjRkZGRkZGXFxcIiBza2V0Y2g6dHlwZT1cXFwiTVNTaGFwZUdyb3VwXFxcIj48L3BhdGg+XFxuICAgICAgPC9nPlxcbiAgICA8L3N2Zz5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwiZHotZXJyb3ItbWFya1xcXCI+XFxuICAgIDxzdmcgd2lkdGg9XFxcIjU0cHhcXFwiIGhlaWdodD1cXFwiNTRweFxcXCIgdmlld0JveD1cXFwiMCAwIDU0IDU0XFxcIiB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHhtbG5zOnNrZXRjaD1cXFwiaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoL25zXFxcIj5cXG4gICAgICA8dGl0bGU+RXJyb3I8L3RpdGxlPlxcbiAgICAgIDxkZWZzPjwvZGVmcz5cXG4gICAgICA8ZyBpZD1cXFwiUGFnZS0xXFxcIiBzdHJva2U9XFxcIm5vbmVcXFwiIHN0cm9rZS13aWR0aD1cXFwiMVxcXCIgZmlsbD1cXFwibm9uZVxcXCIgZmlsbC1ydWxlPVxcXCJldmVub2RkXFxcIiBza2V0Y2g6dHlwZT1cXFwiTVNQYWdlXFxcIj5cXG4gICAgICAgIDxnIGlkPVxcXCJDaGVjay0rLU92YWwtMlxcXCIgc2tldGNoOnR5cGU9XFxcIk1TTGF5ZXJHcm91cFxcXCIgc3Ryb2tlPVxcXCIjNzQ3NDc0XFxcIiBzdHJva2Utb3BhY2l0eT1cXFwiMC4xOTg3OTQxNThcXFwiIGZpbGw9XFxcIiNGRkZGRkZcXFwiIGZpbGwtb3BhY2l0eT1cXFwiMC44MTY1MTk0NzVcXFwiPlxcbiAgICAgICAgICA8cGF0aCBkPVxcXCJNMzIuNjU2ODU0MiwyOSBMMzguMzEwNjk3OCwyMy4zNDYxNTY0IEMzOS44NzcxMDIxLDIxLjc3OTc1MjEgMzkuODc1ODA1NywxOS4yNDgzODg3IDM4LjMxMzcwODUsMTcuNjg2MjkxNSBDMzYuNzU0Nzg5OSwxNi4xMjczNzI5IDM0LjIxNzYwMzUsMTYuMTI1NTQyMiAzMi42NTM4NDM2LDE3LjY4OTMwMjIgTDI3LDIzLjM0MzE0NTggTDIxLjM0NjE1NjQsMTcuNjg5MzAyMiBDMTkuNzgyMzk2NSwxNi4xMjU1NDIyIDE3LjI0NTIxMDEsMTYuMTI3MzcyOSAxNS42ODYyOTE1LDE3LjY4NjI5MTUgQzE0LjEyNDE5NDMsMTkuMjQ4Mzg4NyAxNC4xMjI4OTc5LDIxLjc3OTc1MjEgMTUuNjg5MzAyMiwyMy4zNDYxNTY0IEwyMS4zNDMxNDU4LDI5IEwxNS42ODkzMDIyLDM0LjY1Mzg0MzYgQzE0LjEyMjg5NzksMzYuMjIwMjQ3OSAxNC4xMjQxOTQzLDM4Ljc1MTYxMTMgMTUuNjg2MjkxNSw0MC4zMTM3MDg1IEMxNy4yNDUyMTAxLDQxLjg3MjYyNzEgMTkuNzgyMzk2NSw0MS44NzQ0NTc4IDIxLjM0NjE1NjQsNDAuMzEwNjk3OCBMMjcsMzQuNjU2ODU0MiBMMzIuNjUzODQzNiw0MC4zMTA2OTc4IEMzNC4yMTc2MDM1LDQxLjg3NDQ1NzggMzYuNzU0Nzg5OSw0MS44NzI2MjcxIDM4LjMxMzcwODUsNDAuMzEzNzA4NSBDMzkuODc1ODA1NywzOC43NTE2MTEzIDM5Ljg3NzEwMjEsMzYuMjIwMjQ3OSAzOC4zMTA2OTc4LDM0LjY1Mzg0MzYgTDMyLjY1Njg1NDIsMjkgWiBNMjcsNTMgQzQxLjM1OTQwMzUsNTMgNTMsNDEuMzU5NDAzNSA1MywyNyBDNTMsMTIuNjQwNTk2NSA0MS4zNTk0MDM1LDEgMjcsMSBDMTIuNjQwNTk2NSwxIDEsMTIuNjQwNTk2NSAxLDI3IEMxLDQxLjM1OTQwMzUgMTIuNjQwNTk2NSw1MyAyNyw1MyBaXFxcIiBpZD1cXFwiT3ZhbC0yXFxcIiBza2V0Y2g6dHlwZT1cXFwiTVNTaGFwZUdyb3VwXFxcIj48L3BhdGg+XFxuICAgICAgICA8L2c+XFxuICAgICAgPC9nPlxcbiAgICA8L3N2Zz5cXG4gIDwvZGl2PlxcbjwvZGl2PlwiLFxuXG4gICAgICAgIC8vIEVORCBPUFRJT05TXG4gICAgICAgIC8vIChSZXF1aXJlZCBieSB0aGUgZHJvcHpvbmUgZG9jdW1lbnRhdGlvbiBwYXJzZXIpXG5cblxuICAgICAgICAvKlxuICAgICAgICAgVGhvc2UgZnVuY3Rpb25zIHJlZ2lzdGVyIHRoZW1zZWx2ZXMgdG8gdGhlIGV2ZW50cyBvbiBpbml0IGFuZCBoYW5kbGUgYWxsXG4gICAgICAgICB0aGUgdXNlciBpbnRlcmZhY2Ugc3BlY2lmaWMgc3R1ZmYuIE92ZXJ3cml0aW5nIHRoZW0gd29uJ3QgYnJlYWsgdGhlIHVwbG9hZFxuICAgICAgICAgYnV0IGNhbiBicmVhayB0aGUgd2F5IGl0J3MgZGlzcGxheWVkLlxuICAgICAgICAgWW91IGNhbiBvdmVyd3JpdGUgdGhlbSBpZiB5b3UgZG9uJ3QgbGlrZSB0aGUgZGVmYXVsdCBiZWhhdmlvci4gSWYgeW91IGp1c3RcbiAgICAgICAgIHdhbnQgdG8gYWRkIGFuIGFkZGl0aW9uYWwgZXZlbnQgaGFuZGxlciwgcmVnaXN0ZXIgaXQgb24gdGhlIGRyb3B6b25lIG9iamVjdFxuICAgICAgICAgYW5kIGRvbid0IG92ZXJ3cml0ZSB0aG9zZSBvcHRpb25zLlxuICAgICAgICAgKi9cblxuICAgICAgICAvLyBUaG9zZSBhcmUgc2VsZiBleHBsYW5hdG9yeSBhbmQgc2ltcGx5IGNvbmNlcm4gdGhlIERyYWduRHJvcC5cbiAgICAgICAgZHJvcDogZnVuY3Rpb24gZHJvcChlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotZHJhZy1ob3ZlclwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ3N0YXJ0OiBmdW5jdGlvbiBkcmFnc3RhcnQoZSkge30sXG4gICAgICAgIGRyYWdlbmQ6IGZ1bmN0aW9uIGRyYWdlbmQoZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LWRyYWctaG92ZXJcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbnRlcjogZnVuY3Rpb24gZHJhZ2VudGVyKGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1kcmFnLWhvdmVyXCIpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnb3ZlcjogZnVuY3Rpb24gZHJhZ292ZXIoZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LWRyYWctaG92ZXJcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdsZWF2ZTogZnVuY3Rpb24gZHJhZ2xlYXZlKGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkei1kcmFnLWhvdmVyXCIpO1xuICAgICAgICB9LFxuICAgICAgICBwYXN0ZTogZnVuY3Rpb24gcGFzdGUoZSkge30sXG5cblxuICAgICAgICAvLyBDYWxsZWQgd2hlbmV2ZXIgdGhlcmUgYXJlIG5vIGZpbGVzIGxlZnQgaW4gdGhlIGRyb3B6b25lIGFueW1vcmUsIGFuZCB0aGVcbiAgICAgICAgLy8gZHJvcHpvbmUgc2hvdWxkIGJlIGRpc3BsYXllZCBhcyBpZiBpbiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImR6LXN0YXJ0ZWRcIik7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvLyBDYWxsZWQgd2hlbiBhIGZpbGUgaXMgYWRkZWQgdG8gdGhlIHF1ZXVlXG4gICAgICAgIC8vIFJlY2VpdmVzIGBmaWxlYFxuICAgICAgICBhZGRlZGZpbGU6IGZ1bmN0aW9uIGFkZGVkZmlsZShmaWxlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBpZiAodGhpcy5lbGVtZW50ID09PSB0aGlzLnByZXZpZXdzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImR6LXN0YXJ0ZWRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMucHJldmlld3NDb250YWluZXIpIHtcbiAgICAgICAgICAgIGZpbGUucHJldmlld0VsZW1lbnQgPSBEcm9wem9uZS5jcmVhdGVFbGVtZW50KHRoaXMub3B0aW9ucy5wcmV2aWV3VGVtcGxhdGUudHJpbSgpKTtcbiAgICAgICAgICAgIGZpbGUucHJldmlld1RlbXBsYXRlID0gZmlsZS5wcmV2aWV3RWxlbWVudDsgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICAgICAgICAgICAgdGhpcy5wcmV2aWV3c0NvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxlLnByZXZpZXdFbGVtZW50KTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1kei1uYW1lXVwiKSwgX2lzQXJyYXkzID0gdHJ1ZSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfaTMgPSBfaXRlcmF0b3IzLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2kzLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgIF9yZWYzID0gX2kzLnZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBfcmVmMztcblxuICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gZmlsZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LXNpemVdXCIpLCBfaXNBcnJheTQgPSB0cnVlLCBfaTQgPSAwLCBfaXRlcmF0b3I0ID0gX2lzQXJyYXk0ID8gX2l0ZXJhdG9yNCA6IF9pdGVyYXRvcjRbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICAgICAgaWYgKF9pc0FycmF5NCkge1xuICAgICAgICAgICAgICAgIGlmIChfaTQgPj0gX2l0ZXJhdG9yNC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBfaXRlcmF0b3I0W19pNCsrXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfaTQgPSBfaXRlcmF0b3I0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2k0LmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBfaTQudmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IHRoaXMuZmlsZXNpemUoZmlsZS5zaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRSZW1vdmVMaW5rcykge1xuICAgICAgICAgICAgICBmaWxlLl9yZW1vdmVMaW5rID0gRHJvcHpvbmUuY3JlYXRlRWxlbWVudChcIjxhIGNsYXNzPVxcXCJkei1yZW1vdmVcXFwiIGhyZWY9XFxcImphdmFzY3JpcHQ6dW5kZWZpbmVkO1xcXCIgZGF0YS1kei1yZW1vdmU+XCIgKyB0aGlzLm9wdGlvbnMuZGljdFJlbW92ZUZpbGUgKyBcIjwvYT5cIik7XG4gICAgICAgICAgICAgIGZpbGUucHJldmlld0VsZW1lbnQuYXBwZW5kQ2hpbGQoZmlsZS5fcmVtb3ZlTGluayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZW1vdmVGaWxlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVGaWxlRXZlbnQoZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIGlmIChmaWxlLnN0YXR1cyA9PT0gRHJvcHpvbmUuVVBMT0FESU5HKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERyb3B6b25lLmNvbmZpcm0oX3RoaXMyLm9wdGlvbnMuZGljdENhbmNlbFVwbG9hZENvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5yZW1vdmVGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5kaWN0UmVtb3ZlRmlsZUNvbmZpcm1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIERyb3B6b25lLmNvbmZpcm0oX3RoaXMyLm9wdGlvbnMuZGljdFJlbW92ZUZpbGVDb25maXJtYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5yZW1vdmVGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIucmVtb3ZlRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1kei1yZW1vdmVdXCIpLCBfaXNBcnJheTUgPSB0cnVlLCBfaTUgPSAwLCBfaXRlcmF0b3I1ID0gX2lzQXJyYXk1ID8gX2l0ZXJhdG9yNSA6IF9pdGVyYXRvcjVbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWY0O1xuXG4gICAgICAgICAgICAgIGlmIChfaXNBcnJheTUpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2k1ID49IF9pdGVyYXRvcjUubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICBfcmVmNCA9IF9pdGVyYXRvcjVbX2k1KytdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9pNSA9IF9pdGVyYXRvcjUubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChfaTUuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgX3JlZjQgPSBfaTUudmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmVtb3ZlTGluayA9IF9yZWY0O1xuXG4gICAgICAgICAgICAgIHJlbW92ZUxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHJlbW92ZUZpbGVFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLy8gQ2FsbGVkIHdoZW5ldmVyIGEgZmlsZSBpcyByZW1vdmVkLlxuICAgICAgICByZW1vdmVkZmlsZTogZnVuY3Rpb24gcmVtb3ZlZGZpbGUoZmlsZSkge1xuICAgICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50ICE9IG51bGwgJiYgZmlsZS5wcmV2aWV3RWxlbWVudC5wYXJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZpbGUucHJldmlld0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmaWxlLnByZXZpZXdFbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1heEZpbGVzUmVhY2hlZENsYXNzKCk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvLyBDYWxsZWQgd2hlbiBhIHRodW1ibmFpbCBoYXMgYmVlbiBnZW5lcmF0ZWRcbiAgICAgICAgLy8gUmVjZWl2ZXMgYGZpbGVgIGFuZCBgZGF0YVVybGBcbiAgICAgICAgdGh1bWJuYWlsOiBmdW5jdGlvbiB0aHVtYm5haWwoZmlsZSwgZGF0YVVybCkge1xuICAgICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSB7XG4gICAgICAgICAgICBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkei1maWxlLXByZXZpZXdcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gZmlsZS5wcmV2aWV3RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtZHotdGh1bWJuYWlsXVwiKSwgX2lzQXJyYXk2ID0gdHJ1ZSwgX2k2ID0gMCwgX2l0ZXJhdG9yNiA9IF9pc0FycmF5NiA/IF9pdGVyYXRvcjYgOiBfaXRlcmF0b3I2W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmNTtcblxuICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk2KSB7XG4gICAgICAgICAgICAgICAgaWYgKF9pNiA+PSBfaXRlcmF0b3I2Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgX3JlZjUgPSBfaXRlcmF0b3I2W19pNisrXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfaTYgPSBfaXRlcmF0b3I2Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2k2LmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgIF9yZWY1ID0gX2k2LnZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHRodW1ibmFpbEVsZW1lbnQgPSBfcmVmNTtcblxuICAgICAgICAgICAgICB0aHVtYm5haWxFbGVtZW50LmFsdCA9IGZpbGUubmFtZTtcbiAgICAgICAgICAgICAgdGh1bWJuYWlsRWxlbWVudC5zcmMgPSBkYXRhVXJsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1pbWFnZS1wcmV2aWV3XCIpO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLy8gQ2FsbGVkIHdoZW5ldmVyIGFuIGVycm9yIG9jY3Vyc1xuICAgICAgICAvLyBSZWNlaXZlcyBgZmlsZWAgYW5kIGBtZXNzYWdlYFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoZmlsZSwgbWVzc2FnZSkge1xuICAgICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSB7XG4gICAgICAgICAgICBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1lcnJvclwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJTdHJpbmdcIiAmJiBtZXNzYWdlLmVycm9yKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNyA9IGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LWVycm9ybWVzc2FnZV1cIiksIF9pc0FycmF5NyA9IHRydWUsIF9pNyA9IDAsIF9pdGVyYXRvcjcgPSBfaXNBcnJheTcgPyBfaXRlcmF0b3I3IDogX2l0ZXJhdG9yN1tTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgICAgICB2YXIgX3JlZjY7XG5cbiAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Nykge1xuICAgICAgICAgICAgICAgIGlmIChfaTcgPj0gX2l0ZXJhdG9yNy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgIF9yZWY2ID0gX2l0ZXJhdG9yN1tfaTcrK107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2k3ID0gX2l0ZXJhdG9yNy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKF9pNy5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICBfcmVmNiA9IF9pNy52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBub2RlID0gX3JlZjY7XG5cbiAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcm11bHRpcGxlOiBmdW5jdGlvbiBlcnJvcm11bHRpcGxlKCkge30sXG5cblxuICAgICAgICAvLyBDYWxsZWQgd2hlbiBhIGZpbGUgZ2V0cyBwcm9jZXNzZWQuIFNpbmNlIHRoZXJlIGlzIGEgY3VlLCBub3QgYWxsIGFkZGVkXG4gICAgICAgIC8vIGZpbGVzIGFyZSBwcm9jZXNzZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIFJlY2VpdmVzIGBmaWxlYFxuICAgICAgICBwcm9jZXNzaW5nOiBmdW5jdGlvbiBwcm9jZXNzaW5nKGZpbGUpIHtcbiAgICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkge1xuICAgICAgICAgICAgZmlsZS5wcmV2aWV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotcHJvY2Vzc2luZ1wiKTtcbiAgICAgICAgICAgIGlmIChmaWxlLl9yZW1vdmVMaW5rKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaWxlLl9yZW1vdmVMaW5rLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5kaWN0Q2FuY2VsVXBsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc2luZ211bHRpcGxlOiBmdW5jdGlvbiBwcm9jZXNzaW5nbXVsdGlwbGUoKSB7fSxcblxuXG4gICAgICAgIC8vIENhbGxlZCB3aGVuZXZlciB0aGUgdXBsb2FkIHByb2dyZXNzIGdldHMgdXBkYXRlZC5cbiAgICAgICAgLy8gUmVjZWl2ZXMgYGZpbGVgLCBgcHJvZ3Jlc3NgIChwZXJjZW50YWdlIDAtMTAwKSBhbmQgYGJ5dGVzU2VudGAuXG4gICAgICAgIC8vIFRvIGdldCB0aGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG9mIHRoZSBmaWxlLCB1c2UgYGZpbGUuc2l6ZWBcbiAgICAgICAgdXBsb2FkcHJvZ3Jlc3M6IGZ1bmN0aW9uIHVwbG9hZHByb2dyZXNzKGZpbGUsIHByb2dyZXNzLCBieXRlc1NlbnQpIHtcbiAgICAgICAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yOCA9IGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWR6LXVwbG9hZHByb2dyZXNzXVwiKSwgX2lzQXJyYXk4ID0gdHJ1ZSwgX2k4ID0gMCwgX2l0ZXJhdG9yOCA9IF9pc0FycmF5OCA/IF9pdGVyYXRvcjggOiBfaXRlcmF0b3I4W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmNztcblxuICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk4KSB7XG4gICAgICAgICAgICAgICAgaWYgKF9pOCA+PSBfaXRlcmF0b3I4Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgX3JlZjcgPSBfaXRlcmF0b3I4W19pOCsrXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfaTggPSBfaXRlcmF0b3I4Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2k4LmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgIF9yZWY3ID0gX2k4LnZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBfcmVmNztcblxuICAgICAgICAgICAgICBub2RlLm5vZGVOYW1lID09PSAnUFJPR1JFU1MnID8gbm9kZS52YWx1ZSA9IHByb2dyZXNzIDogbm9kZS5zdHlsZS53aWR0aCA9IHByb2dyZXNzICsgXCIlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG5cbiAgICAgICAgLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSB0b3RhbCB1cGxvYWQgcHJvZ3Jlc3MgZ2V0cyB1cGRhdGVkLlxuICAgICAgICAvLyBDYWxsZWQgd2l0aCB0b3RhbFVwbG9hZFByb2dyZXNzICgwLTEwMCksIHRvdGFsQnl0ZXMgYW5kIHRvdGFsQnl0ZXNTZW50XG4gICAgICAgIHRvdGFsdXBsb2FkcHJvZ3Jlc3M6IGZ1bmN0aW9uIHRvdGFsdXBsb2FkcHJvZ3Jlc3MoKSB7fSxcblxuXG4gICAgICAgIC8vIENhbGxlZCBqdXN0IGJlZm9yZSB0aGUgZmlsZSBpcyBzZW50LiBHZXRzIHRoZSBgeGhyYCBvYmplY3QgYXMgc2Vjb25kXG4gICAgICAgIC8vIHBhcmFtZXRlciwgc28geW91IGNhbiBtb2RpZnkgaXQgKGZvciBleGFtcGxlIHRvIGFkZCBhIENTUkYgdG9rZW4pIGFuZCBhXG4gICAgICAgIC8vIGBmb3JtRGF0YWAgb2JqZWN0IHRvIGFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICAgICAgICBzZW5kaW5nOiBmdW5jdGlvbiBzZW5kaW5nKCkge30sXG4gICAgICAgIHNlbmRpbmdtdWx0aXBsZTogZnVuY3Rpb24gc2VuZGluZ211bHRpcGxlKCkge30sXG5cblxuICAgICAgICAvLyBXaGVuIHRoZSBjb21wbGV0ZSB1cGxvYWQgaXMgZmluaXNoZWQgYW5kIHN1Y2Nlc3NmdWxcbiAgICAgICAgLy8gUmVjZWl2ZXMgYGZpbGVgXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoZmlsZSkge1xuICAgICAgICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZS5wcmV2aWV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotc3VjY2Vzc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN1Y2Nlc3NtdWx0aXBsZTogZnVuY3Rpb24gc3VjY2Vzc211bHRpcGxlKCkge30sXG5cblxuICAgICAgICAvLyBXaGVuIHRoZSB1cGxvYWQgaXMgY2FuY2VsZWQuXG4gICAgICAgIGNhbmNlbGVkOiBmdW5jdGlvbiBjYW5jZWxlZChmaWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImVycm9yXCIsIGZpbGUsIHRoaXMub3B0aW9ucy5kaWN0VXBsb2FkQ2FuY2VsZWQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWxlZG11bHRpcGxlOiBmdW5jdGlvbiBjYW5jZWxlZG11bHRpcGxlKCkge30sXG5cblxuICAgICAgICAvLyBXaGVuIHRoZSB1cGxvYWQgaXMgZmluaXNoZWQsIGVpdGhlciB3aXRoIHN1Y2Nlc3Mgb3IgYW4gZXJyb3IuXG4gICAgICAgIC8vIFJlY2VpdmVzIGBmaWxlYFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUoZmlsZSkge1xuICAgICAgICAgIGlmIChmaWxlLl9yZW1vdmVMaW5rKSB7XG4gICAgICAgICAgICBmaWxlLl9yZW1vdmVMaW5rLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5kaWN0UmVtb3ZlRmlsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpbGUucHJldmlld0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkei1jb21wbGV0ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlbXVsdGlwbGU6IGZ1bmN0aW9uIGNvbXBsZXRlbXVsdGlwbGUoKSB7fSxcbiAgICAgICAgbWF4ZmlsZXNleGNlZWRlZDogZnVuY3Rpb24gbWF4ZmlsZXNleGNlZWRlZCgpIHt9LFxuICAgICAgICBtYXhmaWxlc3JlYWNoZWQ6IGZ1bmN0aW9uIG1heGZpbGVzcmVhY2hlZCgpIHt9LFxuICAgICAgICBxdWV1ZWNvbXBsZXRlOiBmdW5jdGlvbiBxdWV1ZWNvbXBsZXRlKCkge30sXG4gICAgICAgIGFkZGVkZmlsZXM6IGZ1bmN0aW9uIGFkZGVkZmlsZXMoKSB7fVxuICAgICAgfTtcblxuICAgICAgdGhpcy5wcm90b3R5cGUuX3RodW1ibmFpbFF1ZXVlID0gW107XG4gICAgICB0aGlzLnByb3RvdHlwZS5fcHJvY2Vzc2luZ1RodW1ibmFpbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGdsb2JhbCB1dGlsaXR5XG5cbiAgfSwge1xuICAgIGtleTogXCJleHRlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBvYmplY3RzID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBvYmplY3RzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3I5ID0gb2JqZWN0cywgX2lzQXJyYXk5ID0gdHJ1ZSwgX2k5ID0gMCwgX2l0ZXJhdG9yOSA9IF9pc0FycmF5OSA/IF9pdGVyYXRvcjkgOiBfaXRlcmF0b3I5W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgIHZhciBfcmVmODtcblxuICAgICAgICBpZiAoX2lzQXJyYXk5KSB7XG4gICAgICAgICAgaWYgKF9pOSA+PSBfaXRlcmF0b3I5Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjggPSBfaXRlcmF0b3I5W19pOSsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTkgPSBfaXRlcmF0b3I5Lm5leHQoKTtcbiAgICAgICAgICBpZiAoX2k5LmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWY4ID0gX2k5LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9iamVjdCA9IF9yZWY4O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICB2YXIgdmFsID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gRHJvcHpvbmUoZWwsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcHpvbmUpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERyb3B6b25lLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHJvcHpvbmUpKS5jYWxsKHRoaXMpKTtcblxuICAgIHZhciBmYWxsYmFjayA9IHZvaWQgMCxcbiAgICAgICAgbGVmdCA9IHZvaWQgMDtcbiAgICBfdGhpcy5lbGVtZW50ID0gZWw7XG4gICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHNpbmNlIHRoZSB2ZXJzaW9uIHdhcyBpbiB0aGUgcHJvdG90eXBlIHByZXZpb3VzbHlcbiAgICBfdGhpcy52ZXJzaW9uID0gRHJvcHpvbmUudmVyc2lvbjtcblxuICAgIF90aGlzLmRlZmF1bHRPcHRpb25zLnByZXZpZXdUZW1wbGF0ZSA9IF90aGlzLmRlZmF1bHRPcHRpb25zLnByZXZpZXdUZW1wbGF0ZS5yZXBsYWNlKC9cXG4qL2csIFwiXCIpO1xuXG4gICAgX3RoaXMuY2xpY2thYmxlRWxlbWVudHMgPSBbXTtcbiAgICBfdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICBfdGhpcy5maWxlcyA9IFtdOyAvLyBBbGwgZmlsZXNcblxuICAgIGlmICh0eXBlb2YgX3RoaXMuZWxlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgX3RoaXMuZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMuZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gTm90IGNoZWNraW5nIGlmIGluc3RhbmNlIG9mIEhUTUxFbGVtZW50IG9yIEVsZW1lbnQgc2luY2UgSUU5IGlzIGV4dHJlbWVseSB3ZWlyZC5cbiAgICBpZiAoIV90aGlzLmVsZW1lbnQgfHwgX3RoaXMuZWxlbWVudC5ub2RlVHlwZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRyb3B6b25lIGVsZW1lbnQuXCIpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5lbGVtZW50LmRyb3B6b25lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEcm9wem9uZSBhbHJlYWR5IGF0dGFjaGVkLlwiKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgYWRkIHRoaXMgZHJvcHpvbmUgdG8gdGhlIGluc3RhbmNlcy5cbiAgICBEcm9wem9uZS5pbnN0YW5jZXMucHVzaChfdGhpcyk7XG5cbiAgICAvLyBQdXQgdGhlIGRyb3B6b25lIGluc2lkZSB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgX3RoaXMuZWxlbWVudC5kcm9wem9uZSA9IF90aGlzO1xuXG4gICAgdmFyIGVsZW1lbnRPcHRpb25zID0gKGxlZnQgPSBEcm9wem9uZS5vcHRpb25zRm9yRWxlbWVudChfdGhpcy5lbGVtZW50KSkgIT0gbnVsbCA/IGxlZnQgOiB7fTtcblxuICAgIF90aGlzLm9wdGlvbnMgPSBEcm9wem9uZS5leHRlbmQoe30sIF90aGlzLmRlZmF1bHRPcHRpb25zLCBlbGVtZW50T3B0aW9ucywgb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9KTtcblxuICAgIC8vIElmIHRoZSBicm93c2VyIGZhaWxlZCwganVzdCBjYWxsIHRoZSBmYWxsYmFjayBhbmQgbGVhdmVcbiAgICBpZiAoX3RoaXMub3B0aW9ucy5mb3JjZUZhbGxiYWNrIHx8ICFEcm9wem9uZS5pc0Jyb3dzZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgIHJldHVybiBfcmV0ID0gX3RoaXMub3B0aW9ucy5mYWxsYmFjay5jYWxsKF90aGlzKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICAgIH1cblxuICAgIC8vIEBvcHRpb25zLnVybCA9IEBlbGVtZW50LmdldEF0dHJpYnV0ZSBcImFjdGlvblwiIHVubGVzcyBAb3B0aW9ucy51cmw/XG4gICAgaWYgKF90aGlzLm9wdGlvbnMudXJsID09IG51bGwpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMudXJsID0gX3RoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKCFfdGhpcy5vcHRpb25zLnVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gVVJMIHByb3ZpZGVkLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMub3B0aW9ucy5hY2NlcHRlZEZpbGVzICYmIF90aGlzLm9wdGlvbnMuYWNjZXB0ZWRNaW1lVHlwZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4ndCBwcm92aWRlIGJvdGggJ2FjY2VwdGVkRmlsZXMnIGFuZCAnYWNjZXB0ZWRNaW1lVHlwZXMnLiAnYWNjZXB0ZWRNaW1lVHlwZXMnIGlzIGRlcHJlY2F0ZWQuXCIpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlICYmIF90aGlzLm9wdGlvbnMuY2h1bmtpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBzZXQgYm90aDogdXBsb2FkTXVsdGlwbGUgYW5kIGNodW5raW5nLicpO1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKF90aGlzLm9wdGlvbnMuYWNjZXB0ZWRNaW1lVHlwZXMpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMuYWNjZXB0ZWRGaWxlcyA9IF90aGlzLm9wdGlvbnMuYWNjZXB0ZWRNaW1lVHlwZXM7XG4gICAgICBkZWxldGUgX3RoaXMub3B0aW9ucy5hY2NlcHRlZE1pbWVUeXBlcztcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChfdGhpcy5vcHRpb25zLnJlbmFtZUZpbGVuYW1lICE9IG51bGwpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMucmVuYW1lRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vcHRpb25zLnJlbmFtZUZpbGVuYW1lLmNhbGwoX3RoaXMsIGZpbGUubmFtZSwgZmlsZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIF90aGlzLm9wdGlvbnMubWV0aG9kID0gX3RoaXMub3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKTtcblxuICAgIGlmICgoZmFsbGJhY2sgPSBfdGhpcy5nZXRFeGlzdGluZ0ZhbGxiYWNrKCkpICYmIGZhbGxiYWNrLnBhcmVudE5vZGUpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgZmFsbGJhY2tcbiAgICAgIGZhbGxiYWNrLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZmFsbGJhY2spO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXkgcHJldmlld3MgaW4gdGhlIHByZXZpZXdzQ29udGFpbmVyIGVsZW1lbnQgb3IgdGhlIERyb3B6b25lIGVsZW1lbnQgdW5sZXNzIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlXG4gICAgaWYgKF90aGlzLm9wdGlvbnMucHJldmlld3NDb250YWluZXIgIT09IGZhbHNlKSB7XG4gICAgICBpZiAoX3RoaXMub3B0aW9ucy5wcmV2aWV3c0NvbnRhaW5lcikge1xuICAgICAgICBfdGhpcy5wcmV2aWV3c0NvbnRhaW5lciA9IERyb3B6b25lLmdldEVsZW1lbnQoX3RoaXMub3B0aW9ucy5wcmV2aWV3c0NvbnRhaW5lciwgXCJwcmV2aWV3c0NvbnRhaW5lclwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnByZXZpZXdzQ29udGFpbmVyID0gX3RoaXMuZWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3RoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsaWNrYWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICBfdGhpcy5jbGlja2FibGVFbGVtZW50cyA9IFtfdGhpcy5lbGVtZW50XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLmNsaWNrYWJsZUVsZW1lbnRzID0gRHJvcHpvbmUuZ2V0RWxlbWVudHMoX3RoaXMub3B0aW9ucy5jbGlja2FibGUsIFwiY2xpY2thYmxlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLmluaXQoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvLyBSZXR1cm5zIGFsbCBmaWxlcyB0aGF0IGhhdmUgYmVlbiBhY2NlcHRlZFxuXG5cbiAgX2NyZWF0ZUNsYXNzKERyb3B6b25lLCBbe1xuICAgIGtleTogXCJnZXRBY2NlcHRlZEZpbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjY2VwdGVkRmlsZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxlcy5maWx0ZXIoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGUuYWNjZXB0ZWQ7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGFsbCBmaWxlcyB0aGF0IGhhdmUgYmVlbiByZWplY3RlZFxuICAgIC8vIE5vdCBzdXJlIHdoZW4gdGhhdCdzIGdvaW5nIHRvIGJlIHVzZWZ1bCwgYnV0IGFkZGVkIGZvciBjb21wbGV0ZW5lc3MuXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZWplY3RlZEZpbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlamVjdGVkRmlsZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxlcy5maWx0ZXIoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuICFmaWxlLmFjY2VwdGVkO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpbGVzV2l0aFN0YXR1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWxlc1dpdGhTdGF0dXMoc3RhdHVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxlcy5maWx0ZXIoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGUuc3RhdHVzID09PSBzdGF0dXM7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGFsbCBmaWxlcyB0aGF0IGFyZSBpbiB0aGUgcXVldWVcblxuICB9LCB7XG4gICAga2V5OiBcImdldFF1ZXVlZEZpbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFF1ZXVlZEZpbGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKERyb3B6b25lLlFVRVVFRCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVwbG9hZGluZ0ZpbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVwbG9hZGluZ0ZpbGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKERyb3B6b25lLlVQTE9BRElORyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFkZGVkRmlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWRkZWRGaWxlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZpbGVzV2l0aFN0YXR1cyhEcm9wem9uZS5BRERFRCk7XG4gICAgfVxuXG4gICAgLy8gRmlsZXMgdGhhdCBhcmUgZWl0aGVyIHF1ZXVlZCBvciB1cGxvYWRpbmdcblxuICB9LCB7XG4gICAga2V5OiBcImdldEFjdGl2ZUZpbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjdGl2ZUZpbGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHJldHVybiBmaWxlLnN0YXR1cyA9PT0gRHJvcHpvbmUuVVBMT0FESU5HIHx8IGZpbGUuc3RhdHVzID09PSBEcm9wem9uZS5RVUVVRUQ7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIERyb3B6b25lIGlzIGluaXRpYWxpemVkLiBZb3VcbiAgICAvLyBjYW4gKGFuZCBzaG91bGQpIHNldHVwIGV2ZW50IGxpc3RlbmVycyBpbnNpZGUgdGhpcyBmdW5jdGlvbi5cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyBJbiBjYXNlIGl0IGlzbid0IHNldCBhbHJlYWR5XG4gICAgICBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgPT09IFwiZm9ybVwiKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJkcm9wem9uZVwiKSAmJiAhdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZHotbWVzc2FnZVwiKSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoRHJvcHpvbmUuY3JlYXRlRWxlbWVudChcIjxkaXYgY2xhc3M9XFxcImR6LWRlZmF1bHQgZHotbWVzc2FnZVxcXCI+PHNwYW4+XCIgKyB0aGlzLm9wdGlvbnMuZGljdERlZmF1bHRNZXNzYWdlICsgXCI8L3NwYW4+PC9kaXY+XCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xpY2thYmxlRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBzZXR1cEhpZGRlbkZpbGVJbnB1dCA9IGZ1bmN0aW9uIHNldHVwSGlkZGVuRmlsZUlucHV0KCkge1xuICAgICAgICAgIGlmIChfdGhpczMuaGlkZGVuRmlsZUlucHV0KSB7XG4gICAgICAgICAgICBfdGhpczMuaGlkZGVuRmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX3RoaXMzLmhpZGRlbkZpbGVJbnB1dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzMy5oaWRkZW5GaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiZmlsZVwiKTtcbiAgICAgICAgICBpZiAoX3RoaXMzLm9wdGlvbnMubWF4RmlsZXMgPT09IG51bGwgfHwgX3RoaXMzLm9wdGlvbnMubWF4RmlsZXMgPiAxKSB7XG4gICAgICAgICAgICBfdGhpczMuaGlkZGVuRmlsZUlucHV0LnNldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIsIFwibXVsdGlwbGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzMy5oaWRkZW5GaWxlSW5wdXQuY2xhc3NOYW1lID0gXCJkei1oaWRkZW4taW5wdXRcIjtcblxuICAgICAgICAgIGlmIChfdGhpczMub3B0aW9ucy5hY2NlcHRlZEZpbGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpczMuaGlkZGVuRmlsZUlucHV0LnNldEF0dHJpYnV0ZShcImFjY2VwdFwiLCBfdGhpczMub3B0aW9ucy5hY2NlcHRlZEZpbGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzMy5vcHRpb25zLmNhcHR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzMy5oaWRkZW5GaWxlSW5wdXQuc2V0QXR0cmlidXRlKFwiY2FwdHVyZVwiLCBfdGhpczMub3B0aW9ucy5jYXB0dXJlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOb3Qgc2V0dGluZyBgZGlzcGxheT1cIm5vbmVcImAgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGRvbid0IGFjY2VwdCBjbGlja3NcbiAgICAgICAgICAvLyBvbiBlbGVtZW50cyB0aGF0IGFyZW4ndCBkaXNwbGF5ZWQuXG4gICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICBfdGhpczMuaGlkZGVuRmlsZUlucHV0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgIF90aGlzMy5oaWRkZW5GaWxlSW5wdXQuc3R5bGUudG9wID0gXCIwXCI7XG4gICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcbiAgICAgICAgICBfdGhpczMuaGlkZGVuRmlsZUlucHV0LnN0eWxlLndpZHRoID0gXCIwXCI7XG4gICAgICAgICAgRHJvcHpvbmUuZ2V0RWxlbWVudChfdGhpczMub3B0aW9ucy5oaWRkZW5JbnB1dENvbnRhaW5lciwgJ2hpZGRlbklucHV0Q29udGFpbmVyJykuYXBwZW5kQ2hpbGQoX3RoaXMzLmhpZGRlbkZpbGVJbnB1dCk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5oaWRkZW5GaWxlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmlsZXMgPSBfdGhpczMuaGlkZGVuRmlsZUlucHV0LmZpbGVzO1xuXG4gICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEwID0gZmlsZXMsIF9pc0FycmF5MTAgPSB0cnVlLCBfaTEwID0gMCwgX2l0ZXJhdG9yMTAgPSBfaXNBcnJheTEwID8gX2l0ZXJhdG9yMTAgOiBfaXRlcmF0b3IxMFtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgICAgICAgIHZhciBfcmVmOTtcblxuICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTEwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX2kxMCA+PSBfaXRlcmF0b3IxMC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgX3JlZjkgPSBfaXRlcmF0b3IxMFtfaTEwKytdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBfaTEwID0gX2l0ZXJhdG9yMTAubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKF9pMTAuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBfcmVmOSA9IF9pMTAudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGZpbGUgPSBfcmVmOTtcblxuICAgICAgICAgICAgICAgIF90aGlzMy5hZGRGaWxlKGZpbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpczMuZW1pdChcImFkZGVkZmlsZXNcIiwgZmlsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHNldHVwSGlkZGVuRmlsZUlucHV0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHNldHVwSGlkZGVuRmlsZUlucHV0KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuVVJMID0gd2luZG93LlVSTCAhPT0gbnVsbCA/IHdpbmRvdy5VUkwgOiB3aW5kb3cud2Via2l0VVJMO1xuXG4gICAgICAvLyBTZXR1cCBhbGwgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBEcm9wem9uZSBvYmplY3QgaXRzZWxmLlxuICAgICAgLy8gVGhleSdyZSBub3QgaW4gQHNldHVwRXZlbnRMaXN0ZW5lcnMoKSBiZWNhdXNlIHRoZXkgc2hvdWxkbid0IGJlIHJlbW92ZWRcbiAgICAgIC8vIGFnYWluIHdoZW4gdGhlIGRyb3B6b25lIGdldHMgZGlzYWJsZWQuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMSA9IHRoaXMuZXZlbnRzLCBfaXNBcnJheTExID0gdHJ1ZSwgX2kxMSA9IDAsIF9pdGVyYXRvcjExID0gX2lzQXJyYXkxMSA/IF9pdGVyYXRvcjExIDogX2l0ZXJhdG9yMTFbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgdmFyIF9yZWYxMDtcblxuICAgICAgICBpZiAoX2lzQXJyYXkxMSkge1xuICAgICAgICAgIGlmIChfaTExID49IF9pdGVyYXRvcjExLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjEwID0gX2l0ZXJhdG9yMTFbX2kxMSsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTExID0gX2l0ZXJhdG9yMTEubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTExLmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYxMCA9IF9pMTEudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZlbnROYW1lID0gX3JlZjEwO1xuXG4gICAgICAgIHRoaXMub24oZXZlbnROYW1lLCB0aGlzLm9wdGlvbnNbZXZlbnROYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub24oXCJ1cGxvYWRwcm9ncmVzc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMudXBkYXRlVG90YWxVcGxvYWRQcm9ncmVzcygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMub24oXCJyZW1vdmVkZmlsZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMudXBkYXRlVG90YWxVcGxvYWRQcm9ncmVzcygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMub24oXCJjYW5jZWxlZFwiLCBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLmVtaXQoXCJjb21wbGV0ZVwiLCBmaWxlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFbWl0IGEgYHF1ZXVlY29tcGxldGVgIGV2ZW50IGlmIGFsbCBmaWxlcyBmaW5pc2hlZCB1cGxvYWRpbmcuXG4gICAgICB0aGlzLm9uKFwiY29tcGxldGVcIiwgZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgaWYgKF90aGlzMy5nZXRBZGRlZEZpbGVzKCkubGVuZ3RoID09PSAwICYmIF90aGlzMy5nZXRVcGxvYWRpbmdGaWxlcygpLmxlbmd0aCA9PT0gMCAmJiBfdGhpczMuZ2V0UXVldWVkRmlsZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlZmVycmVkIHNvIHRoYXQgYHF1ZXVlY29tcGxldGVgIHJlYWxseSB0cmlnZ2VycyBhZnRlciBgY29tcGxldGVgXG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5lbWl0KFwicXVldWVjb21wbGV0ZVwiKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBub1Byb3BhZ2F0aW9uID0gZnVuY3Rpb24gbm9Qcm9wYWdhdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIGxpc3RlbmVyc1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbe1xuICAgICAgICBlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIFwiZHJhZ3N0YXJ0XCI6IGZ1bmN0aW9uIGRyYWdzdGFydChlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmVtaXQoXCJkcmFnc3RhcnRcIiwgZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRyYWdlbnRlclwiOiBmdW5jdGlvbiBkcmFnZW50ZXIoZSkge1xuICAgICAgICAgICAgbm9Qcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuZW1pdChcImRyYWdlbnRlclwiLCBlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZHJhZ292ZXJcIjogZnVuY3Rpb24gZHJhZ292ZXIoZSkge1xuICAgICAgICAgICAgLy8gTWFrZXMgaXQgcG9zc2libGUgdG8gZHJhZyBmaWxlcyBmcm9tIGNocm9tZSdzIGRvd25sb2FkIGJhclxuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTUyNjQzMC9kcmFnLWFuZC1kcm9wLWZpbGUtdXBsb2Fkcy1mcm9tLWNocm9tZS1kb3dubG9hZHMtYmFyXG4gICAgICAgICAgICAvLyBUcnkgaXMgcmVxdWlyZWQgdG8gcHJldmVudCBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTEgKFNDUklQVDY1NTM1IGV4Y2VwdGlvbilcbiAgICAgICAgICAgIHZhciBlZmN0ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZWZjdCA9IGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZScgPT09IGVmY3QgfHwgJ2xpbmtNb3ZlJyA9PT0gZWZjdCA/ICdtb3ZlJyA6ICdjb3B5JztcblxuICAgICAgICAgICAgbm9Qcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuZW1pdChcImRyYWdvdmVyXCIsIGUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkcmFnbGVhdmVcIjogZnVuY3Rpb24gZHJhZ2xlYXZlKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuZW1pdChcImRyYWdsZWF2ZVwiLCBlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZHJvcFwiOiBmdW5jdGlvbiBkcm9wKGUpIHtcbiAgICAgICAgICAgIG5vUHJvcGFnYXRpb24oZSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmRyb3AoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRyYWdlbmRcIjogZnVuY3Rpb24gZHJhZ2VuZChlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmVtaXQoXCJkcmFnZW5kXCIsIGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoaXMgaXMgZGlzYWJsZWQgcmlnaHQgbm93LCBiZWNhdXNlIHRoZSBicm93c2VycyBkb24ndCBpbXBsZW1lbnQgaXQgcHJvcGVybHkuXG4gICAgICAgICAgLy8gXCJwYXN0ZVwiOiAoZSkgPT5cbiAgICAgICAgICAvLyAgIG5vUHJvcGFnYXRpb24gZVxuICAgICAgICAgIC8vICAgQHBhc3RlIGVcbiAgICAgICAgfSB9XTtcblxuICAgICAgdGhpcy5jbGlja2FibGVFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjbGlja2FibGVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczMubGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGNsaWNrYWJsZUVsZW1lbnQsXG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uIGNsaWNrKGV2dCkge1xuICAgICAgICAgICAgICAvLyBPbmx5IHRoZSBhY3R1YWwgZHJvcHpvbmUgb3IgdGhlIG1lc3NhZ2UgZWxlbWVudCBzaG91bGQgdHJpZ2dlciBmaWxlIHNlbGVjdGlvblxuICAgICAgICAgICAgICBpZiAoY2xpY2thYmxlRWxlbWVudCAhPT0gX3RoaXMzLmVsZW1lbnQgfHwgZXZ0LnRhcmdldCA9PT0gX3RoaXMzLmVsZW1lbnQgfHwgRHJvcHpvbmUuZWxlbWVudEluc2lkZShldnQudGFyZ2V0LCBfdGhpczMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLmR6LW1lc3NhZ2VcIikpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLmhpZGRlbkZpbGVJbnB1dC5jbGljaygpOyAvLyBGb3J3YXJkIHRoZSBjbGlja1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5lbmFibGUoKTtcblxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbml0LmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGZ1bGx5IHRlc3RlZCB5ZXRcblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgdGhpcy5yZW1vdmVBbGxGaWxlcyh0cnVlKTtcbiAgICAgIGlmICh0aGlzLmhpZGRlbkZpbGVJbnB1dCAhPSBudWxsID8gdGhpcy5oaWRkZW5GaWxlSW5wdXQucGFyZW50Tm9kZSA6IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmhpZGRlbkZpbGVJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuaGlkZGVuRmlsZUlucHV0KTtcbiAgICAgICAgdGhpcy5oaWRkZW5GaWxlSW5wdXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuZWxlbWVudC5kcm9wem9uZTtcbiAgICAgIHJldHVybiBEcm9wem9uZS5pbnN0YW5jZXMuc3BsaWNlKERyb3B6b25lLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVG90YWxVcGxvYWRQcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUb3RhbFVwbG9hZFByb2dyZXNzKCkge1xuICAgICAgdmFyIHRvdGFsVXBsb2FkUHJvZ3Jlc3MgPSB2b2lkIDA7XG4gICAgICB2YXIgdG90YWxCeXRlc1NlbnQgPSAwO1xuICAgICAgdmFyIHRvdGFsQnl0ZXMgPSAwO1xuXG4gICAgICB2YXIgYWN0aXZlRmlsZXMgPSB0aGlzLmdldEFjdGl2ZUZpbGVzKCk7XG5cbiAgICAgIGlmIChhY3RpdmVGaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTIgPSB0aGlzLmdldEFjdGl2ZUZpbGVzKCksIF9pc0FycmF5MTIgPSB0cnVlLCBfaTEyID0gMCwgX2l0ZXJhdG9yMTIgPSBfaXNBcnJheTEyID8gX2l0ZXJhdG9yMTIgOiBfaXRlcmF0b3IxMltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgIHZhciBfcmVmMTE7XG5cbiAgICAgICAgICBpZiAoX2lzQXJyYXkxMikge1xuICAgICAgICAgICAgaWYgKF9pMTIgPj0gX2l0ZXJhdG9yMTIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgIF9yZWYxMSA9IF9pdGVyYXRvcjEyW19pMTIrK107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9pMTIgPSBfaXRlcmF0b3IxMi5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoX2kxMi5kb25lKSBicmVhaztcbiAgICAgICAgICAgIF9yZWYxMSA9IF9pMTIudmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGZpbGUgPSBfcmVmMTE7XG5cbiAgICAgICAgICB0b3RhbEJ5dGVzU2VudCArPSBmaWxlLnVwbG9hZC5ieXRlc1NlbnQ7XG4gICAgICAgICAgdG90YWxCeXRlcyArPSBmaWxlLnVwbG9hZC50b3RhbDtcbiAgICAgICAgfVxuICAgICAgICB0b3RhbFVwbG9hZFByb2dyZXNzID0gMTAwICogdG90YWxCeXRlc1NlbnQgLyB0b3RhbEJ5dGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG90YWxVcGxvYWRQcm9ncmVzcyA9IDEwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZW1pdChcInRvdGFsdXBsb2FkcHJvZ3Jlc3NcIiwgdG90YWxVcGxvYWRQcm9ncmVzcywgdG90YWxCeXRlcywgdG90YWxCeXRlc1NlbnQpO1xuICAgIH1cblxuICAgIC8vIEBvcHRpb25zLnBhcmFtTmFtZSBjYW4gYmUgYSBmdW5jdGlvbiB0YWtpbmcgb25lIHBhcmFtZXRlciByYXRoZXIgdGhhbiBhIHN0cmluZy5cbiAgICAvLyBBIHBhcmFtZXRlciBuYW1lIGZvciBhIGZpbGUgaXMgb2J0YWluZWQgc2ltcGx5IGJ5IGNhbGxpbmcgdGhpcyB3aXRoIGFuIGluZGV4IG51bWJlci5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRQYXJhbU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFBhcmFtTmFtZShuKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5wYXJhbU5hbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBhcmFtTmFtZShuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5vcHRpb25zLnBhcmFtTmFtZSArICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUgPyBcIltcIiArIG4gKyBcIl1cIiA6IFwiXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIEBvcHRpb25zLnJlbmFtZUZpbGUgaXMgYSBmdW5jdGlvbixcbiAgICAvLyB0aGUgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIHJlbmFtZSB0aGUgZmlsZS5uYW1lIGJlZm9yZSBhcHBlbmRpbmcgaXQgdG8gdGhlIGZvcm1EYXRhXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVuYW1lRmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuYW1lRmlsZShmaWxlKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5yZW5hbWVGaWxlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGZpbGUubmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVuYW1lRmlsZShmaWxlKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgZm9ybSB0aGF0IGNhbiBiZSB1c2VkIGFzIGZhbGxiYWNrIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgRHJhZ25Ecm9wXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgZHJvcHpvbmUgaXMgYWxyZWFkeSBhIGZvcm0sIG9ubHkgdGhlIGlucHV0IGZpZWxkIGFuZCBidXR0b24gYXJlIHJldHVybmVkLiBPdGhlcndpc2UgYSBjb21wbGV0ZSBmb3JtIGVsZW1lbnQgaXMgcHJvdmlkZWQuXG4gICAgLy8gVGhpcyBjb2RlIGhhcyB0byBwYXNzIGluIElFNyA6KFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmFsbGJhY2tGb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZhbGxiYWNrRm9ybSgpIHtcbiAgICAgIHZhciBleGlzdGluZ0ZhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgICAgIGZvcm0gPSB2b2lkIDA7XG4gICAgICBpZiAoZXhpc3RpbmdGYWxsYmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdGYWxsYmFjaygpKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0ZhbGxiYWNrO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmllbGRzU3RyaW5nID0gXCI8ZGl2IGNsYXNzPVxcXCJkei1mYWxsYmFja1xcXCI+XCI7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRpY3RGYWxsYmFja1RleHQpIHtcbiAgICAgICAgZmllbGRzU3RyaW5nICs9IFwiPHA+XCIgKyB0aGlzLm9wdGlvbnMuZGljdEZhbGxiYWNrVGV4dCArIFwiPC9wPlwiO1xuICAgICAgfVxuICAgICAgZmllbGRzU3RyaW5nICs9IFwiPGlucHV0IHR5cGU9XFxcImZpbGVcXFwiIG5hbWU9XFxcIlwiICsgdGhpcy5fZ2V0UGFyYW1OYW1lKDApICsgXCJcXFwiIFwiICsgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSA/ICdtdWx0aXBsZT1cIm11bHRpcGxlXCInIDogdW5kZWZpbmVkKSArIFwiIC8+PGlucHV0IHR5cGU9XFxcInN1Ym1pdFxcXCIgdmFsdWU9XFxcIlVwbG9hZCFcXFwiPjwvZGl2PlwiO1xuXG4gICAgICB2YXIgZmllbGRzID0gRHJvcHpvbmUuY3JlYXRlRWxlbWVudChmaWVsZHNTdHJpbmcpO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC50YWdOYW1lICE9PSBcIkZPUk1cIikge1xuICAgICAgICBmb3JtID0gRHJvcHpvbmUuY3JlYXRlRWxlbWVudChcIjxmb3JtIGFjdGlvbj1cXFwiXCIgKyB0aGlzLm9wdGlvbnMudXJsICsgXCJcXFwiIGVuY3R5cGU9XFxcIm11bHRpcGFydC9mb3JtLWRhdGFcXFwiIG1ldGhvZD1cXFwiXCIgKyB0aGlzLm9wdGlvbnMubWV0aG9kICsgXCJcXFwiPjwvZm9ybT5cIik7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoZmllbGRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBlbmN0eXBlIGFuZCBtZXRob2QgYXR0cmlidXRlcyBhcmUgc2V0IHByb3Blcmx5XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIsIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcIm1ldGhvZFwiLCB0aGlzLm9wdGlvbnMubWV0aG9kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JtICE9IG51bGwgPyBmb3JtIDogZmllbGRzO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIGZhbGxiYWNrIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QgYWxyZWFkeVxuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGhhcyB0byBwYXNzIGluIElFNyA6KFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RXhpc3RpbmdGYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFeGlzdGluZ0ZhbGxiYWNrKCkge1xuICAgICAgdmFyIGdldEZhbGxiYWNrID0gZnVuY3Rpb24gZ2V0RmFsbGJhY2soZWxlbWVudHMpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTMgPSBlbGVtZW50cywgX2lzQXJyYXkxMyA9IHRydWUsIF9pMTMgPSAwLCBfaXRlcmF0b3IxMyA9IF9pc0FycmF5MTMgPyBfaXRlcmF0b3IxMyA6IF9pdGVyYXRvcjEzW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgdmFyIF9yZWYxMjtcblxuICAgICAgICAgIGlmIChfaXNBcnJheTEzKSB7XG4gICAgICAgICAgICBpZiAoX2kxMyA+PSBfaXRlcmF0b3IxMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjEyID0gX2l0ZXJhdG9yMTNbX2kxMysrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kxMyA9IF9pdGVyYXRvcjEzLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChfaTEzLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjEyID0gX2kxMy52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZWwgPSBfcmVmMTI7XG5cbiAgICAgICAgICBpZiAoLyhefCApZmFsbGJhY2soJHwgKS8udGVzdChlbC5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgX2FyciA9IFtcImRpdlwiLCBcImZvcm1cIl07XG4gICAgICBmb3IgKHZhciBfaTE0ID0gMDsgX2kxNCA8IF9hcnIubGVuZ3RoOyBfaTE0KyspIHtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBfYXJyW19pMTRdO1xuICAgICAgICB2YXIgZmFsbGJhY2s7XG4gICAgICAgIGlmIChmYWxsYmFjayA9IGdldEZhbGxiYWNrKHRoaXMuZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBY3RpdmF0ZXMgYWxsIGxpc3RlbmVycyBzdG9yZWQgaW4gQGxpc3RlbmVyc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLm1hcChmdW5jdGlvbiAoZWxlbWVudExpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBldmVudCBpbiBlbGVtZW50TGlzdGVuZXJzLmV2ZW50cykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZWxlbWVudExpc3RlbmVycy5ldmVudHNbZXZlbnRdO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudExpc3RlbmVycy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZWFjdGl2YXRlcyBhbGwgbGlzdGVuZXJzIHN0b3JlZCBpbiBAbGlzdGVuZXJzXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5tYXAoZnVuY3Rpb24gKGVsZW1lbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgZXZlbnQgaW4gZWxlbWVudExpc3RlbmVycy5ldmVudHMpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGVsZW1lbnRMaXN0ZW5lcnMuZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnRMaXN0ZW5lcnMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBjYW5jZWxzIGFsbCBmaWxlcyBpbiB0aGUgcXVldWUgb3IgYmVpbmcgcHJvY2Vzc2VkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuY2xpY2thYmxlRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZHotY2xpY2thYmxlXCIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHRoaXMuZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuY2FuY2VsVXBsb2FkKGZpbGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICBkZWxldGUgdGhpcy5kaXNhYmxlZDtcbiAgICAgIHRoaXMuY2xpY2thYmxlRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotY2xpY2thYmxlXCIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhIG5pY2VseSBmb3JtYXR0ZWQgZmlsZXNpemVcblxuICB9LCB7XG4gICAga2V5OiBcImZpbGVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGVzaXplKHNpemUpIHtcbiAgICAgIHZhciBzZWxlY3RlZFNpemUgPSAwO1xuICAgICAgdmFyIHNlbGVjdGVkVW5pdCA9IFwiYlwiO1xuXG4gICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIHVuaXRzID0gWyd0YicsICdnYicsICdtYicsICdrYicsICdiJ107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB1bml0ID0gdW5pdHNbaV07XG4gICAgICAgICAgdmFyIGN1dG9mZiA9IE1hdGgucG93KHRoaXMub3B0aW9ucy5maWxlc2l6ZUJhc2UsIDQgLSBpKSAvIDEwO1xuXG4gICAgICAgICAgaWYgKHNpemUgPj0gY3V0b2ZmKSB7XG4gICAgICAgICAgICBzZWxlY3RlZFNpemUgPSBzaXplIC8gTWF0aC5wb3codGhpcy5vcHRpb25zLmZpbGVzaXplQmFzZSwgNCAtIGkpO1xuICAgICAgICAgICAgc2VsZWN0ZWRVbml0ID0gdW5pdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdGVkU2l6ZSA9IE1hdGgucm91bmQoMTAgKiBzZWxlY3RlZFNpemUpIC8gMTA7IC8vIEN1dHRpbmcgb2YgZGlnaXRzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIjxzdHJvbmc+XCIgKyBzZWxlY3RlZFNpemUgKyBcIjwvc3Ryb25nPiBcIiArIHRoaXMub3B0aW9ucy5kaWN0RmlsZVNpemVVbml0c1tzZWxlY3RlZFVuaXRdO1xuICAgIH1cblxuICAgIC8vIEFkZHMgb3IgcmVtb3ZlcyB0aGUgYGR6LW1heC1maWxlcy1yZWFjaGVkYCBjbGFzcyBmcm9tIHRoZSBmb3JtLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZU1heEZpbGVzUmVhY2hlZENsYXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVNYXhGaWxlc1JlYWNoZWRDbGFzcygpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4RmlsZXMgIT0gbnVsbCAmJiB0aGlzLmdldEFjY2VwdGVkRmlsZXMoKS5sZW5ndGggPj0gdGhpcy5vcHRpb25zLm1heEZpbGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmdldEFjY2VwdGVkRmlsZXMoKS5sZW5ndGggPT09IHRoaXMub3B0aW9ucy5tYXhGaWxlcykge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWF4ZmlsZXNyZWFjaGVkJywgdGhpcy5maWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZHotbWF4LWZpbGVzLXJlYWNoZWRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkei1tYXgtZmlsZXMtcmVhY2hlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcm9wKGUpIHtcbiAgICAgIGlmICghZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiZHJvcFwiLCBlKTtcblxuICAgICAgLy8gQ29udmVydCB0aGUgRmlsZUxpc3QgdG8gYW4gQXJyYXlcbiAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBJRTExXG4gICAgICB2YXIgZmlsZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmlsZXNbaV0gPSBlLmRhdGFUcmFuc2Zlci5maWxlc1tpXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KFwiYWRkZWRmaWxlc1wiLCBmaWxlcyk7XG5cbiAgICAgIC8vIEV2ZW4gaWYgaXQncyBhIGZvbGRlciwgZmlsZXMubGVuZ3RoIHdpbGwgY29udGFpbiB0aGUgZm9sZGVycy5cbiAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gZS5kYXRhVHJhbnNmZXIuaXRlbXM7XG5cbiAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1swXS53ZWJraXRHZXRBc0VudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGUgYnJvd3NlciBzdXBwb3J0cyBkcm9wcGluZyBvZiBmb2xkZXJzLCBzbyBoYW5kbGUgaXRlbXMgaW5zdGVhZCBvZiBmaWxlc1xuICAgICAgICAgIHRoaXMuX2FkZEZpbGVzRnJvbUl0ZW1zKGl0ZW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUZpbGVzKGZpbGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXN0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXN0ZShlKSB7XG4gICAgICBpZiAoX19ndWFyZF9fKGUgIT0gbnVsbCA/IGUuY2xpcGJvYXJkRGF0YSA6IHVuZGVmaW5lZCwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHguaXRlbXM7XG4gICAgICB9KSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KFwicGFzdGVcIiwgZSk7XG4gICAgICB2YXIgaXRlbXMgPSBlLmNsaXBib2FyZERhdGEuaXRlbXM7XG5cblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRmlsZXNGcm9tSXRlbXMoaXRlbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVGaWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVGaWxlcyhmaWxlcykge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTQgPSBmaWxlcywgX2lzQXJyYXkxNCA9IHRydWUsIF9pMTUgPSAwLCBfaXRlcmF0b3IxNCA9IF9pc0FycmF5MTQgPyBfaXRlcmF0b3IxNCA6IF9pdGVyYXRvcjE0W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMTM7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5MTQpIHtcbiAgICAgICAgICBpZiAoX2kxNSA+PSBfaXRlcmF0b3IxNC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYxMyA9IF9pdGVyYXRvcjE0W19pMTUrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kxNSA9IF9pdGVyYXRvcjE0Lm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kxNS5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMTMgPSBfaTE1LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbGUgPSBfcmVmMTM7XG5cbiAgICAgICAgdGhpcy5hZGRGaWxlKGZpbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gYSBmb2xkZXIgaXMgZHJvcHBlZCAob3IgZmlsZXMgYXJlIHBhc3RlZCksIGl0ZW1zIG11c3QgYmUgaGFuZGxlZFxuICAgIC8vIGluc3RlYWQgb2YgZmlsZXMuXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkRmlsZXNGcm9tSXRlbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEZpbGVzRnJvbUl0ZW1zKGl0ZW1zKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxNSA9IGl0ZW1zLCBfaXNBcnJheTE1ID0gdHJ1ZSwgX2kxNiA9IDAsIF9pdGVyYXRvcjE1ID0gX2lzQXJyYXkxNSA/IF9pdGVyYXRvcjE1IDogX2l0ZXJhdG9yMTVbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICB2YXIgX3JlZjE0O1xuXG4gICAgICAgICAgaWYgKF9pc0FycmF5MTUpIHtcbiAgICAgICAgICAgIGlmIChfaTE2ID49IF9pdGVyYXRvcjE1Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMTQgPSBfaXRlcmF0b3IxNVtfaTE2KytdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfaTE2ID0gX2l0ZXJhdG9yMTUubmV4dCgpO1xuICAgICAgICAgICAgaWYgKF9pMTYuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMTQgPSBfaTE2LnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpdGVtID0gX3JlZjE0O1xuXG4gICAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICAgIGlmIChpdGVtLndlYmtpdEdldEFzRW50cnkgIT0gbnVsbCAmJiAoZW50cnkgPSBpdGVtLndlYmtpdEdldEFzRW50cnkoKSkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX3RoaXM1LmFkZEZpbGUoaXRlbS5nZXRBc0ZpbGUoKSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAvLyBBcHBlbmQgYWxsIGZpbGVzIGZyb20gdGhhdCBkaXJlY3RvcnkgdG8gZmlsZXNcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX3RoaXM1Ll9hZGRGaWxlc0Zyb21EaXJlY3RvcnkoZW50cnksIGVudHJ5Lm5hbWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmdldEFzRmlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5raW5kID09IG51bGwgfHwgaXRlbS5raW5kID09PSBcImZpbGVcIikge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChfdGhpczUuYWRkRmlsZShpdGVtLmdldEFzRmlsZSgpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSgpO1xuICAgIH1cblxuICAgIC8vIEdvZXMgdGhyb3VnaCB0aGUgZGlyZWN0b3J5LCBhbmQgYWRkcyBlYWNoIGZpbGUgaXQgZmluZHMgcmVjdXJzaXZlbHlcblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRGaWxlc0Zyb21EaXJlY3RvcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEZpbGVzRnJvbURpcmVjdG9yeShkaXJlY3RvcnksIHBhdGgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgZGlyUmVhZGVyID0gZGlyZWN0b3J5LmNyZWF0ZVJlYWRlcigpO1xuXG4gICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gZXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBfX2d1YXJkTWV0aG9kX18oY29uc29sZSwgJ2xvZycsIGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgcmV0dXJuIG8ubG9nKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVhZEVudHJpZXMgPSBmdW5jdGlvbiByZWFkRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIGRpclJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjE2ID0gZW50cmllcywgX2lzQXJyYXkxNiA9IHRydWUsIF9pMTcgPSAwLCBfaXRlcmF0b3IxNiA9IF9pc0FycmF5MTYgPyBfaXRlcmF0b3IxNiA6IF9pdGVyYXRvcjE2W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmMTU7XG5cbiAgICAgICAgICAgICAgaWYgKF9pc0FycmF5MTYpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2kxNyA+PSBfaXRlcmF0b3IxNi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgIF9yZWYxNSA9IF9pdGVyYXRvcjE2W19pMTcrK107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2kxNyA9IF9pdGVyYXRvcjE2Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2kxNy5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICBfcmVmMTUgPSBfaTE3LnZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX3JlZjE1O1xuXG4gICAgICAgICAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5maWxlKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXM2Lm9wdGlvbnMuaWdub3JlSGlkZGVuRmlsZXMgJiYgZmlsZS5uYW1lLnN1YnN0cmluZygwLCAxKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZpbGUuZnVsbFBhdGggPSBwYXRoICsgXCIvXCIgKyBmaWxlLm5hbWU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM2LmFkZEZpbGUoZmlsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBfdGhpczYuX2FkZEZpbGVzRnJvbURpcmVjdG9yeShlbnRyeSwgcGF0aCArIFwiL1wiICsgZW50cnkubmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY2FsbCByZWFkRW50cmllcygpIGFnYWluLCBzaW5jZSBicm93c2VyIG9ubHkgaGFuZGxlXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgMTAwIGVudHJpZXMuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9EaXJlY3RvcnlSZWFkZXIjcmVhZEVudHJpZXNcbiAgICAgICAgICAgIHJlYWRFbnRyaWVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlYWRFbnRyaWVzKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgYGRvbmUoKWAgaXMgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnQgdGhlIGZpbGUgaXMgYWNjZXB0ZWRcbiAgICAvLyBJZiB5b3UgY2FsbCBpdCB3aXRoIGFuIGVycm9yIG1lc3NhZ2UsIHRoZSBmaWxlIGlzIHJlamVjdGVkXG4gICAgLy8gKFRoaXMgYWxsb3dzIGZvciBhc3luY2hyb25vdXMgdmFsaWRhdGlvbilcbiAgICAvL1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gY2hlY2tzIHRoZSBmaWxlc2l6ZSwgYW5kIGlmIHRoZSBmaWxlLnR5cGUgcGFzc2VzIHRoZVxuICAgIC8vIGBhY2NlcHRlZEZpbGVzYCBjaGVjay5cblxuICB9LCB7XG4gICAga2V5OiBcImFjY2VwdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHQoZmlsZSwgZG9uZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhGaWxlc2l6ZSAmJiBmaWxlLnNpemUgPiB0aGlzLm9wdGlvbnMubWF4RmlsZXNpemUgKiAxMDI0ICogMTAyNCkge1xuICAgICAgICByZXR1cm4gZG9uZSh0aGlzLm9wdGlvbnMuZGljdEZpbGVUb29CaWcucmVwbGFjZShcInt7ZmlsZXNpemV9fVwiLCBNYXRoLnJvdW5kKGZpbGUuc2l6ZSAvIDEwMjQgLyAxMC4yNCkgLyAxMDApLnJlcGxhY2UoXCJ7e21heEZpbGVzaXplfX1cIiwgdGhpcy5vcHRpb25zLm1heEZpbGVzaXplKSk7XG4gICAgICB9IGVsc2UgaWYgKCFEcm9wem9uZS5pc1ZhbGlkRmlsZShmaWxlLCB0aGlzLm9wdGlvbnMuYWNjZXB0ZWRGaWxlcykpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUodGhpcy5vcHRpb25zLmRpY3RJbnZhbGlkRmlsZVR5cGUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubWF4RmlsZXMgIT0gbnVsbCAmJiB0aGlzLmdldEFjY2VwdGVkRmlsZXMoKS5sZW5ndGggPj0gdGhpcy5vcHRpb25zLm1heEZpbGVzKSB7XG4gICAgICAgIGRvbmUodGhpcy5vcHRpb25zLmRpY3RNYXhGaWxlc0V4Y2VlZGVkLnJlcGxhY2UoXCJ7e21heEZpbGVzfX1cIiwgdGhpcy5vcHRpb25zLm1heEZpbGVzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJtYXhmaWxlc2V4Y2VlZGVkXCIsIGZpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hY2NlcHQuY2FsbCh0aGlzLCBmaWxlLCBkb25lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGaWxlKGZpbGUpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICBmaWxlLnVwbG9hZCA9IHtcbiAgICAgICAgdXVpZDogRHJvcHpvbmUudXVpZHY0KCksXG4gICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAvLyBTZXR0aW5nIHRoZSB0b3RhbCB1cGxvYWQgc2l6ZSB0byBmaWxlLnNpemUgZm9yIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgLy8gSXQncyBhY3R1YWwgZGlmZmVyZW50IHRoYW4gdGhlIHNpemUgdG8gYmUgdHJhbnNtaXR0ZWQuXG4gICAgICAgIHRvdGFsOiBmaWxlLnNpemUsXG4gICAgICAgIGJ5dGVzU2VudDogMCxcbiAgICAgICAgZmlsZW5hbWU6IHRoaXMuX3JlbmFtZUZpbGUoZmlsZSksXG4gICAgICAgIGNodW5rZWQ6IHRoaXMub3B0aW9ucy5jaHVua2luZyAmJiAodGhpcy5vcHRpb25zLmZvcmNlQ2h1bmtpbmcgfHwgZmlsZS5zaXplID4gdGhpcy5vcHRpb25zLmNodW5rU2l6ZSksXG4gICAgICAgIHRvdGFsQ2h1bmtDb3VudDogTWF0aC5jZWlsKGZpbGUuc2l6ZSAvIHRoaXMub3B0aW9ucy5jaHVua1NpemUpXG4gICAgICB9O1xuICAgICAgdGhpcy5maWxlcy5wdXNoKGZpbGUpO1xuXG4gICAgICBmaWxlLnN0YXR1cyA9IERyb3B6b25lLkFEREVEO1xuXG4gICAgICB0aGlzLmVtaXQoXCJhZGRlZGZpbGVcIiwgZmlsZSk7XG5cbiAgICAgIHRoaXMuX2VucXVldWVUaHVtYm5haWwoZmlsZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmFjY2VwdChmaWxlLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgZmlsZS5hY2NlcHRlZCA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzNy5fZXJyb3JQcm9jZXNzaW5nKFtmaWxlXSwgZXJyb3IpOyAvLyBXaWxsIHNldCB0aGUgZmlsZS5zdGF0dXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWxlLmFjY2VwdGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoX3RoaXM3Lm9wdGlvbnMuYXV0b1F1ZXVlKSB7XG4gICAgICAgICAgICBfdGhpczcuZW5xdWV1ZUZpbGUoZmlsZSk7XG4gICAgICAgICAgfSAvLyBXaWxsIHNldCAuYWNjZXB0ZWQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzNy5fdXBkYXRlTWF4RmlsZXNSZWFjaGVkQ2xhc3MoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFdyYXBwZXIgZm9yIGVucXVldWVGaWxlXG5cbiAgfSwge1xuICAgIGtleTogXCJlbnF1ZXVlRmlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5xdWV1ZUZpbGVzKGZpbGVzKSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IxNyA9IGZpbGVzLCBfaXNBcnJheTE3ID0gdHJ1ZSwgX2kxOCA9IDAsIF9pdGVyYXRvcjE3ID0gX2lzQXJyYXkxNyA/IF9pdGVyYXRvcjE3IDogX2l0ZXJhdG9yMTdbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgdmFyIF9yZWYxNjtcblxuICAgICAgICBpZiAoX2lzQXJyYXkxNykge1xuICAgICAgICAgIGlmIChfaTE4ID49IF9pdGVyYXRvcjE3Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjE2ID0gX2l0ZXJhdG9yMTdbX2kxOCsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTE4ID0gX2l0ZXJhdG9yMTcubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTE4LmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYxNiA9IF9pMTgudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsZSA9IF9yZWYxNjtcblxuICAgICAgICB0aGlzLmVucXVldWVGaWxlKGZpbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVucXVldWVGaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVucXVldWVGaWxlKGZpbGUpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICBpZiAoZmlsZS5zdGF0dXMgPT09IERyb3B6b25lLkFEREVEICYmIGZpbGUuYWNjZXB0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgZmlsZS5zdGF0dXMgPSBEcm9wem9uZS5RVUVVRUQ7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Byb2Nlc3NRdWV1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczgucHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgICAgfSwgMCk7IC8vIERlZmVycmluZyB0aGUgY2FsbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGZpbGUgY2FuJ3QgYmUgcXVldWVkIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQgb3Igd2FzIHJlamVjdGVkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VucXVldWVUaHVtYm5haWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VucXVldWVUaHVtYm5haWwoZmlsZSkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3JlYXRlSW1hZ2VUaHVtYm5haWxzICYmIGZpbGUudHlwZS5tYXRjaCgvaW1hZ2UuKi8pICYmIGZpbGUuc2l6ZSA8PSB0aGlzLm9wdGlvbnMubWF4VGh1bWJuYWlsRmlsZXNpemUgKiAxMDI0ICogMTAyNCkge1xuICAgICAgICB0aGlzLl90aHVtYm5haWxRdWV1ZS5wdXNoKGZpbGUpO1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzOS5fcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCk7XG4gICAgICAgIH0sIDApOyAvLyBEZWZlcnJpbmcgdGhlIGNhbGxcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Byb2Nlc3NUaHVtYm5haWxRdWV1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCkge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1RodW1ibmFpbCB8fCB0aGlzLl90aHVtYm5haWxRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcm9jZXNzaW5nVGh1bWJuYWlsID0gdHJ1ZTtcbiAgICAgIHZhciBmaWxlID0gdGhpcy5fdGh1bWJuYWlsUXVldWUuc2hpZnQoKTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRodW1ibmFpbChmaWxlLCB0aGlzLm9wdGlvbnMudGh1bWJuYWlsV2lkdGgsIHRoaXMub3B0aW9ucy50aHVtYm5haWxIZWlnaHQsIHRoaXMub3B0aW9ucy50aHVtYm5haWxNZXRob2QsIHRydWUsIGZ1bmN0aW9uIChkYXRhVXJsKSB7XG4gICAgICAgIF90aGlzMTAuZW1pdChcInRodW1ibmFpbFwiLCBmaWxlLCBkYXRhVXJsKTtcbiAgICAgICAgX3RoaXMxMC5fcHJvY2Vzc2luZ1RodW1ibmFpbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXMxMC5fcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDYW4gYmUgY2FsbGVkIGJ5IHRoZSB1c2VyIHRvIHJlbW92ZSBhIGZpbGVcblxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRmlsZShmaWxlKSB7XG4gICAgICBpZiAoZmlsZS5zdGF0dXMgPT09IERyb3B6b25lLlVQTE9BRElORykge1xuICAgICAgICB0aGlzLmNhbmNlbFVwbG9hZChmaWxlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlsZXMgPSB3aXRob3V0KHRoaXMuZmlsZXMsIGZpbGUpO1xuXG4gICAgICB0aGlzLmVtaXQoXCJyZW1vdmVkZmlsZVwiLCBmaWxlKTtcbiAgICAgIGlmICh0aGlzLmZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KFwicmVzZXRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlcyBhbGwgZmlsZXMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IHByb2Nlc3NlZCBmcm9tIHRoZSBsaXN0XG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVBbGxGaWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBbGxGaWxlcyhjYW5jZWxJZk5lY2Vzc2FyeSkge1xuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiBmaWxlcyBzaW5jZSByZW1vdmVGaWxlKCkgY2hhbmdlcyB0aGUgQGZpbGVzIGFycmF5LlxuICAgICAgaWYgKGNhbmNlbElmTmVjZXNzYXJ5ID09IG51bGwpIHtcbiAgICAgICAgY2FuY2VsSWZOZWNlc3NhcnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjE4ID0gdGhpcy5maWxlcy5zbGljZSgpLCBfaXNBcnJheTE4ID0gdHJ1ZSwgX2kxOSA9IDAsIF9pdGVyYXRvcjE4ID0gX2lzQXJyYXkxOCA/IF9pdGVyYXRvcjE4IDogX2l0ZXJhdG9yMThbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgdmFyIF9yZWYxNztcblxuICAgICAgICBpZiAoX2lzQXJyYXkxOCkge1xuICAgICAgICAgIGlmIChfaTE5ID49IF9pdGVyYXRvcjE4Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjE3ID0gX2l0ZXJhdG9yMThbX2kxOSsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTE5ID0gX2l0ZXJhdG9yMTgubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTE5LmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYxNyA9IF9pMTkudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsZSA9IF9yZWYxNztcblxuICAgICAgICBpZiAoZmlsZS5zdGF0dXMgIT09IERyb3B6b25lLlVQTE9BRElORyB8fCBjYW5jZWxJZk5lY2Vzc2FyeSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRmlsZShmaWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gUmVzaXplcyBhbiBpbWFnZSBiZWZvcmUgaXQgZ2V0cyBzZW50IHRvIHRoZSBzZXJ2ZXIuIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcbiAgICAvLyBgb3B0aW9ucy50cmFuc2Zvcm1GaWxlYCBpZiBgcmVzaXplV2lkdGhgIG9yIGByZXNpemVIZWlnaHRgIGFyZSBzZXQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGhcbiAgICAvLyB0aGUgcmVzaXplZCBibG9iLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplSW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplSW1hZ2UoZmlsZSwgd2lkdGgsIGhlaWdodCwgcmVzaXplTWV0aG9kLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVUaHVtYm5haWwoZmlsZSwgd2lkdGgsIGhlaWdodCwgcmVzaXplTWV0aG9kLCB0cnVlLCBmdW5jdGlvbiAoZGF0YVVybCwgY2FudmFzKSB7XG4gICAgICAgIGlmIChjYW52YXMgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoZSBpbWFnZSBoYXMgbm90IGJlZW4gcmVzaXplZFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhmaWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzaXplTWltZVR5cGUgPSBfdGhpczExLm9wdGlvbnMucmVzaXplTWltZVR5cGU7XG5cbiAgICAgICAgICBpZiAocmVzaXplTWltZVR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzaXplTWltZVR5cGUgPSBmaWxlLnR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXNpemVkRGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwocmVzaXplTWltZVR5cGUsIF90aGlzMTEub3B0aW9ucy5yZXNpemVRdWFsaXR5KTtcbiAgICAgICAgICBpZiAocmVzaXplTWltZVR5cGUgPT09ICdpbWFnZS9qcGVnJyB8fCByZXNpemVNaW1lVHlwZSA9PT0gJ2ltYWdlL2pwZycpIHtcbiAgICAgICAgICAgIC8vIE5vdyBhZGQgdGhlIG9yaWdpbmFsIEVYSUYgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIHJlc2l6ZWREYXRhVVJMID0gRXhpZlJlc3RvcmUucmVzdG9yZShmaWxlLmRhdGFVUkwsIHJlc2l6ZWREYXRhVVJMKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKERyb3B6b25lLmRhdGFVUkl0b0Jsb2IocmVzaXplZERhdGFVUkwpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVRodW1ibmFpbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUaHVtYm5haWwoZmlsZSwgd2lkdGgsIGhlaWdodCwgcmVzaXplTWV0aG9kLCBmaXhPcmllbnRhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBmaWxlLmRhdGFVUkwgPSBmaWxlUmVhZGVyLnJlc3VsdDtcblxuICAgICAgICAvLyBEb24ndCBib3RoZXIgY3JlYXRpbmcgYSB0aHVtYm5haWwgZm9yIFNWRyBpbWFnZXMgc2luY2UgdGhleSdyZSB2ZWN0b3JcbiAgICAgICAgaWYgKGZpbGUudHlwZSA9PT0gXCJpbWFnZS9zdmcreG1sXCIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZmlsZVJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMxMi5jcmVhdGVUaHVtYm5haWxGcm9tVXJsKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgZml4T3JpZW50YXRpb24sIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVRodW1ibmFpbEZyb21VcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGh1bWJuYWlsRnJvbVVybChmaWxlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemVNZXRob2QsIGZpeE9yaWVudGF0aW9uLCBjYWxsYmFjaywgY3Jvc3NPcmlnaW4pIHtcbiAgICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgICAgLy8gTm90IHVzaW5nIGBuZXcgSW1hZ2VgIGhlcmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBsYXRlc3QgQ2hyb21lIHZlcnNpb25zLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbnlvL2Ryb3B6b25lL3B1bGwvMjI2XG4gICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblxuICAgICAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9hZEV4aWYgPSBmdW5jdGlvbiBsb2FkRXhpZihjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygxKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBFWElGICE9PSAndW5kZWZpbmVkJyAmJiBFWElGICE9PSBudWxsICYmIGZpeE9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgbG9hZEV4aWYgPSBmdW5jdGlvbiBsb2FkRXhpZihjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIEVYSUYuZ2V0RGF0YShpbWcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVYSUYuZ2V0VGFnKHRoaXMsICdPcmllbnRhdGlvbicpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9hZEV4aWYoZnVuY3Rpb24gKG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgZmlsZS53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICBmaWxlLmhlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgICB2YXIgcmVzaXplSW5mbyA9IF90aGlzMTMub3B0aW9ucy5yZXNpemUuY2FsbChfdGhpczEzLCBmaWxlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemVNZXRob2QpO1xuXG4gICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgICBjYW52YXMud2lkdGggPSByZXNpemVJbmZvLnRyZ1dpZHRoO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSByZXNpemVJbmZvLnRyZ0hlaWdodDtcblxuICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA+IDQpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHJlc2l6ZUluZm8udHJnSGVpZ2h0O1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHJlc2l6ZUluZm8udHJnV2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChvcmllbnRhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAvLyBob3Jpem9udGFsIGZsaXBcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGgsIDApO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgLy8gMTgwwrAgcm90YXRlIGxlZnRcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICBjdHgucm90YXRlKE1hdGguUEkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgLy8gdmVydGljYWwgZmxpcFxuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgLy8gdmVydGljYWwgZmxpcCArIDkwIHJvdGF0ZSByaWdodFxuICAgICAgICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgLy8gOTDCsCByb3RhdGUgcmlnaHRcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgwLjUgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCAtY2FudmFzLndpZHRoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIC8vIGhvcml6b250YWwgZmxpcCArIDkwIHJvdGF0ZSByaWdodFxuICAgICAgICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNhbnZhcy5oZWlnaHQsIC1jYW52YXMud2lkdGgpO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgLy8gOTDCsCByb3RhdGUgbGVmdFxuICAgICAgICAgICAgICBjdHgucm90YXRlKC0wLjUgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY2FudmFzLmhlaWdodCwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoaXMgaXMgYSBidWdmaXggZm9yIGlPUycgc2NhbGluZyBidWcuXG4gICAgICAgICAgZHJhd0ltYWdlSU9TRml4KGN0eCwgaW1nLCByZXNpemVJbmZvLnNyY1ggIT0gbnVsbCA/IHJlc2l6ZUluZm8uc3JjWCA6IDAsIHJlc2l6ZUluZm8uc3JjWSAhPSBudWxsID8gcmVzaXplSW5mby5zcmNZIDogMCwgcmVzaXplSW5mby5zcmNXaWR0aCwgcmVzaXplSW5mby5zcmNIZWlnaHQsIHJlc2l6ZUluZm8udHJnWCAhPSBudWxsID8gcmVzaXplSW5mby50cmdYIDogMCwgcmVzaXplSW5mby50cmdZICE9IG51bGwgPyByZXNpemVJbmZvLnRyZ1kgOiAwLCByZXNpemVJbmZvLnRyZ1dpZHRoLCByZXNpemVJbmZvLnRyZ0hlaWdodCk7XG5cbiAgICAgICAgICB2YXIgdGh1bWJuYWlsID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcblxuICAgICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGh1bWJuYWlsLCBjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBpbWcub25lcnJvciA9IGNhbGxiYWNrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW1nLnNyYyA9IGZpbGUuZGF0YVVSTDtcbiAgICB9XG5cbiAgICAvLyBHb2VzIHRocm91Z2ggdGhlIHF1ZXVlIGFuZCBwcm9jZXNzZXMgZmlsZXMgaWYgdGhlcmUgYXJlbid0IHRvbyBtYW55IGFscmVhZHkuXG5cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzUXVldWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICAgICAgdmFyIHBhcmFsbGVsVXBsb2FkcyA9IHRoaXMub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHM7XG5cbiAgICAgIHZhciBwcm9jZXNzaW5nTGVuZ3RoID0gdGhpcy5nZXRVcGxvYWRpbmdGaWxlcygpLmxlbmd0aDtcbiAgICAgIHZhciBpID0gcHJvY2Vzc2luZ0xlbmd0aDtcblxuICAgICAgLy8gVGhlcmUgYXJlIGFscmVhZHkgYXQgbGVhc3QgYXMgbWFueSBmaWxlcyB1cGxvYWRpbmcgdGhhbiBzaG91bGQgYmVcbiAgICAgIGlmIChwcm9jZXNzaW5nTGVuZ3RoID49IHBhcmFsbGVsVXBsb2Fkcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBxdWV1ZWRGaWxlcyA9IHRoaXMuZ2V0UXVldWVkRmlsZXMoKTtcblxuICAgICAgaWYgKCEocXVldWVkRmlsZXMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XG4gICAgICAgIC8vIFRoZSBmaWxlcyBzaG91bGQgYmUgdXBsb2FkZWQgaW4gb25lIHJlcXVlc3RcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0ZpbGVzKHF1ZXVlZEZpbGVzLnNsaWNlKDAsIHBhcmFsbGVsVXBsb2FkcyAtIHByb2Nlc3NpbmdMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChpIDwgcGFyYWxsZWxVcGxvYWRzKSB7XG4gICAgICAgICAgaWYgKCFxdWV1ZWRGaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIE5vdGhpbmcgbGVmdCB0byBwcm9jZXNzXG4gICAgICAgICAgdGhpcy5wcm9jZXNzRmlsZShxdWV1ZWRGaWxlcy5zaGlmdCgpKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXcmFwcGVyIGZvciBgcHJvY2Vzc0ZpbGVzYFxuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc0ZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0ZpbGUoZmlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0ZpbGVzKFtmaWxlXSk7XG4gICAgfVxuXG4gICAgLy8gTG9hZHMgdGhlIGZpbGUsIHRoZW4gY2FsbHMgZmluaXNoZWRMb2FkaW5nKClcblxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NGaWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoZmlsZXMpIHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjE5ID0gZmlsZXMsIF9pc0FycmF5MTkgPSB0cnVlLCBfaTIwID0gMCwgX2l0ZXJhdG9yMTkgPSBfaXNBcnJheTE5ID8gX2l0ZXJhdG9yMTkgOiBfaXRlcmF0b3IxOVtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICB2YXIgX3JlZjE4O1xuXG4gICAgICAgIGlmIChfaXNBcnJheTE5KSB7XG4gICAgICAgICAgaWYgKF9pMjAgPj0gX2l0ZXJhdG9yMTkubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmMTggPSBfaXRlcmF0b3IxOVtfaTIwKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pMjAgPSBfaXRlcmF0b3IxOS5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pMjAuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZjE4ID0gX2kyMC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWxlID0gX3JlZjE4O1xuXG4gICAgICAgIGZpbGUucHJvY2Vzc2luZyA9IHRydWU7IC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIGZpbGUuc3RhdHVzID0gRHJvcHpvbmUuVVBMT0FESU5HO1xuXG4gICAgICAgIHRoaXMuZW1pdChcInByb2Nlc3NpbmdcIiwgZmlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwicHJvY2Vzc2luZ211bHRpcGxlXCIsIGZpbGVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudXBsb2FkRmlsZXMoZmlsZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RmlsZXNXaXRoWGhyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGaWxlc1dpdGhYaHIoeGhyKSB7XG4gICAgICB2YXIgZmlsZXMgPSB2b2lkIDA7XG4gICAgICByZXR1cm4gZmlsZXMgPSB0aGlzLmZpbGVzLmZpbHRlcihmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICByZXR1cm4gZmlsZS54aHIgPT09IHhocjtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENhbmNlbHMgdGhlIGZpbGUgdXBsb2FkIGFuZCBzZXRzIHRoZSBzdGF0dXMgdG8gQ0FOQ0VMRURcbiAgICAvLyAqKmlmKiogdGhlIGZpbGUgaXMgYWN0dWFsbHkgYmVpbmcgdXBsb2FkZWQuXG4gICAgLy8gSWYgaXQncyBzdGlsbCBpbiB0aGUgcXVldWUsIHRoZSBmaWxlIGlzIGJlaW5nIHJlbW92ZWQgZnJvbSBpdCBhbmQgdGhlIHN0YXR1c1xuICAgIC8vIHNldCB0byBDQU5DRUxFRC5cblxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbFVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWxVcGxvYWQoZmlsZSkge1xuICAgICAgaWYgKGZpbGUuc3RhdHVzID09PSBEcm9wem9uZS5VUExPQURJTkcpIHtcbiAgICAgICAgdmFyIGdyb3VwZWRGaWxlcyA9IHRoaXMuX2dldEZpbGVzV2l0aFhocihmaWxlLnhocik7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIwID0gZ3JvdXBlZEZpbGVzLCBfaXNBcnJheTIwID0gdHJ1ZSwgX2kyMSA9IDAsIF9pdGVyYXRvcjIwID0gX2lzQXJyYXkyMCA/IF9pdGVyYXRvcjIwIDogX2l0ZXJhdG9yMjBbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICB2YXIgX3JlZjE5O1xuXG4gICAgICAgICAgaWYgKF9pc0FycmF5MjApIHtcbiAgICAgICAgICAgIGlmIChfaTIxID49IF9pdGVyYXRvcjIwLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMTkgPSBfaXRlcmF0b3IyMFtfaTIxKytdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfaTIxID0gX2l0ZXJhdG9yMjAubmV4dCgpO1xuICAgICAgICAgICAgaWYgKF9pMjEuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMTkgPSBfaTIxLnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBncm91cGVkRmlsZSA9IF9yZWYxOTtcblxuICAgICAgICAgIGdyb3VwZWRGaWxlLnN0YXR1cyA9IERyb3B6b25lLkNBTkNFTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZS54aHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZmlsZS54aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyMSA9IGdyb3VwZWRGaWxlcywgX2lzQXJyYXkyMSA9IHRydWUsIF9pMjIgPSAwLCBfaXRlcmF0b3IyMSA9IF9pc0FycmF5MjEgPyBfaXRlcmF0b3IyMSA6IF9pdGVyYXRvcjIxW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgdmFyIF9yZWYyMDtcblxuICAgICAgICAgIGlmIChfaXNBcnJheTIxKSB7XG4gICAgICAgICAgICBpZiAoX2kyMiA+PSBfaXRlcmF0b3IyMS5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjIwID0gX2l0ZXJhdG9yMjFbX2kyMisrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kyMiA9IF9pdGVyYXRvcjIxLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChfaTIyLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjIwID0gX2kyMi52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dyb3VwZWRGaWxlID0gX3JlZjIwO1xuXG4gICAgICAgICAgdGhpcy5lbWl0KFwiY2FuY2VsZWRcIiwgX2dyb3VwZWRGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwiY2FuY2VsZWRtdWx0aXBsZVwiLCBncm91cGVkRmlsZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpbGUuc3RhdHVzID09PSBEcm9wem9uZS5BRERFRCB8fCBmaWxlLnN0YXR1cyA9PT0gRHJvcHpvbmUuUVVFVUVEKSB7XG4gICAgICAgIGZpbGUuc3RhdHVzID0gRHJvcHpvbmUuQ0FOQ0VMRUQ7XG4gICAgICAgIHRoaXMuZW1pdChcImNhbmNlbGVkXCIsIGZpbGUpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwiY2FuY2VsZWRtdWx0aXBsZVwiLCBbZmlsZV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Byb2Nlc3NRdWV1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUXVldWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZU9wdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlT3B0aW9uKG9wdGlvbikge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBsb2FkRmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGxvYWRGaWxlKGZpbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwbG9hZEZpbGVzKFtmaWxlXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwbG9hZEZpbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwbG9hZEZpbGVzKGZpbGVzKSB7XG4gICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3RyYW5zZm9ybUZpbGVzKGZpbGVzLCBmdW5jdGlvbiAodHJhbnNmb3JtZWRGaWxlcykge1xuICAgICAgICBpZiAoZmlsZXNbMF0udXBsb2FkLmNodW5rZWQpIHtcbiAgICAgICAgICAvLyBUaGlzIGZpbGUgc2hvdWxkIGJlIHNlbnQgaW4gY2h1bmtzIVxuXG4gICAgICAgICAgLy8gSWYgdGhlIGNodW5raW5nIG9wdGlvbiBpcyBzZXQsIHdlICoqa25vdyoqIHRoYXQgdGhlcmUgY2FuIG9ubHkgYmUgKipvbmUqKiBmaWxlLCBzaW5jZVxuICAgICAgICAgIC8vIHVwbG9hZE11bHRpcGxlIGlzIG5vdCBhbGxvd2VkIHdpdGggdGhpcyBvcHRpb24uXG4gICAgICAgICAgdmFyIGZpbGUgPSBmaWxlc1swXTtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRGaWxlID0gdHJhbnNmb3JtZWRGaWxlc1swXTtcbiAgICAgICAgICB2YXIgc3RhcnRlZENodW5rQ291bnQgPSAwO1xuXG4gICAgICAgICAgZmlsZS51cGxvYWQuY2h1bmtzID0gW107XG5cbiAgICAgICAgICB2YXIgaGFuZGxlTmV4dENodW5rID0gZnVuY3Rpb24gaGFuZGxlTmV4dENodW5rKCkge1xuICAgICAgICAgICAgdmFyIGNodW5rSW5kZXggPSAwO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXh0IGl0ZW0gaW4gZmlsZS51cGxvYWQuY2h1bmtzIHRoYXQgaXMgbm90IGRlZmluZWQgeWV0LlxuICAgICAgICAgICAgd2hpbGUgKGZpbGUudXBsb2FkLmNodW5rc1tjaHVua0luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhpcyBtZWFucywgdGhhdCBhbGwgY2h1bmtzIGhhdmUgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQuXG4gICAgICAgICAgICBpZiAoY2h1bmtJbmRleCA+PSBmaWxlLnVwbG9hZC50b3RhbENodW5rQ291bnQpIHJldHVybjtcblxuICAgICAgICAgICAgc3RhcnRlZENodW5rQ291bnQrKztcblxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2h1bmtJbmRleCAqIF90aGlzMTQub3B0aW9ucy5jaHVua1NpemU7XG4gICAgICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBfdGhpczE0Lm9wdGlvbnMuY2h1bmtTaXplLCBmaWxlLnNpemUpO1xuXG4gICAgICAgICAgICB2YXIgZGF0YUJsb2NrID0ge1xuICAgICAgICAgICAgICBuYW1lOiBfdGhpczE0Ll9nZXRQYXJhbU5hbWUoMCksXG4gICAgICAgICAgICAgIGRhdGE6IHRyYW5zZm9ybWVkRmlsZS53ZWJraXRTbGljZSA/IHRyYW5zZm9ybWVkRmlsZS53ZWJraXRTbGljZShzdGFydCwgZW5kKSA6IHRyYW5zZm9ybWVkRmlsZS5zbGljZShzdGFydCwgZW5kKSxcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGUudXBsb2FkLmZpbGVuYW1lLFxuICAgICAgICAgICAgICBjaHVua0luZGV4OiBjaHVua0luZGV4XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmaWxlLnVwbG9hZC5jaHVua3NbY2h1bmtJbmRleF0gPSB7XG4gICAgICAgICAgICAgIGZpbGU6IGZpbGUsXG4gICAgICAgICAgICAgIGluZGV4OiBjaHVua0luZGV4LFxuICAgICAgICAgICAgICBkYXRhQmxvY2s6IGRhdGFCbG9jaywgLy8gSW4gY2FzZSB3ZSB3YW50IHRvIHJldHJ5LlxuICAgICAgICAgICAgICBzdGF0dXM6IERyb3B6b25lLlVQTE9BRElORyxcbiAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICAgIHJldHJpZXM6IDAgLy8gVGhlIG51bWJlciBvZiB0aW1lcyB0aGlzIGJsb2NrIGhhcyBiZWVuIHJldHJpZWQuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfdGhpczE0Ll91cGxvYWREYXRhKGZpbGVzLCBbZGF0YUJsb2NrXSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZpbGUudXBsb2FkLmZpbmlzaGVkQ2h1bmtVcGxvYWQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIHZhciBhbGxGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBEcm9wem9uZS5TVUNDRVNTO1xuXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgZGF0YSBmcm9tIHRoZSBjaHVua1xuICAgICAgICAgICAgY2h1bmsuZGF0YUJsb2NrID0gbnVsbDtcbiAgICAgICAgICAgIC8vIExlYXZpbmcgdGhpcyByZWZlcmVuY2UgdG8geGhyIGludGFjdCBoZXJlIHdpbGwgY2F1c2UgbWVtb3J5IGxlYWtzIGluIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgIGNodW5rLnhociA9IG51bGw7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZS51cGxvYWQudG90YWxDaHVua0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGZpbGUudXBsb2FkLmNodW5rc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU5leHRDaHVuaygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmaWxlLnVwbG9hZC5jaHVua3NbaV0uc3RhdHVzICE9PSBEcm9wem9uZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICAgICAgYWxsRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXMxNC5vcHRpb25zLmNodW5rc1VwbG9hZGVkKGZpbGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczE0Ll9maW5pc2hlZChmaWxlcywgJycsIG51bGwpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKF90aGlzMTQub3B0aW9ucy5wYXJhbGxlbENodW5rVXBsb2Fkcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlLnVwbG9hZC50b3RhbENodW5rQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBoYW5kbGVOZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlTmV4dENodW5rKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkYXRhQmxvY2tzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kyMyA9IDA7IF9pMjMgPCBmaWxlcy5sZW5ndGg7IF9pMjMrKykge1xuICAgICAgICAgICAgZGF0YUJsb2Nrc1tfaTIzXSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogX3RoaXMxNC5fZ2V0UGFyYW1OYW1lKF9pMjMpLFxuICAgICAgICAgICAgICBkYXRhOiB0cmFuc2Zvcm1lZEZpbGVzW19pMjNdLFxuICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZXNbX2kyM10udXBsb2FkLmZpbGVuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczE0Ll91cGxvYWREYXRhKGZpbGVzLCBkYXRhQmxvY2tzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8vIFJldHVybnMgdGhlIHJpZ2h0IGNodW5rIGZvciBnaXZlbiBmaWxlIGFuZCB4aHJcblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDaHVua1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2h1bmsoZmlsZSwgeGhyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChmaWxlLnVwbG9hZC5jaHVua3NbaV0gIT09IHVuZGVmaW5lZCAmJiBmaWxlLnVwbG9hZC5jaHVua3NbaV0ueGhyID09PSB4aHIpIHtcbiAgICAgICAgICByZXR1cm4gZmlsZS51cGxvYWQuY2h1bmtzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY3R1YWxseSB1cGxvYWRzIHRoZSBmaWxlKHMpIHRvIHRoZSBzZXJ2ZXIuXG4gICAgLy8gSWYgZGF0YUJsb2NrcyBjb250YWlucyB0aGUgYWN0dWFsIGRhdGEgdG8gdXBsb2FkIChtZWFuaW5nLCB0aGF0IHRoaXMgY291bGQgZWl0aGVyIGJlIHRyYW5zZm9ybWVkXG4gICAgLy8gZmlsZXMsIG9yIGluZGl2aWR1YWwgY2h1bmtzIGZvciBjaHVua2VkIHVwbG9hZCkuXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBsb2FkRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBsb2FkRGF0YShmaWxlcywgZGF0YUJsb2Nrcykge1xuICAgICAgdmFyIF90aGlzMTUgPSB0aGlzO1xuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIC8vIFB1dCB0aGUgeGhyIG9iamVjdCBpbiB0aGUgZmlsZSBvYmplY3RzIHRvIGJlIGFibGUgdG8gcmVmZXJlbmNlIGl0IGxhdGVyLlxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMjIgPSBmaWxlcywgX2lzQXJyYXkyMiA9IHRydWUsIF9pMjQgPSAwLCBfaXRlcmF0b3IyMiA9IF9pc0FycmF5MjIgPyBfaXRlcmF0b3IyMiA6IF9pdGVyYXRvcjIyW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMjE7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5MjIpIHtcbiAgICAgICAgICBpZiAoX2kyNCA+PSBfaXRlcmF0b3IyMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYyMSA9IF9pdGVyYXRvcjIyW19pMjQrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kyNCA9IF9pdGVyYXRvcjIyLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kyNC5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMjEgPSBfaTI0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbGUgPSBfcmVmMjE7XG5cbiAgICAgICAgZmlsZS54aHIgPSB4aHI7XG4gICAgICB9XG4gICAgICBpZiAoZmlsZXNbMF0udXBsb2FkLmNodW5rZWQpIHtcbiAgICAgICAgLy8gUHV0IHRoZSB4aHIgb2JqZWN0IGluIHRoZSByaWdodCBjaHVuayBvYmplY3QsIHNvIGl0IGNhbiBiZSBhc3NvY2lhdGVkIGxhdGVyLCBhbmQgZm91bmQgd2l0aCBfZ2V0Q2h1bmtcbiAgICAgICAgZmlsZXNbMF0udXBsb2FkLmNodW5rc1tkYXRhQmxvY2tzWzBdLmNodW5rSW5kZXhdLnhociA9IHhocjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucmVzb2x2ZU9wdGlvbih0aGlzLm9wdGlvbnMubWV0aG9kLCBmaWxlcyk7XG4gICAgICB2YXIgdXJsID0gdGhpcy5yZXNvbHZlT3B0aW9uKHRoaXMub3B0aW9ucy51cmwsIGZpbGVzKTtcbiAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgICAgLy8gU2V0dGluZyB0aGUgdGltZW91dCBhZnRlciBvcGVuIGJlY2F1c2Ugb2YgSUUxMSBpc3N1ZTogaHR0cHM6Ly9naXRsYWIuY29tL21lbm8vZHJvcHpvbmUvaXNzdWVzLzhcbiAgICAgIHhoci50aW1lb3V0ID0gdGhpcy5yZXNvbHZlT3B0aW9uKHRoaXMub3B0aW9ucy50aW1lb3V0LCBmaWxlcyk7XG5cbiAgICAgIC8vIEhhcyB0byBiZSBhZnRlciBgLm9wZW4oKWAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZW55by9kcm9wem9uZS9pc3N1ZXMvMTc5XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISF0aGlzLm9wdGlvbnMud2l0aENyZWRlbnRpYWxzO1xuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXMxNS5fZmluaXNoZWRVcGxvYWRpbmcoZmlsZXMsIHhociwgZSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxNS5faGFuZGxlVXBsb2FkRXJyb3IoZmlsZXMsIHhocik7XG4gICAgICB9O1xuXG4gICAgICAvLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBoYXZlIHRoZSAudXBsb2FkIHByb3BlcnR5XG4gICAgICB2YXIgcHJvZ3Jlc3NPYmogPSB4aHIudXBsb2FkICE9IG51bGwgPyB4aHIudXBsb2FkIDogeGhyO1xuICAgICAgcHJvZ3Jlc3NPYmoub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczE1Ll91cGRhdGVGaWxlc1VwbG9hZFByb2dyZXNzKGZpbGVzLCB4aHIsIGUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGhlYWRlcnMgPSB7XG4gICAgICAgIFwiQWNjZXB0XCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkNhY2hlLUNvbnRyb2xcIjogXCJuby1jYWNoZVwiLFxuICAgICAgICBcIlgtUmVxdWVzdGVkLVdpdGhcIjogXCJYTUxIdHRwUmVxdWVzdFwiXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgRHJvcHpvbmUuZXh0ZW5kKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgICAgIHZhciBoZWFkZXJWYWx1ZSA9IGhlYWRlcnNbaGVhZGVyTmFtZV07XG4gICAgICAgIGlmIChoZWFkZXJWYWx1ZSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgLy8gQWRkaW5nIGFsbCBAb3B0aW9ucyBwYXJhbWV0ZXJzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFtcykge1xuICAgICAgICB2YXIgYWRkaXRpb25hbFBhcmFtcyA9IHRoaXMub3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIGlmICh0eXBlb2YgYWRkaXRpb25hbFBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGFkZGl0aW9uYWxQYXJhbXMgPSBhZGRpdGlvbmFsUGFyYW1zLmNhbGwodGhpcywgZmlsZXMsIHhociwgZmlsZXNbMF0udXBsb2FkLmNodW5rZWQgPyB0aGlzLl9nZXRDaHVuayhmaWxlc1swXSwgeGhyKSA6IG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGFkZGl0aW9uYWxQYXJhbXMpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhZGRpdGlvbmFsUGFyYW1zW2tleV07XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIExldCB0aGUgdXNlciBhZGQgYWRkaXRpb25hbCBkYXRhIGlmIG5lY2Vzc2FyeVxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMjMgPSBmaWxlcywgX2lzQXJyYXkyMyA9IHRydWUsIF9pMjUgPSAwLCBfaXRlcmF0b3IyMyA9IF9pc0FycmF5MjMgPyBfaXRlcmF0b3IyMyA6IF9pdGVyYXRvcjIzW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMjI7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5MjMpIHtcbiAgICAgICAgICBpZiAoX2kyNSA+PSBfaXRlcmF0b3IyMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYyMiA9IF9pdGVyYXRvcjIzW19pMjUrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kyNSA9IF9pdGVyYXRvcjIzLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kyNS5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMjIgPSBfaTI1LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9maWxlID0gX3JlZjIyO1xuXG4gICAgICAgIHRoaXMuZW1pdChcInNlbmRpbmdcIiwgX2ZpbGUsIHhociwgZm9ybURhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJzZW5kaW5nbXVsdGlwbGVcIiwgZmlsZXMsIHhociwgZm9ybURhdGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hZGRGb3JtRWxlbWVudERhdGEoZm9ybURhdGEpO1xuXG4gICAgICAvLyBGaW5hbGx5IGFkZCB0aGUgZmlsZXNcbiAgICAgIC8vIEhhcyB0byBiZSBsYXN0IGJlY2F1c2Ugc29tZSBzZXJ2ZXJzIChlZzogUzMpIGV4cGVjdCB0aGUgZmlsZSB0byBiZSB0aGUgbGFzdCBwYXJhbWV0ZXJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUJsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGF0YUJsb2NrID0gZGF0YUJsb2Nrc1tpXTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGRhdGFCbG9jay5uYW1lLCBkYXRhQmxvY2suZGF0YSwgZGF0YUJsb2NrLmZpbGVuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdWJtaXRSZXF1ZXN0KHhociwgZm9ybURhdGEsIGZpbGVzKTtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm1zIGFsbCBmaWxlcyB3aXRoIHRoaXMub3B0aW9ucy50cmFuc2Zvcm1GaWxlIGFuZCBpbnZva2VzIGRvbmUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgZmlsZXMgd2hlbiBkb25lLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyYW5zZm9ybUZpbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90cmFuc2Zvcm1GaWxlcyhmaWxlcywgZG9uZSkge1xuICAgICAgdmFyIF90aGlzMTYgPSB0aGlzO1xuXG4gICAgICB2YXIgdHJhbnNmb3JtZWRGaWxlcyA9IFtdO1xuICAgICAgLy8gQ2x1bXN5IHdheSBvZiBoYW5kbGluZyBhc3luY2hyb25vdXMgY2FsbHMsIHVudGlsIEkgZ2V0IHRvIGFkZCBhIHByb3BlciBGdXR1cmUgbGlicmFyeS5cbiAgICAgIHZhciBkb25lQ291bnRlciA9IDA7XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgX3RoaXMxNi5vcHRpb25zLnRyYW5zZm9ybUZpbGUuY2FsbChfdGhpczE2LCBmaWxlc1tpXSwgZnVuY3Rpb24gKHRyYW5zZm9ybWVkRmlsZSkge1xuICAgICAgICAgIHRyYW5zZm9ybWVkRmlsZXNbaV0gPSB0cmFuc2Zvcm1lZEZpbGU7XG4gICAgICAgICAgaWYgKCsrZG9uZUNvdW50ZXIgPT09IGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZG9uZSh0cmFuc2Zvcm1lZEZpbGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfbG9vcChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUYWtlcyBjYXJlIG9mIGFkZGluZyBvdGhlciBpbnB1dCBlbGVtZW50cyBvZiB0aGUgZm9ybSB0byB0aGUgQUpBWCByZXF1ZXN0XG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkRm9ybUVsZW1lbnREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRGb3JtRWxlbWVudERhdGEoZm9ybURhdGEpIHtcbiAgICAgIC8vIFRha2UgY2FyZSBvZiBvdGhlciBpbnB1dCBlbGVtZW50c1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC50YWdOYW1lID09PSBcIkZPUk1cIikge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyNCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QsIGJ1dHRvblwiKSwgX2lzQXJyYXkyNCA9IHRydWUsIF9pMjYgPSAwLCBfaXRlcmF0b3IyNCA9IF9pc0FycmF5MjQgPyBfaXRlcmF0b3IyNCA6IF9pdGVyYXRvcjI0W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgdmFyIF9yZWYyMztcblxuICAgICAgICAgIGlmIChfaXNBcnJheTI0KSB7XG4gICAgICAgICAgICBpZiAoX2kyNiA+PSBfaXRlcmF0b3IyNC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjIzID0gX2l0ZXJhdG9yMjRbX2kyNisrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kyNiA9IF9pdGVyYXRvcjI0Lm5leHQoKTtcbiAgICAgICAgICAgIGlmIChfaTI2LmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjIzID0gX2kyNi52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5wdXQgPSBfcmVmMjM7XG5cbiAgICAgICAgICB2YXIgaW5wdXROYW1lID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICAgICAgICB2YXIgaW5wdXRUeXBlID0gaW5wdXQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICAgICAgICBpZiAoaW5wdXRUeXBlKSBpbnB1dFR5cGUgPSBpbnB1dFR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgIC8vIElmIHRoZSBpbnB1dCBkb2Vzbid0IGhhdmUgYSBuYW1lLCB3ZSBjYW4ndCB1c2UgaXQuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dE5hbWUgPT09ICd1bmRlZmluZWQnIHx8IGlucHV0TmFtZSA9PT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgICAgICBpZiAoaW5wdXQudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIiAmJiBpbnB1dC5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSkge1xuICAgICAgICAgICAgLy8gUG9zc2libHkgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyNSA9IGlucHV0Lm9wdGlvbnMsIF9pc0FycmF5MjUgPSB0cnVlLCBfaTI3ID0gMCwgX2l0ZXJhdG9yMjUgPSBfaXNBcnJheTI1ID8gX2l0ZXJhdG9yMjUgOiBfaXRlcmF0b3IyNVtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgICAgICB2YXIgX3JlZjI0O1xuXG4gICAgICAgICAgICAgIGlmIChfaXNBcnJheTI1KSB7XG4gICAgICAgICAgICAgICAgaWYgKF9pMjcgPj0gX2l0ZXJhdG9yMjUubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICBfcmVmMjQgPSBfaXRlcmF0b3IyNVtfaTI3KytdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9pMjcgPSBfaXRlcmF0b3IyNS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKF9pMjcuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgX3JlZjI0ID0gX2kyNy52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBfcmVmMjQ7XG5cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChpbnB1dE5hbWUsIG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dFR5cGUgfHwgaW5wdXRUeXBlICE9PSBcImNoZWNrYm94XCIgJiYgaW5wdXRUeXBlICE9PSBcInJhZGlvXCIgfHwgaW5wdXQuY2hlY2tlZCkge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGlucHV0TmFtZSwgaW5wdXQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEludm9rZWQgd2hlbiB0aGVyZSBpcyBuZXcgcHJvZ3Jlc3MgaW5mb3JtYXRpb24gYWJvdXQgZ2l2ZW4gZmlsZXMuXG4gICAgLy8gSWYgZSBpcyBub3QgcHJvdmlkZWQsIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdXBsb2FkIGlzIGZpbmlzaGVkLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUZpbGVzVXBsb2FkUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUZpbGVzVXBsb2FkUHJvZ3Jlc3MoZmlsZXMsIHhociwgZSkge1xuICAgICAgdmFyIHByb2dyZXNzID0gdm9pZCAwO1xuICAgICAgaWYgKHR5cGVvZiBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9ncmVzcyA9IDEwMCAqIGUubG9hZGVkIC8gZS50b3RhbDtcblxuICAgICAgICBpZiAoZmlsZXNbMF0udXBsb2FkLmNodW5rZWQpIHtcbiAgICAgICAgICB2YXIgZmlsZSA9IGZpbGVzWzBdO1xuICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBjaHVua2VkIHVwbG9hZCwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGFwcHJvcHJpYXRlIGNodW5rIHByb2dyZXNzLlxuICAgICAgICAgIHZhciBjaHVuayA9IHRoaXMuX2dldENodW5rKGZpbGUsIHhocik7XG4gICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICBjaHVuay50b3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgY2h1bmsuYnl0ZXNTZW50ID0gZS5sb2FkZWQ7XG4gICAgICAgICAgdmFyIGZpbGVQcm9ncmVzcyA9IDAsXG4gICAgICAgICAgICAgIGZpbGVUb3RhbCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgZmlsZUJ5dGVzU2VudCA9IHZvaWQgMDtcbiAgICAgICAgICBmaWxlLnVwbG9hZC5wcm9ncmVzcyA9IDA7XG4gICAgICAgICAgZmlsZS51cGxvYWQudG90YWwgPSAwO1xuICAgICAgICAgIGZpbGUudXBsb2FkLmJ5dGVzU2VudCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlLnVwbG9hZC50b3RhbENodW5rQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZpbGUudXBsb2FkLmNodW5rc1tpXSAhPT0gdW5kZWZpbmVkICYmIGZpbGUudXBsb2FkLmNodW5rc1tpXS5wcm9ncmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZpbGUudXBsb2FkLnByb2dyZXNzICs9IGZpbGUudXBsb2FkLmNodW5rc1tpXS5wcm9ncmVzcztcbiAgICAgICAgICAgICAgZmlsZS51cGxvYWQudG90YWwgKz0gZmlsZS51cGxvYWQuY2h1bmtzW2ldLnRvdGFsO1xuICAgICAgICAgICAgICBmaWxlLnVwbG9hZC5ieXRlc1NlbnQgKz0gZmlsZS51cGxvYWQuY2h1bmtzW2ldLmJ5dGVzU2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZmlsZS51cGxvYWQucHJvZ3Jlc3MgPSBmaWxlLnVwbG9hZC5wcm9ncmVzcyAvIGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyNiA9IGZpbGVzLCBfaXNBcnJheTI2ID0gdHJ1ZSwgX2kyOCA9IDAsIF9pdGVyYXRvcjI2ID0gX2lzQXJyYXkyNiA/IF9pdGVyYXRvcjI2IDogX2l0ZXJhdG9yMjZbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICAgIHZhciBfcmVmMjU7XG5cbiAgICAgICAgICAgIGlmIChfaXNBcnJheTI2KSB7XG4gICAgICAgICAgICAgIGlmIChfaTI4ID49IF9pdGVyYXRvcjI2Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgIF9yZWYyNSA9IF9pdGVyYXRvcjI2W19pMjgrK107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfaTI4ID0gX2l0ZXJhdG9yMjYubmV4dCgpO1xuICAgICAgICAgICAgICBpZiAoX2kyOC5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgX3JlZjI1ID0gX2kyOC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9maWxlMiA9IF9yZWYyNTtcblxuICAgICAgICAgICAgX2ZpbGUyLnVwbG9hZC5wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgX2ZpbGUyLnVwbG9hZC50b3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICBfZmlsZTIudXBsb2FkLmJ5dGVzU2VudCA9IGUubG9hZGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyNyA9IGZpbGVzLCBfaXNBcnJheTI3ID0gdHJ1ZSwgX2kyOSA9IDAsIF9pdGVyYXRvcjI3ID0gX2lzQXJyYXkyNyA/IF9pdGVyYXRvcjI3IDogX2l0ZXJhdG9yMjdbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICB2YXIgX3JlZjI2O1xuXG4gICAgICAgICAgaWYgKF9pc0FycmF5MjcpIHtcbiAgICAgICAgICAgIGlmIChfaTI5ID49IF9pdGVyYXRvcjI3Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMjYgPSBfaXRlcmF0b3IyN1tfaTI5KytdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfaTI5ID0gX2l0ZXJhdG9yMjcubmV4dCgpO1xuICAgICAgICAgICAgaWYgKF9pMjkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMjYgPSBfaTI5LnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZmlsZTMgPSBfcmVmMjY7XG5cbiAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGxvYWRwcm9ncmVzc1wiLCBfZmlsZTMsIF9maWxlMy51cGxvYWQucHJvZ3Jlc3MsIF9maWxlMy51cGxvYWQuYnl0ZXNTZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGZpbGUgZmluaXNoZWQgdXBsb2FkaW5nXG5cbiAgICAgICAgdmFyIGFsbEZpbGVzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgIHByb2dyZXNzID0gMTAwO1xuXG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjI4ID0gZmlsZXMsIF9pc0FycmF5MjggPSB0cnVlLCBfaTMwID0gMCwgX2l0ZXJhdG9yMjggPSBfaXNBcnJheTI4ID8gX2l0ZXJhdG9yMjggOiBfaXRlcmF0b3IyOFtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgIHZhciBfcmVmMjc7XG5cbiAgICAgICAgICBpZiAoX2lzQXJyYXkyOCkge1xuICAgICAgICAgICAgaWYgKF9pMzAgPj0gX2l0ZXJhdG9yMjgubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgIF9yZWYyNyA9IF9pdGVyYXRvcjI4W19pMzArK107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9pMzAgPSBfaXRlcmF0b3IyOC5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoX2kzMC5kb25lKSBicmVhaztcbiAgICAgICAgICAgIF9yZWYyNyA9IF9pMzAudmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9maWxlNCA9IF9yZWYyNztcblxuICAgICAgICAgIGlmIChfZmlsZTQudXBsb2FkLnByb2dyZXNzICE9PSAxMDAgfHwgX2ZpbGU0LnVwbG9hZC5ieXRlc1NlbnQgIT09IF9maWxlNC51cGxvYWQudG90YWwpIHtcbiAgICAgICAgICAgIGFsbEZpbGVzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2ZpbGU0LnVwbG9hZC5wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgIF9maWxlNC51cGxvYWQuYnl0ZXNTZW50ID0gX2ZpbGU0LnVwbG9hZC50b3RhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8sIGFsbCBmaWxlcyBhbHJlYWR5IGF0IDEwMCVcbiAgICAgICAgaWYgKGFsbEZpbGVzRmluaXNoZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyOSA9IGZpbGVzLCBfaXNBcnJheTI5ID0gdHJ1ZSwgX2kzMSA9IDAsIF9pdGVyYXRvcjI5ID0gX2lzQXJyYXkyOSA/IF9pdGVyYXRvcjI5IDogX2l0ZXJhdG9yMjlbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICB2YXIgX3JlZjI4O1xuXG4gICAgICAgICAgaWYgKF9pc0FycmF5MjkpIHtcbiAgICAgICAgICAgIGlmIChfaTMxID49IF9pdGVyYXRvcjI5Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMjggPSBfaXRlcmF0b3IyOVtfaTMxKytdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfaTMxID0gX2l0ZXJhdG9yMjkubmV4dCgpO1xuICAgICAgICAgICAgaWYgKF9pMzEuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMjggPSBfaTMxLnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZmlsZTUgPSBfcmVmMjg7XG5cbiAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGxvYWRwcm9ncmVzc1wiLCBfZmlsZTUsIHByb2dyZXNzLCBfZmlsZTUudXBsb2FkLmJ5dGVzU2VudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmlzaGVkVXBsb2FkaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5pc2hlZFVwbG9hZGluZyhmaWxlcywgeGhyLCBlKSB7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChmaWxlc1swXS5zdGF0dXMgPT09IERyb3B6b25lLkNBTkNFTEVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHhoci5yZXNwb25zZVR5cGUgIT09ICdhcnJheWJ1ZmZlcicgJiYgeGhyLnJlc3BvbnNlVHlwZSAhPT0gJ2Jsb2InKSB7XG4gICAgICAgIHJlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dDtcblxuICAgICAgICBpZiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpICYmIH54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZSA9IGVycm9yO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBcIkludmFsaWQgSlNPTiByZXNwb25zZSBmcm9tIHNlcnZlci5cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXBkYXRlRmlsZXNVcGxvYWRQcm9ncmVzcyhmaWxlcyk7XG5cbiAgICAgIGlmICghKDIwMCA8PSB4aHIuc3RhdHVzICYmIHhoci5zdGF0dXMgPCAzMDApKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVVwbG9hZEVycm9yKGZpbGVzLCB4aHIsIHJlc3BvbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmaWxlc1swXS51cGxvYWQuY2h1bmtlZCkge1xuICAgICAgICAgIGZpbGVzWzBdLnVwbG9hZC5maW5pc2hlZENodW5rVXBsb2FkKHRoaXMuX2dldENodW5rKGZpbGVzWzBdLCB4aHIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9maW5pc2hlZChmaWxlcywgcmVzcG9uc2UsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVVcGxvYWRFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVXBsb2FkRXJyb3IoZmlsZXMsIHhociwgcmVzcG9uc2UpIHtcbiAgICAgIGlmIChmaWxlc1swXS5zdGF0dXMgPT09IERyb3B6b25lLkNBTkNFTEVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGVzWzBdLnVwbG9hZC5jaHVua2VkICYmIHRoaXMub3B0aW9ucy5yZXRyeUNodW5rcykge1xuICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLl9nZXRDaHVuayhmaWxlc1swXSwgeGhyKTtcbiAgICAgICAgaWYgKGNodW5rLnJldHJpZXMrKyA8IHRoaXMub3B0aW9ucy5yZXRyeUNodW5rc0xpbWl0KSB7XG4gICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YShmaWxlcywgW2NodW5rLmRhdGFCbG9ja10pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1JldHJpZWQgdGhpcyBjaHVuayB0b28gb2Z0ZW4uIEdpdmluZyB1cC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzMCA9IGZpbGVzLCBfaXNBcnJheTMwID0gdHJ1ZSwgX2kzMiA9IDAsIF9pdGVyYXRvcjMwID0gX2lzQXJyYXkzMCA/IF9pdGVyYXRvcjMwIDogX2l0ZXJhdG9yMzBbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgdmFyIF9yZWYyOTtcblxuICAgICAgICBpZiAoX2lzQXJyYXkzMCkge1xuICAgICAgICAgIGlmIChfaTMyID49IF9pdGVyYXRvcjMwLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjI5ID0gX2l0ZXJhdG9yMzBbX2kzMisrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTMyID0gX2l0ZXJhdG9yMzAubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTMyLmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYyOSA9IF9pMzIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsZSA9IF9yZWYyOTtcblxuICAgICAgICB0aGlzLl9lcnJvclByb2Nlc3NpbmcoZmlsZXMsIHJlc3BvbnNlIHx8IHRoaXMub3B0aW9ucy5kaWN0UmVzcG9uc2VFcnJvci5yZXBsYWNlKFwie3tzdGF0dXNDb2RlfX1cIiwgeGhyLnN0YXR1cyksIHhocik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1Ym1pdFJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VibWl0UmVxdWVzdCh4aHIsIGZvcm1EYXRhLCBmaWxlcykge1xuICAgICAgeGhyLnNlbmQoZm9ybURhdGEpO1xuICAgIH1cblxuICAgIC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gcHJvY2Vzc2luZyBpcyBmaW5pc2hlZC5cbiAgICAvLyBJbmRpdmlkdWFsIGNhbGxiYWNrcyBoYXZlIHRvIGJlIGNhbGxlZCBpbiB0aGUgYXBwcm9wcmlhdGUgc2VjdGlvbnMuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZmluaXNoZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmlzaGVkKGZpbGVzLCByZXNwb25zZVRleHQsIGUpIHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMxID0gZmlsZXMsIF9pc0FycmF5MzEgPSB0cnVlLCBfaTMzID0gMCwgX2l0ZXJhdG9yMzEgPSBfaXNBcnJheTMxID8gX2l0ZXJhdG9yMzEgOiBfaXRlcmF0b3IzMVtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICB2YXIgX3JlZjMwO1xuXG4gICAgICAgIGlmIChfaXNBcnJheTMxKSB7XG4gICAgICAgICAgaWYgKF9pMzMgPj0gX2l0ZXJhdG9yMzEubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmMzAgPSBfaXRlcmF0b3IzMVtfaTMzKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pMzMgPSBfaXRlcmF0b3IzMS5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pMzMuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZjMwID0gX2kzMy52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWxlID0gX3JlZjMwO1xuXG4gICAgICAgIGZpbGUuc3RhdHVzID0gRHJvcHpvbmUuU1VDQ0VTUztcbiAgICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc1wiLCBmaWxlLCByZXNwb25zZVRleHQsIGUpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCBmaWxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc211bHRpcGxlXCIsIGZpbGVzLCByZXNwb25zZVRleHQsIGUpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZW11bHRpcGxlXCIsIGZpbGVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUHJvY2Vzc1F1ZXVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gcHJvY2Vzc2luZyBpcyBmaW5pc2hlZC5cbiAgICAvLyBJbmRpdmlkdWFsIGNhbGxiYWNrcyBoYXZlIHRvIGJlIGNhbGxlZCBpbiB0aGUgYXBwcm9wcmlhdGUgc2VjdGlvbnMuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXJyb3JQcm9jZXNzaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lcnJvclByb2Nlc3NpbmcoZmlsZXMsIG1lc3NhZ2UsIHhocikge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMzIgPSBmaWxlcywgX2lzQXJyYXkzMiA9IHRydWUsIF9pMzQgPSAwLCBfaXRlcmF0b3IzMiA9IF9pc0FycmF5MzIgPyBfaXRlcmF0b3IzMiA6IF9pdGVyYXRvcjMyW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMzE7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5MzIpIHtcbiAgICAgICAgICBpZiAoX2kzNCA+PSBfaXRlcmF0b3IzMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgIF9yZWYzMSA9IF9pdGVyYXRvcjMyW19pMzQrK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2kzNCA9IF9pdGVyYXRvcjMyLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kzNC5kb25lKSBicmVhaztcbiAgICAgICAgICBfcmVmMzEgPSBfaTM0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbGUgPSBfcmVmMzE7XG5cbiAgICAgICAgZmlsZS5zdGF0dXMgPSBEcm9wem9uZS5FUlJPUjtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZmlsZSwgbWVzc2FnZSwgeGhyKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29tcGxldGVcIiwgZmlsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImVycm9ybXVsdGlwbGVcIiwgZmlsZXMsIG1lc3NhZ2UsIHhocik7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbXBsZXRlbXVsdGlwbGVcIiwgZmlsZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9Qcm9jZXNzUXVldWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwidXVpZHY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHV1aWR2NCgpIHtcbiAgICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcbiAgICAgICAgICAgIHYgPSBjID09PSAneCcgPyByIDogciAmIDB4MyB8IDB4ODtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERyb3B6b25lO1xufShFbWl0dGVyKTtcblxuRHJvcHpvbmUuaW5pdENsYXNzKCk7XG5cbkRyb3B6b25lLnZlcnNpb24gPSBcIjUuNS4xXCI7XG5cbi8vIFRoaXMgaXMgYSBtYXAgb2Ygb3B0aW9ucyBmb3IgeW91ciBkaWZmZXJlbnQgZHJvcHpvbmVzLiBBZGQgY29uZmlndXJhdGlvbnNcbi8vIHRvIHRoaXMgb2JqZWN0IGZvciB5b3VyIGRpZmZlcmVudCBkcm9wem9uZSBlbGVtZW5zLlxuLy9cbi8vIEV4YW1wbGU6XG4vL1xuLy8gICAgIERyb3B6b25lLm9wdGlvbnMubXlEcm9wem9uZUVsZW1lbnRJZCA9IHsgbWF4RmlsZXNpemU6IDEgfTtcbi8vXG4vLyBUbyBkaXNhYmxlIGF1dG9EaXNjb3ZlciBmb3IgYSBzcGVjaWZpYyBlbGVtZW50LCB5b3UgY2FuIHNldCBgZmFsc2VgIGFzIGFuIG9wdGlvbjpcbi8vXG4vLyAgICAgRHJvcHpvbmUub3B0aW9ucy5teURpc2FibGVkRWxlbWVudElkID0gZmFsc2U7XG4vL1xuLy8gQW5kIGluIGh0bWw6XG4vL1xuLy8gICAgIDxmb3JtIGFjdGlvbj1cIi91cGxvYWRcIiBpZD1cIm15LWRyb3B6b25lLWVsZW1lbnQtaWRcIiBjbGFzcz1cImRyb3B6b25lXCI+PC9mb3JtPlxuRHJvcHpvbmUub3B0aW9ucyA9IHt9O1xuXG4vLyBSZXR1cm5zIHRoZSBvcHRpb25zIGZvciBhbiBlbGVtZW50IG9yIHVuZGVmaW5lZCBpZiBub25lIGF2YWlsYWJsZS5cbkRyb3B6b25lLm9wdGlvbnNGb3JFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgLy8gR2V0IHRoZSBgRHJvcHpvbmUub3B0aW9ucy5lbGVtZW50SWRgIGZvciB0aGlzIGVsZW1lbnQgaWYgaXQgZXhpc3RzXG4gIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpKSB7XG4gICAgcmV0dXJuIERyb3B6b25lLm9wdGlvbnNbY2FtZWxpemUoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbi8vIEhvbGRzIGEgbGlzdCBvZiBhbGwgZHJvcHpvbmUgaW5zdGFuY2VzXG5Ecm9wem9uZS5pbnN0YW5jZXMgPSBbXTtcblxuLy8gUmV0dXJucyB0aGUgZHJvcHpvbmUgZm9yIGdpdmVuIGVsZW1lbnQgaWYgYW55XG5Ecm9wem9uZS5mb3JFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG4gIH1cbiAgaWYgKChlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50LmRyb3B6b25lIDogdW5kZWZpbmVkKSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gRHJvcHpvbmUgZm91bmQgZm9yIGdpdmVuIGVsZW1lbnQuIFRoaXMgaXMgcHJvYmFibHkgYmVjYXVzZSB5b3UncmUgdHJ5aW5nIHRvIGFjY2VzcyBpdCBiZWZvcmUgRHJvcHpvbmUgaGFkIHRoZSB0aW1lIHRvIGluaXRpYWxpemUuIFVzZSB0aGUgYGluaXRgIG9wdGlvbiB0byBzZXR1cCBhbnkgYWRkaXRpb25hbCBvYnNlcnZlcnMgb24geW91ciBEcm9wem9uZS5cIik7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQuZHJvcHpvbmU7XG59O1xuXG4vLyBTZXQgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnQgRHJvcHpvbmUgdG8gYXV0b21hdGljYWxseSBmaW5kIGFuZCBhdHRhY2ggdG8gLmRyb3B6b25lIGVsZW1lbnRzLlxuRHJvcHpvbmUuYXV0b0Rpc2NvdmVyID0gdHJ1ZTtcblxuLy8gTG9va3MgZm9yIGFsbCAuZHJvcHpvbmUgZWxlbWVudHMgYW5kIGNyZWF0ZXMgYSBkcm9wem9uZSBmb3IgdGhlbVxuRHJvcHpvbmUuZGlzY292ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkcm9wem9uZXMgPSB2b2lkIDA7XG4gIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgZHJvcHpvbmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5kcm9wem9uZVwiKTtcbiAgfSBlbHNlIHtcbiAgICBkcm9wem9uZXMgPSBbXTtcbiAgICAvLyBJRSA6KFxuICAgIHZhciBjaGVja0VsZW1lbnRzID0gZnVuY3Rpb24gY2hlY2tFbGVtZW50cyhlbGVtZW50cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzMyA9IGVsZW1lbnRzLCBfaXNBcnJheTMzID0gdHJ1ZSwgX2kzNSA9IDAsIF9pdGVyYXRvcjMzID0gX2lzQXJyYXkzMyA/IF9pdGVyYXRvcjMzIDogX2l0ZXJhdG9yMzNbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICB2YXIgX3JlZjMyO1xuXG4gICAgICAgICAgaWYgKF9pc0FycmF5MzMpIHtcbiAgICAgICAgICAgIGlmIChfaTM1ID49IF9pdGVyYXRvcjMzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMzIgPSBfaXRlcmF0b3IzM1tfaTM1KytdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfaTM1ID0gX2l0ZXJhdG9yMzMubmV4dCgpO1xuICAgICAgICAgICAgaWYgKF9pMzUuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMzIgPSBfaTM1LnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbCA9IF9yZWYzMjtcblxuICAgICAgICAgIGlmICgvKF58IClkcm9wem9uZSgkfCApLy50ZXN0KGVsLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRyb3B6b25lcy5wdXNoKGVsKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KCk7XG4gICAgfTtcbiAgICBjaGVja0VsZW1lbnRzKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpKTtcbiAgICBjaGVja0VsZW1lbnRzKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZm9ybVwiKSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IzNCA9IGRyb3B6b25lcywgX2lzQXJyYXkzNCA9IHRydWUsIF9pMzYgPSAwLCBfaXRlcmF0b3IzNCA9IF9pc0FycmF5MzQgPyBfaXRlcmF0b3IzNCA6IF9pdGVyYXRvcjM0W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICB2YXIgX3JlZjMzO1xuXG4gICAgICBpZiAoX2lzQXJyYXkzNCkge1xuICAgICAgICBpZiAoX2kzNiA+PSBfaXRlcmF0b3IzNC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmMzMgPSBfaXRlcmF0b3IzNFtfaTM2KytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kzNiA9IF9pdGVyYXRvcjM0Lm5leHQoKTtcbiAgICAgICAgaWYgKF9pMzYuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYzMyA9IF9pMzYudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkcm9wem9uZSA9IF9yZWYzMztcblxuICAgICAgLy8gQ3JlYXRlIGEgZHJvcHpvbmUgdW5sZXNzIGF1dG8gZGlzY292ZXIgaGFzIGJlZW4gZGlzYWJsZWQgZm9yIHNwZWNpZmljIGVsZW1lbnRcbiAgICAgIGlmIChEcm9wem9uZS5vcHRpb25zRm9yRWxlbWVudChkcm9wem9uZSkgIT09IGZhbHNlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEcm9wem9uZShkcm9wem9uZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2godW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSgpO1xufTtcblxuLy8gU2luY2UgdGhlIHdob2xlIERyYWcnbidEcm9wIEFQSSBpcyBwcmV0dHkgbmV3LCBzb21lIGJyb3dzZXJzIGltcGxlbWVudCBpdCxcbi8vIGJ1dCBub3QgY29ycmVjdGx5LlxuLy8gU28gSSBjcmVhdGVkIGEgYmxhY2tsaXN0IG9mIHVzZXJBZ2VudHMuIFllcywgeWVzLiBCcm93c2VyIHNuaWZmaW5nLCBJIGtub3cuXG4vLyBCdXQgd2hhdCB0byBkbyB3aGVuIGJyb3dzZXJzICp0aGVvcmV0aWNhbGx5KiBzdXBwb3J0IGFuIEFQSSwgYnV0IGNyYXNoXG4vLyB3aGVuIHVzaW5nIGl0LlxuLy9cbi8vIFRoaXMgaXMgYSBsaXN0IG9mIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGVzdGVkIGFnYWluc3QgbmF2aWdhdG9yLnVzZXJBZ2VudFxuLy9cbi8vICoqIEl0IHNob3VsZCBvbmx5IGJlIHVzZWQgb24gYnJvd3NlciB0aGF0ICpkbyogc3VwcG9ydCB0aGUgQVBJLCBidXRcbi8vIGluY29ycmVjdGx5ICoqXG4vL1xuRHJvcHpvbmUuYmxhY2tsaXN0ZWRCcm93c2VycyA9IFtcbi8vIFRoZSBtYWMgb3MgYW5kIHdpbmRvd3MgcGhvbmUgdmVyc2lvbiBvZiBvcGVyYSAxMiBzZWVtcyB0byBoYXZlIGEgcHJvYmxlbSB3aXRoIHRoZSBGaWxlIGRyYWcnbidkcm9wIEFQSS5cbi9vcGVyYS4qKE1hY2ludG9zaHxXaW5kb3dzIFBob25lKS4qdmVyc2lvblxcLzEyL2ldO1xuXG4vLyBDaGVja3MgaWYgdGhlIGJyb3dzZXIgaXMgc3VwcG9ydGVkXG5Ecm9wem9uZS5pc0Jyb3dzZXJTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjYXBhYmxlQnJvd3NlciA9IHRydWU7XG5cbiAgaWYgKHdpbmRvdy5GaWxlICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlTGlzdCAmJiB3aW5kb3cuQmxvYiAmJiB3aW5kb3cuRm9ybURhdGEgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcikge1xuICAgIGlmICghKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikpKSB7XG4gICAgICBjYXBhYmxlQnJvd3NlciA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJLCBidXQgbWF5IGJlIGJsYWNrbGlzdGVkLlxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMzUgPSBEcm9wem9uZS5ibGFja2xpc3RlZEJyb3dzZXJzLCBfaXNBcnJheTM1ID0gdHJ1ZSwgX2kzNyA9IDAsIF9pdGVyYXRvcjM1ID0gX2lzQXJyYXkzNSA/IF9pdGVyYXRvcjM1IDogX2l0ZXJhdG9yMzVbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgdmFyIF9yZWYzNDtcblxuICAgICAgICBpZiAoX2lzQXJyYXkzNSkge1xuICAgICAgICAgIGlmIChfaTM3ID49IF9pdGVyYXRvcjM1Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjM0ID0gX2l0ZXJhdG9yMzVbX2kzNysrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTM3ID0gX2l0ZXJhdG9yMzUubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTM3LmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYzNCA9IF9pMzcudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVnZXggPSBfcmVmMzQ7XG5cbiAgICAgICAgaWYgKHJlZ2V4LnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICBjYXBhYmxlQnJvd3NlciA9IGZhbHNlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNhcGFibGVCcm93c2VyID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY2FwYWJsZUJyb3dzZXI7XG59O1xuXG5Ecm9wem9uZS5kYXRhVVJJdG9CbG9iID0gZnVuY3Rpb24gKGRhdGFVUkkpIHtcbiAgLy8gY29udmVydCBiYXNlNjQgdG8gcmF3IGJpbmFyeSBkYXRhIGhlbGQgaW4gYSBzdHJpbmdcbiAgLy8gZG9lc24ndCBoYW5kbGUgVVJMRW5jb2RlZCBEYXRhVVJJcyAtIHNlZSBTTyBhbnN3ZXIgIzY4NTAyNzYgZm9yIGNvZGUgdGhhdCBkb2VzIHRoaXNcbiAgdmFyIGJ5dGVTdHJpbmcgPSBhdG9iKGRhdGFVUkkuc3BsaXQoJywnKVsxXSk7XG5cbiAgLy8gc2VwYXJhdGUgb3V0IHRoZSBtaW1lIGNvbXBvbmVudFxuICB2YXIgbWltZVN0cmluZyA9IGRhdGFVUkkuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF07XG5cbiAgLy8gd3JpdGUgdGhlIGJ5dGVzIG9mIHRoZSBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXJcbiAgdmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcbiAgdmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICBmb3IgKHZhciBpID0gMCwgZW5kID0gYnl0ZVN0cmluZy5sZW5ndGgsIGFzYyA9IDAgPD0gZW5kOyBhc2MgPyBpIDw9IGVuZCA6IGkgPj0gZW5kOyBhc2MgPyBpKysgOiBpLS0pIHtcbiAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuXG4gIC8vIHdyaXRlIHRoZSBBcnJheUJ1ZmZlciB0byBhIGJsb2JcbiAgcmV0dXJuIG5ldyBCbG9iKFthYl0sIHsgdHlwZTogbWltZVN0cmluZyB9KTtcbn07XG5cbi8vIFJldHVybnMgYW4gYXJyYXkgd2l0aG91dCB0aGUgcmVqZWN0ZWQgaXRlbVxudmFyIHdpdGhvdXQgPSBmdW5jdGlvbiB3aXRob3V0KGxpc3QsIHJlamVjdGVkSXRlbSkge1xuICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSAhPT0gcmVqZWN0ZWRJdGVtO1xuICB9KS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSk7XG59O1xuXG4vLyBhYmMtZGVmX2doaSAtPiBhYmNEZWZHaGlcbnZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXC1fXShcXHcpL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBtYXRjaC5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59O1xuXG4vLyBDcmVhdGVzIGFuIGVsZW1lbnQgZnJvbSBzdHJpbmdcbkRyb3B6b25lLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBkaXYuaW5uZXJIVE1MID0gc3RyaW5nO1xuICByZXR1cm4gZGl2LmNoaWxkTm9kZXNbMF07XG59O1xuXG4vLyBUZXN0cyBpZiBnaXZlbiBlbGVtZW50IGlzIGluc2lkZSAob3Igc2ltcGx5IGlzKSB0aGUgY29udGFpbmVyXG5Ecm9wem9uZS5lbGVtZW50SW5zaWRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lcikge1xuICBpZiAoZWxlbWVudCA9PT0gY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gQ29mZmVlc2NyaXB0IGRvZXNuJ3Qgc3VwcG9ydCBkby93aGlsZSBsb29wc1xuICB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgIGlmIChlbGVtZW50ID09PSBjb250YWluZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ecm9wem9uZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7XG4gIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICB9IGVsc2UgaWYgKGVsLm5vZGVUeXBlICE9IG51bGwpIHtcbiAgICBlbGVtZW50ID0gZWw7XG4gIH1cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYFwiICsgbmFtZSArIFwiYCBvcHRpb24gcHJvdmlkZWQuIFBsZWFzZSBwcm92aWRlIGEgQ1NTIHNlbGVjdG9yIG9yIGEgcGxhaW4gSFRNTCBlbGVtZW50LlwiKTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbkRyb3B6b25lLmdldEVsZW1lbnRzID0gZnVuY3Rpb24gKGVscywgbmFtZSkge1xuICB2YXIgZWwgPSB2b2lkIDAsXG4gICAgICBlbGVtZW50cyA9IHZvaWQgMDtcbiAgaWYgKGVscyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgZWxlbWVudHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMzYgPSBlbHMsIF9pc0FycmF5MzYgPSB0cnVlLCBfaTM4ID0gMCwgX2l0ZXJhdG9yMzYgPSBfaXNBcnJheTM2ID8gX2l0ZXJhdG9yMzYgOiBfaXRlcmF0b3IzNltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICBpZiAoX2lzQXJyYXkzNikge1xuICAgICAgICAgIGlmIChfaTM4ID49IF9pdGVyYXRvcjM2Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgZWwgPSBfaXRlcmF0b3IzNltfaTM4KytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pMzggPSBfaXRlcmF0b3IzNi5uZXh0KCk7XG4gICAgICAgICAgaWYgKF9pMzguZG9uZSkgYnJlYWs7XG4gICAgICAgICAgZWwgPSBfaTM4LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLmdldEVsZW1lbnQoZWwsIG5hbWUpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlbGVtZW50cyA9IG51bGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBlbGVtZW50cyA9IFtdO1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjM3ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbHMpLCBfaXNBcnJheTM3ID0gdHJ1ZSwgX2kzOSA9IDAsIF9pdGVyYXRvcjM3ID0gX2lzQXJyYXkzNyA/IF9pdGVyYXRvcjM3IDogX2l0ZXJhdG9yMzdbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgIGlmIChfaXNBcnJheTM3KSB7XG4gICAgICAgIGlmIChfaTM5ID49IF9pdGVyYXRvcjM3Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIGVsID0gX2l0ZXJhdG9yMzdbX2kzOSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pMzkgPSBfaXRlcmF0b3IzNy5uZXh0KCk7XG4gICAgICAgIGlmIChfaTM5LmRvbmUpIGJyZWFrO1xuICAgICAgICBlbCA9IF9pMzkudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRzLnB1c2goZWwpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbHMubm9kZVR5cGUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnRzID0gW2Vsc107XG4gIH1cblxuICBpZiAoZWxlbWVudHMgPT0gbnVsbCB8fCAhZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBgXCIgKyBuYW1lICsgXCJgIG9wdGlvbiBwcm92aWRlZC4gUGxlYXNlIHByb3ZpZGUgYSBDU1Mgc2VsZWN0b3IsIGEgcGxhaW4gSFRNTCBlbGVtZW50IG9yIGEgbGlzdCBvZiB0aG9zZS5cIik7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudHM7XG59O1xuXG4vLyBBc2tzIHRoZSB1c2VyIHRoZSBxdWVzdGlvbiBhbmQgY2FsbHMgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQgYWNjb3JkaW5nbHlcbi8vXG4vLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0IHVzZXMgYHdpbmRvdy5jb25maXJtYCBhbmQgdGhlbiBjYWxscyB0aGVcbi8vIGFwcHJvcHJpYXRlIGNhbGxiYWNrLlxuRHJvcHpvbmUuY29uZmlybSA9IGZ1bmN0aW9uIChxdWVzdGlvbiwgYWNjZXB0ZWQsIHJlamVjdGVkKSB7XG4gIGlmICh3aW5kb3cuY29uZmlybShxdWVzdGlvbikpIHtcbiAgICByZXR1cm4gYWNjZXB0ZWQoKTtcbiAgfSBlbHNlIGlmIChyZWplY3RlZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHJlamVjdGVkKCk7XG4gIH1cbn07XG5cbi8vIFZhbGlkYXRlcyB0aGUgbWltZSB0eXBlIGxpa2UgdGhpczpcbi8vXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvRWxlbWVudC9pbnB1dCNhdHRyLWFjY2VwdFxuRHJvcHpvbmUuaXNWYWxpZEZpbGUgPSBmdW5jdGlvbiAoZmlsZSwgYWNjZXB0ZWRGaWxlcykge1xuICBpZiAoIWFjY2VwdGVkRmlsZXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiB0aGVyZSBhcmUgbm8gYWNjZXB0ZWQgbWltZSB0eXBlcywgaXQncyBPS1xuICBhY2NlcHRlZEZpbGVzID0gYWNjZXB0ZWRGaWxlcy5zcGxpdChcIixcIik7XG5cbiAgdmFyIG1pbWVUeXBlID0gZmlsZS50eXBlO1xuICB2YXIgYmFzZU1pbWVUeXBlID0gbWltZVR5cGUucmVwbGFjZSgvXFwvLiokLywgXCJcIik7XG5cbiAgZm9yICh2YXIgX2l0ZXJhdG9yMzggPSBhY2NlcHRlZEZpbGVzLCBfaXNBcnJheTM4ID0gdHJ1ZSwgX2k0MCA9IDAsIF9pdGVyYXRvcjM4ID0gX2lzQXJyYXkzOCA/IF9pdGVyYXRvcjM4IDogX2l0ZXJhdG9yMzhbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICB2YXIgX3JlZjM1O1xuXG4gICAgaWYgKF9pc0FycmF5MzgpIHtcbiAgICAgIGlmIChfaTQwID49IF9pdGVyYXRvcjM4Lmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmMzUgPSBfaXRlcmF0b3IzOFtfaTQwKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaTQwID0gX2l0ZXJhdG9yMzgubmV4dCgpO1xuICAgICAgaWYgKF9pNDAuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmMzUgPSBfaTQwLnZhbHVlO1xuICAgIH1cblxuICAgIHZhciB2YWxpZFR5cGUgPSBfcmVmMzU7XG5cbiAgICB2YWxpZFR5cGUgPSB2YWxpZFR5cGUudHJpbSgpO1xuICAgIGlmICh2YWxpZFR5cGUuY2hhckF0KDApID09PSBcIi5cIikge1xuICAgICAgaWYgKGZpbGUubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsaWRUeXBlLnRvTG93ZXJDYXNlKCksIGZpbGUubmFtZS5sZW5ndGggLSB2YWxpZFR5cGUubGVuZ3RoKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgvXFwvXFwqJC8udGVzdCh2YWxpZFR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHNvbWV0aGluZyBsaWtlIGEgaW1hZ2UvKiBtaW1lIHR5cGVcbiAgICAgIGlmIChiYXNlTWltZVR5cGUgPT09IHZhbGlkVHlwZS5yZXBsYWNlKC9cXC8uKiQvLCBcIlwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1pbWVUeXBlID09PSB2YWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gQXVnbWVudCBqUXVlcnlcbmlmICh0eXBlb2YgalF1ZXJ5ICE9PSAndW5kZWZpbmVkJyAmJiBqUXVlcnkgIT09IG51bGwpIHtcbiAgalF1ZXJ5LmZuLmRyb3B6b25lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRHJvcHpvbmUodGhpcywgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH07XG59XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUgIT09IG51bGwpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBEcm9wem9uZTtcbn0gZWxzZSB7XG4gIHdpbmRvdy5Ecm9wem9uZSA9IERyb3B6b25lO1xufVxuXG4vLyBEcm9wem9uZSBmaWxlIHN0YXR1cyBjb2Rlc1xuRHJvcHpvbmUuQURERUQgPSBcImFkZGVkXCI7XG5cbkRyb3B6b25lLlFVRVVFRCA9IFwicXVldWVkXCI7XG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIE5vdywgaWYgYSBmaWxlIGlzIGFjY2VwdGVkLCBpdCdzIGVpdGhlciBxdWV1ZWRcbi8vIG9yIHVwbG9hZGluZy5cbkRyb3B6b25lLkFDQ0VQVEVEID0gRHJvcHpvbmUuUVVFVUVEO1xuXG5Ecm9wem9uZS5VUExPQURJTkcgPSBcInVwbG9hZGluZ1wiO1xuRHJvcHpvbmUuUFJPQ0VTU0lORyA9IERyb3B6b25lLlVQTE9BRElORzsgLy8gYWxpYXNcblxuRHJvcHpvbmUuQ0FOQ0VMRUQgPSBcImNhbmNlbGVkXCI7XG5Ecm9wem9uZS5FUlJPUiA9IFwiZXJyb3JcIjtcbkRyb3B6b25lLlNVQ0NFU1MgPSBcInN1Y2Nlc3NcIjtcblxuLypcblxuIEJ1Z2ZpeCBmb3IgaU9TIDYgYW5kIDdcbiBTb3VyY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE5MjkwOTkvaHRtbDUtY2FudmFzLWRyYXdpbWFnZS1yYXRpby1idWctaW9zXG4gYmFzZWQgb24gdGhlIHdvcmsgb2YgaHR0cHM6Ly9naXRodWIuY29tL3N0b21pdGEvaW9zLWltYWdlZmlsZS1tZWdhcGl4ZWxcblxuICovXG5cbi8vIERldGVjdGluZyB2ZXJ0aWNhbCBzcXVhc2ggaW4gbG9hZGVkIGltYWdlLlxuLy8gRml4ZXMgYSBidWcgd2hpY2ggc3F1YXNoIGltYWdlIHZlcnRpY2FsbHkgd2hpbGUgZHJhd2luZyBpbnRvIGNhbnZhcyBmb3Igc29tZSBpbWFnZXMuXG4vLyBUaGlzIGlzIGEgYnVnIGluIGlPUzYgZGV2aWNlcy4gVGhpcyBmdW5jdGlvbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zdG9taXRhL2lvcy1pbWFnZWZpbGUtbWVnYXBpeGVsXG52YXIgZGV0ZWN0VmVydGljYWxTcXVhc2ggPSBmdW5jdGlvbiBkZXRlY3RWZXJ0aWNhbFNxdWFzaChpbWcpIHtcbiAgdmFyIGl3ID0gaW1nLm5hdHVyYWxXaWR0aDtcbiAgdmFyIGloID0gaW1nLm5hdHVyYWxIZWlnaHQ7XG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMud2lkdGggPSAxO1xuICBjYW52YXMuaGVpZ2h0ID0gaWg7XG4gIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG5cbiAgdmFyIF9jdHgkZ2V0SW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgxLCAwLCAxLCBpaCksXG4gICAgICBkYXRhID0gX2N0eCRnZXRJbWFnZURhdGEuZGF0YTtcblxuICAvLyBzZWFyY2ggaW1hZ2UgZWRnZSBwaXhlbCBwb3NpdGlvbiBpbiBjYXNlIGl0IGlzIHNxdWFzaGVkIHZlcnRpY2FsbHkuXG5cblxuICB2YXIgc3kgPSAwO1xuICB2YXIgZXkgPSBpaDtcbiAgdmFyIHB5ID0gaWg7XG4gIHdoaWxlIChweSA+IHN5KSB7XG4gICAgdmFyIGFscGhhID0gZGF0YVsocHkgLSAxKSAqIDQgKyAzXTtcblxuICAgIGlmIChhbHBoYSA9PT0gMCkge1xuICAgICAgZXkgPSBweTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3kgPSBweTtcbiAgICB9XG5cbiAgICBweSA9IGV5ICsgc3kgPj4gMTtcbiAgfVxuICB2YXIgcmF0aW8gPSBweSAvIGloO1xuXG4gIGlmIChyYXRpbyA9PT0gMCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByYXRpbztcbiAgfVxufTtcblxuLy8gQSByZXBsYWNlbWVudCBmb3IgY29udGV4dC5kcmF3SW1hZ2Vcbi8vIChhcmdzIGFyZSBmb3Igc291cmNlIGFuZCBkZXN0aW5hdGlvbikuXG52YXIgZHJhd0ltYWdlSU9TRml4ID0gZnVuY3Rpb24gZHJhd0ltYWdlSU9TRml4KGN0eCwgaW1nLCBzeCwgc3ksIHN3LCBzaCwgZHgsIGR5LCBkdywgZGgpIHtcbiAgdmFyIHZlcnRTcXVhc2hSYXRpbyA9IGRldGVjdFZlcnRpY2FsU3F1YXNoKGltZyk7XG4gIHJldHVybiBjdHguZHJhd0ltYWdlKGltZywgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSwgZHcsIGRoIC8gdmVydFNxdWFzaFJhdGlvKTtcbn07XG5cbi8vIEJhc2VkIG9uIE1pbmlmeUpwZWdcbi8vIFNvdXJjZTogaHR0cDovL3d3dy5wZXJyeS5jei9maWxlcy9FeGlmUmVzdG9yZXIuanNcbi8vIGh0dHA6Ly9lbGljb24uYmxvZzU3LmZjMi5jb20vYmxvZy1lbnRyeS0yMDYuaHRtbFxuXG52YXIgRXhpZlJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4aWZSZXN0b3JlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeGlmUmVzdG9yZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXhpZlJlc3RvcmUsIG51bGwsIFt7XG4gICAga2V5OiBcImluaXRDbGFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Q2xhc3MoKSB7XG4gICAgICB0aGlzLktFWV9TVFIgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmNvZGU2NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGU2NChpbnB1dCkge1xuICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgdmFyIGNocjEgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2hyMiA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBjaHIzID0gJyc7XG4gICAgICB2YXIgZW5jMSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBlbmMyID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGVuYzMgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgZW5jNCA9ICcnO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgICAgIGNocjIgPSBpbnB1dFtpKytdO1xuICAgICAgICBjaHIzID0gaW5wdXRbaSsrXTtcbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9IChjaHIxICYgMykgPDwgNCB8IGNocjIgPj4gNDtcbiAgICAgICAgZW5jMyA9IChjaHIyICYgMTUpIDw8IDIgfCBjaHIzID4+IDY7XG4gICAgICAgIGVuYzQgPSBjaHIzICYgNjM7XG4gICAgICAgIGlmIChpc05hTihjaHIyKSkge1xuICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oY2hyMykpIHtcbiAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmMxKSArIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jMikgKyB0aGlzLktFWV9TVFIuY2hhckF0KGVuYzMpICsgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmM0KTtcbiAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gJyc7XG4gICAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSAnJztcbiAgICAgICAgaWYgKCEoaSA8IGlucHV0Lmxlbmd0aCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzdG9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlKG9yaWdGaWxlQmFzZTY0LCByZXNpemVkRmlsZUJhc2U2NCkge1xuICAgICAgaWYgKCFvcmlnRmlsZUJhc2U2NC5tYXRjaCgnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnKSkge1xuICAgICAgICByZXR1cm4gcmVzaXplZEZpbGVCYXNlNjQ7XG4gICAgICB9XG4gICAgICB2YXIgcmF3SW1hZ2UgPSB0aGlzLmRlY29kZTY0KG9yaWdGaWxlQmFzZTY0LnJlcGxhY2UoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJywgJycpKTtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2xpY2UyU2VnbWVudHMocmF3SW1hZ2UpO1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5leGlmTWFuaXB1bGF0aW9uKHJlc2l6ZWRGaWxlQmFzZTY0LCBzZWdtZW50cyk7XG4gICAgICByZXR1cm4gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiICsgdGhpcy5lbmNvZGU2NChpbWFnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4aWZNYW5pcHVsYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhpZk1hbmlwdWxhdGlvbihyZXNpemVkRmlsZUJhc2U2NCwgc2VnbWVudHMpIHtcbiAgICAgIHZhciBleGlmQXJyYXkgPSB0aGlzLmdldEV4aWZBcnJheShzZWdtZW50cyk7XG4gICAgICB2YXIgbmV3SW1hZ2VBcnJheSA9IHRoaXMuaW5zZXJ0RXhpZihyZXNpemVkRmlsZUJhc2U2NCwgZXhpZkFycmF5KTtcbiAgICAgIHZhciBhQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3SW1hZ2VBcnJheSk7XG4gICAgICByZXR1cm4gYUJ1ZmZlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RXhpZkFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEV4aWZBcnJheShzZWdtZW50cykge1xuICAgICAgdmFyIHNlZyA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHdoaWxlICh4IDwgc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHNlZyA9IHNlZ21lbnRzW3hdO1xuICAgICAgICBpZiAoc2VnWzBdID09PSAyNTUgJiBzZWdbMV0gPT09IDIyNSkge1xuICAgICAgICAgIHJldHVybiBzZWc7XG4gICAgICAgIH1cbiAgICAgICAgeCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRFeGlmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEV4aWYocmVzaXplZEZpbGVCYXNlNjQsIGV4aWZBcnJheSkge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IHJlc2l6ZWRGaWxlQmFzZTY0LnJlcGxhY2UoJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJywgJycpO1xuICAgICAgdmFyIGJ1ZiA9IHRoaXMuZGVjb2RlNjQoaW1hZ2VEYXRhKTtcbiAgICAgIHZhciBzZXBhcmF0ZVBvaW50ID0gYnVmLmluZGV4T2YoMjU1LCAzKTtcbiAgICAgIHZhciBtYWUgPSBidWYuc2xpY2UoMCwgc2VwYXJhdGVQb2ludCk7XG4gICAgICB2YXIgYXRvID0gYnVmLnNsaWNlKHNlcGFyYXRlUG9pbnQpO1xuICAgICAgdmFyIGFycmF5ID0gbWFlO1xuICAgICAgYXJyYXkgPSBhcnJheS5jb25jYXQoZXhpZkFycmF5KTtcbiAgICAgIGFycmF5ID0gYXJyYXkuY29uY2F0KGF0byk7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNsaWNlMlNlZ21lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlMlNlZ21lbnRzKHJhd0ltYWdlQXJyYXkpIHtcbiAgICAgIHZhciBoZWFkID0gMDtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgaWYgKHJhd0ltYWdlQXJyYXlbaGVhZF0gPT09IDI1NSAmIHJhd0ltYWdlQXJyYXlbaGVhZCArIDFdID09PSAyMTgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmF3SW1hZ2VBcnJheVtoZWFkXSA9PT0gMjU1ICYgcmF3SW1hZ2VBcnJheVtoZWFkICsgMV0gPT09IDIxNikge1xuICAgICAgICAgIGhlYWQgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSByYXdJbWFnZUFycmF5W2hlYWQgKyAyXSAqIDI1NiArIHJhd0ltYWdlQXJyYXlbaGVhZCArIDNdO1xuICAgICAgICAgIHZhciBlbmRQb2ludCA9IGhlYWQgKyBsZW5ndGggKyAyO1xuICAgICAgICAgIHZhciBzZWcgPSByYXdJbWFnZUFycmF5LnNsaWNlKGhlYWQsIGVuZFBvaW50KTtcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZyk7XG4gICAgICAgICAgaGVhZCA9IGVuZFBvaW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkID4gcmF3SW1hZ2VBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlZ21lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGU2NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGU2NChpbnB1dCkge1xuICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgdmFyIGNocjEgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgY2hyMiA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBjaHIzID0gJyc7XG4gICAgICB2YXIgZW5jMSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBlbmMyID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGVuYzMgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgZW5jNCA9ICcnO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGJ1ZiA9IFtdO1xuICAgICAgLy8gcmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBBLVosIGEteiwgMC05LCArLCAvLCBvciA9XG4gICAgICB2YXIgYmFzZTY0dGVzdCA9IC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZztcbiAgICAgIGlmIChiYXNlNjR0ZXN0LmV4ZWMoaW5wdXQpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlcmUgd2VyZSBpbnZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGluIHRoZSBpbnB1dCB0ZXh0LlxcblZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGFyZSBBLVosIGEteiwgMC05LCBcXCcrXFwnLCBcXCcvXFwnLGFuZCBcXCc9XFwnXFxuRXhwZWN0IGVycm9ycyBpbiBkZWNvZGluZy4nKTtcbiAgICAgIH1cbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGVuYzEgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzMgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGNocjEgPSBlbmMxIDw8IDIgfCBlbmMyID4+IDQ7XG4gICAgICAgIGNocjIgPSAoZW5jMiAmIDE1KSA8PCA0IHwgZW5jMyA+PiAyO1xuICAgICAgICBjaHIzID0gKGVuYzMgJiAzKSA8PCA2IHwgZW5jNDtcbiAgICAgICAgYnVmLnB1c2goY2hyMSk7XG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgIGJ1Zi5wdXNoKGNocjIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmM0ICE9PSA2NCkge1xuICAgICAgICAgIGJ1Zi5wdXNoKGNocjMpO1xuICAgICAgICB9XG4gICAgICAgIGNocjEgPSBjaHIyID0gY2hyMyA9ICcnO1xuICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gJyc7XG4gICAgICAgIGlmICghKGkgPCBpbnB1dC5sZW5ndGgpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV4aWZSZXN0b3JlO1xufSgpO1xuXG5FeGlmUmVzdG9yZS5pbml0Q2xhc3MoKTtcblxuLypcbiAqIGNvbnRlbnRsb2FkZWQuanNcbiAqXG4gKiBBdXRob3I6IERpZWdvIFBlcmluaSAoZGllZ28ucGVyaW5pIGF0IGdtYWlsLmNvbSlcbiAqIFN1bW1hcnk6IGNyb3NzLWJyb3dzZXIgd3JhcHBlciBmb3IgRE9NQ29udGVudExvYWRlZFxuICogVXBkYXRlZDogMjAxMDEwMjBcbiAqIExpY2Vuc2U6IE1JVFxuICogVmVyc2lvbjogMS4yXG4gKlxuICogVVJMOlxuICogaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0NvbnRlbnRMb2FkZWQvXG4gKiBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vQ29udGVudExvYWRlZC9NSVQtTElDRU5TRVxuICovXG5cbi8vIEB3aW4gd2luZG93IHJlZmVyZW5jZVxuLy8gQGZuIGZ1bmN0aW9uIHJlZmVyZW5jZVxudmFyIGNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiBjb250ZW50TG9hZGVkKHdpbiwgZm4pIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdmFyIHRvcCA9IHRydWU7XG4gIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIHZhciByb290ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGFkZCA9IGRvYy5hZGRFdmVudExpc3RlbmVyID8gXCJhZGRFdmVudExpc3RlbmVyXCIgOiBcImF0dGFjaEV2ZW50XCI7XG4gIHZhciByZW0gPSBkb2MuYWRkRXZlbnRMaXN0ZW5lciA/IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiIDogXCJkZXRhY2hFdmVudFwiO1xuICB2YXIgcHJlID0gZG9jLmFkZEV2ZW50TGlzdGVuZXIgPyBcIlwiIDogXCJvblwiO1xuICB2YXIgaW5pdCA9IGZ1bmN0aW9uIGluaXQoZSkge1xuICAgIGlmIChlLnR5cGUgPT09IFwicmVhZHlzdGF0ZWNoYW5nZVwiICYmIGRvYy5yZWFkeVN0YXRlICE9PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKGUudHlwZSA9PT0gXCJsb2FkXCIgPyB3aW4gOiBkb2MpW3JlbV0ocHJlICsgZS50eXBlLCBpbml0LCBmYWxzZSk7XG4gICAgaWYgKCFkb25lICYmIChkb25lID0gdHJ1ZSkpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHdpbiwgZS50eXBlIHx8IGUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcG9sbCA9IGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJvb3QuZG9TY3JvbGwoXCJsZWZ0XCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNldFRpbWVvdXQocG9sbCwgNTApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdChcInBvbGxcIik7XG4gIH07XG5cbiAgaWYgKGRvYy5yZWFkeVN0YXRlICE9PSBcImNvbXBsZXRlXCIpIHtcbiAgICBpZiAoZG9jLmNyZWF0ZUV2ZW50T2JqZWN0ICYmIHJvb3QuZG9TY3JvbGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRvcCA9ICF3aW4uZnJhbWVFbGVtZW50O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICBpZiAodG9wKSB7XG4gICAgICAgIHBvbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZG9jW2FkZF0ocHJlICsgXCJET01Db250ZW50TG9hZGVkXCIsIGluaXQsIGZhbHNlKTtcbiAgICBkb2NbYWRkXShwcmUgKyBcInJlYWR5c3RhdGVjaGFuZ2VcIiwgaW5pdCwgZmFsc2UpO1xuICAgIHJldHVybiB3aW5bYWRkXShwcmUgKyBcImxvYWRcIiwgaW5pdCwgZmFsc2UpO1xuICB9XG59O1xuXG4vLyBBcyBhIHNpbmdsZSBmdW5jdGlvbiB0byBiZSBhYmxlIHRvIHdyaXRlIHRlc3RzLlxuRHJvcHpvbmUuX2F1dG9EaXNjb3ZlckZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICBpZiAoRHJvcHpvbmUuYXV0b0Rpc2NvdmVyKSB7XG4gICAgcmV0dXJuIERyb3B6b25lLmRpc2NvdmVyKCk7XG4gIH1cbn07XG5jb250ZW50TG9hZGVkKHdpbmRvdywgRHJvcHpvbmUuX2F1dG9EaXNjb3ZlckZ1bmN0aW9uKTtcblxuZnVuY3Rpb24gX19ndWFyZF9fKHZhbHVlLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IG51bGwgPyB0cmFuc2Zvcm0odmFsdWUpIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gX19ndWFyZE1ldGhvZF9fKG9iaiwgbWV0aG9kTmFtZSwgdHJhbnNmb3JtKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJyAmJiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9ialttZXRob2ROYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cmFuc2Zvcm0ob2JqLCBtZXRob2ROYW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/dropzone/dist/dropzone.js\n");

/***/ }),

/***/ "./node_modules/nestable2/jquery.nestable.js":
/*!***************************************************!*\
  !*** ./node_modules/nestable2/jquery.nestable.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Nestable jQuery Plugin - Copyright (c) 2014 Ramon Smit - https://github.com/RamonSmit/Nestable\n */\n\n(function($, window, document, undefined) {\n    var hasTouch = 'ontouchstart' in document;\n\n    /**\n     * Detect CSS pointer-events property\n     * events are normally disabled on the dragging element to avoid conflicts\n     * https://github.com/ausi/Feature-detection-technique-for-pointer-events/blob/master/modernizr-pointerevents.js\n     */\n    var hasPointerEvents = (function() {\n        var el = document.createElement('div'),\n            docEl = document.documentElement;\n        if (!('pointerEvents' in el.style)) {\n            return false;\n        }\n        el.style.pointerEvents = 'auto';\n        el.style.pointerEvents = 'x';\n        docEl.appendChild(el);\n        var supports = window.getComputedStyle && window.getComputedStyle(el, '').pointerEvents === 'auto';\n        docEl.removeChild(el);\n        return !!supports;\n    })();\n\n    var defaults = {\n        contentCallback: function(item) {return item.content || '' ? item.content : item.id;},\n        listNodeName: 'ol',\n        itemNodeName: 'li',\n        handleNodeName: 'div',\n        contentNodeName: 'span',\n        rootClass: 'dd',\n        listClass: 'dd-list',\n        itemClass: 'dd-item',\n        dragClass: 'dd-dragel',\n        handleClass: 'dd-handle',\n        contentClass: 'dd-content',\n        collapsedClass: 'dd-collapsed',\n        placeClass: 'dd-placeholder',\n        noDragClass: 'dd-nodrag',\n        noChildrenClass: 'dd-nochildren',\n        emptyClass: 'dd-empty',\n        expandBtnHTML: '<button class=\"dd-expand\" data-action=\"expand\" type=\"button\">Expand</button>',\n        collapseBtnHTML: '<button class=\"dd-collapse\" data-action=\"collapse\" type=\"button\">Collapse</button>',\n        group: 0,\n        maxDepth: 5,\n        threshold: 20,\n        fixedDepth: false, //fixed item's depth\n        fixed: false,\n        includeContent: false,\n        scroll: false,\n        scrollSensitivity: 1,\n        scrollSpeed: 5,\n        scrollTriggers: {\n            top: 40,\n            left: 40,\n            right: -40,\n            bottom: -40\n        },\n        effect: {\n            animation: 'none',\n            time: 'slow'\n        },\n        callback: function(l, e, p) {},\n        onDragStart: function(l, e, p) {},\n        beforeDragStop: function(l, e, p) {},\n        listRenderer: function(children, options) {\n            var html = '<' + options.listNodeName + ' class=\"' + options.listClass + '\">';\n            html += children;\n            html += '</' + options.listNodeName + '>';\n\n            return html;\n        },\n        itemRenderer: function(item_attrs, content, children, options, item) {\n            var item_attrs_string = $.map(item_attrs, function(value, key) {\n                return ' ' + key + '=\"' + value + '\"';\n            }).join(' ');\n\n            var html = '<' + options.itemNodeName + item_attrs_string + '>';\n            html += '<' + options.handleNodeName + ' class=\"' + options.handleClass + '\">';\n            html += '<' + options.contentNodeName + ' class=\"' + options.contentClass + '\">';\n            html += content;\n            html += '</' + options.contentNodeName + '>';\n            html += '</' + options.handleNodeName + '>';\n            html += children;\n            html += '</' + options.itemNodeName + '>';\n\n            return html;\n        }\n    };\n\n    function Plugin(element, options) {\n        this.w  = $(document);\n        this.el = $(element);\n        options = options || defaults;\n\n        if (options.rootClass !== undefined && options.rootClass !== 'dd') {\n            options.listClass       = options.listClass ? options.listClass : options.rootClass + '-list';\n            options.itemClass       = options.itemClass ? options.itemClass : options.rootClass + '-item';\n            options.dragClass       = options.dragClass ? options.dragClass : options.rootClass + '-dragel';\n            options.handleClass     = options.handleClass ? options.handleClass : options.rootClass + '-handle';\n            options.collapsedClass  = options.collapsedClass ? options.collapsedClass : options.rootClass + '-collapsed';\n            options.placeClass      = options.placeClass ? options.placeClass : options.rootClass + '-placeholder';\n            options.noDragClass     = options.noDragClass ? options.noDragClass : options.rootClass + '-nodrag';\n            options.noChildrenClass = options.noChildrenClass ? options.noChildrenClass : options.rootClass + '-nochildren';\n            options.emptyClass      = options.emptyClass ? options.emptyClass : options.rootClass + '-empty';\n        }\n\n        this.options = $.extend({}, defaults, options);\n\n        // build HTML from serialized JSON if passed\n        if (this.options.json !== undefined) {\n            this._build();\n        }\n\n        this.init();\n    }\n\n    Plugin.prototype = {\n\n        init: function() {\n            var list = this;\n\n            list.reset();\n            list.el.data('nestable-group', this.options.group);\n            list.placeEl = $('<div class=\"' + list.options.placeClass + '\"/>');\n\n            var items = this.el.find(list.options.itemNodeName);\n            $.each(items, function(k, el) {\n                var item = $(el),\n                    parent = item.parent();\n                list.setParent(item);\n                if (parent.hasClass(list.options.collapsedClass)) {\n                    list.collapseItem(parent.parent());\n                }\n            });\n\n            // Append the .dd-empty div if the list don't have any items on init\n            if (!items.length) {\n                this.appendEmptyElement(this.el);\n            }\n\n            list.el.on('click', 'button', function(e) {\n                if (list.dragEl) {\n                    return;\n                }\n                var target = $(e.currentTarget),\n                    action = target.data('action'),\n                    item = target.parents(list.options.itemNodeName).eq(0);\n                if (action === 'collapse') {\n                    list.collapseItem(item);\n                }\n                if (action === 'expand') {\n                    list.expandItem(item);\n                }\n            });\n\n            var onStartEvent = function(e) {\n                var handle = $(e.target);\n                if (!handle.hasClass(list.options.handleClass)) {\n                    if (handle.closest('.' + list.options.noDragClass).length) {\n                        return;\n                    }\n                    handle = handle.closest('.' + list.options.handleClass);\n                }\n                if (!handle.length || list.dragEl) {\n                    return;\n                }\n\n                list.isTouch = /^touch/.test(e.type);\n                if (list.isTouch && e.touches.length !== 1) {\n                    return;\n                }\n\n                e.preventDefault();\n                list.dragStart(e.touches ? e.touches[0] : e);\n            };\n\n            var onMoveEvent = function(e) {\n                if (list.dragEl) {\n                    e.preventDefault();\n                    list.dragMove(e.touches ? e.touches[0] : e);\n                }\n            };\n\n            var onEndEvent = function(e) {\n                if (list.dragEl) {\n                    e.preventDefault();\n                    list.dragStop(e.touches ? e.changedTouches[0] : e);\n                }\n            };\n\n            if (hasTouch) {\n                list.el[0].addEventListener('touchstart', onStartEvent, false);\n                window.addEventListener('touchmove', onMoveEvent, false);\n                window.addEventListener('touchend', onEndEvent, false);\n                window.addEventListener('touchcancel', onEndEvent, false);\n            }\n\n            list.el.on('mousedown', onStartEvent);\n            list.w.on('mousemove', onMoveEvent);\n            list.w.on('mouseup', onEndEvent);\n\n            var destroyNestable = function()\n            {\n                if (hasTouch) {\n                    list.el[0].removeEventListener('touchstart', onStartEvent, false);\n                    window.removeEventListener('touchmove', onMoveEvent, false);\n                    window.removeEventListener('touchend', onEndEvent, false);\n                    window.removeEventListener('touchcancel', onEndEvent, false);\n                }\n\n                list.el.off('mousedown', onStartEvent);\n                list.w.off('mousemove', onMoveEvent);\n                list.w.off('mouseup', onEndEvent);\n\n                list.el.off('click');\n                list.el.unbind('destroy-nestable');\n\n                list.el.data(\"nestable\", null);\n            };\n\n            list.el.bind('destroy-nestable', destroyNestable);\n\n        },\n\n        destroy: function ()\n        {\n            this.el.trigger('destroy-nestable');\n        },\n\n        add: function (item)\n        {\n            var listClassSelector = '.' + this.options.listClass;\n            var tree = $(this.el).children(listClassSelector);\n\n            if (item.parent_id !== undefined) {\n                tree = tree.find('[data-id=\"' + item.parent_id + '\"]');\n                delete item.parent_id;\n\n                if (tree.children(listClassSelector).length === 0) {\n                    tree = tree.append(this.options.listRenderer('', this.options));\n                }\n\n                tree = tree.find(listClassSelector + ':first');\n                this.setParent(tree.parent());\n            }\n\n            tree.append(this._buildItem(item, this.options));\n        },\n\n        replace: function (item)\n        {\n            var html = this._buildItem(item, this.options);\n\n            this._getItemById(item.id)\n                .replaceWith(html);\n        },\n\n        //removes item and additional elements from list\n        removeItem: function (item){\n            var opts = this.options,\n                el   = this.el;\n\n            // remove item\n            item = item || this;\n            item.remove();\n\n            // remove empty children lists\n            var emptyListsSelector = '.' + opts.listClass\n                + ' .' + opts.listClass + ':not(:has(*))';\n            $(el).find(emptyListsSelector).remove();\n\n            // remove buttons if parents do not have children\n            var buttonsSelector = '[data-action=\"expand\"], [data-action=\"collapse\"]';\n            $(el).find(buttonsSelector).each(function() {\n                var siblings = $(this).siblings('.' + opts.listClass);\n                if (siblings.length === 0) {\n                    $(this).remove();\n                }\n            });\n        },\n\n        //removes item by itemId and run callback at the end\n        remove: function (itemId, callback)\n        {\n            var opts = this.options;\n            var list = this;\n            var item = this._getItemById(itemId);\n\n            //animation style\n            var animation = opts.effect.animation || 'fade';\n\n            //animation time\n            var time = opts.effect.time || 'slow';\n\n            //add fadeOut effect when removing\n            if (animation === 'fade'){\n                item.fadeOut(time, function(){\n                    list.removeItem(item);\n                });\n            }\n            else {\n                this.removeItem(item);\n            }\n\n            if (callback) callback();\n        },\n\n        //removes all items from the list and run callback at the end\n        removeAll: function(callback){\n\n            var list  = this,\n                opts  = this.options,\n                node  = list.el.find(opts.listNodeName).first(),\n                items = node.children(opts.itemNodeName);\n\n            //animation style\n            var animation = opts.effect.animation || 'fade';\n\n            //animation time\n            var time = opts.effect.time || 'slow';\n\n            function remove(){\n                //Removes each item and its children.\n                items.each(function() {\n                    list.removeItem($(this));\n                });\n                //Now we can again show our node element\n                node.show();\n                if (callback) callback();\n            }\n\n            //add fadeOut effect when removing\n            if (animation === 'fade'){\n                node.fadeOut(time, remove);\n            }\n            else {\n                remove();\n            }\n        },\n\n        _getItemById: function(itemId) {\n            return $(this.el).children('.' + this.options.listClass)\n                .find('[data-id=\"' + itemId + '\"]');\n        },\n\n        _build: function() {\n            var json = this.options.json;\n\n            if (typeof json === 'string') {\n                json = JSON.parse(json);\n            }\n\n            $(this.el).html(this._buildList(json, this.options));\n        },\n\n        _buildList: function(items, options) {\n            if (!items) {\n                return '';\n            }\n\n            var children = '';\n            var that = this;\n\n            $.each(items, function(index, sub) {\n                children += that._buildItem(sub, options);\n            });\n\n            return options.listRenderer(children, options);\n        },\n\n        _buildItem: function(item, options) {\n            function escapeHtml(text) {\n                var map = {\n                    '&': '&amp;',\n                    '<': '&lt;',\n                    '>': '&gt;',\n                    '\"': '&quot;',\n                    \"'\": '&#039;'\n                };\n\n                return text + \"\".replace(/[&<>\"']/g, function(m) { return map[m]; });\n            }\n\n            function filterClasses(classes) {\n                var new_classes = {};\n\n                for (var k in classes) {\n                    // Remove duplicates\n                    new_classes[classes[k]] = classes[k];\n                }\n\n                return new_classes;\n            }\n\n            function createClassesString(item, options) {\n                var classes = item.classes || {};\n\n                if (typeof classes === 'string') {\n                    classes = [classes];\n                }\n\n                var item_classes = filterClasses(classes);\n                item_classes[options.itemClass] = options.itemClass;\n\n                // create class string\n                return $.map(item_classes, function(val) {\n                    return val;\n                }).join(' ');\n            }\n\n            function createDataAttrs(attr) {\n                attr = $.extend({}, attr);\n\n                delete attr.children;\n                delete attr.classes;\n                delete attr.content;\n\n                var data_attrs = {};\n\n                $.each(attr, function(key, value) {\n                    if (typeof value === 'object') {\n                        value = JSON.stringify(value);\n                    }\n\n                    data_attrs[\"data-\" + key] = escapeHtml(value);\n                });\n\n                return data_attrs;\n            }\n\n            var item_attrs = createDataAttrs(item);\n            item_attrs[\"class\"] = createClassesString(item, options);\n\n            var content = options.contentCallback(item);\n            var children = this._buildList(item.children, options);\n            var html = $(options.itemRenderer(item_attrs, content, children, options, item));\n\n            this.setParent(html);\n\n            return html[0].outerHTML;\n        },\n\n        serialize: function() {\n            var data, list = this, step = function(level) {\n                var array = [],\n                    items = level.children(list.options.itemNodeName);\n                items.each(function() {\n                    var li = $(this),\n                        item = $.extend({}, li.data()),\n                        sub = li.children(list.options.listNodeName);\n\n                    if (list.options.includeContent) {\n                        var content = li.find('.' + list.options.contentClass).html();\n\n                        if (content) {\n                            item.content = content;\n                        }\n                    }\n\n                    if (sub.length) {\n                        item.children = step(sub);\n                    }\n                    array.push(item);\n                });\n                return array;\n            };\n            data = step(list.el.find(list.options.listNodeName).first());\n            return data;\n        },\n\n        asNestedSet: function() {\n            var list = this, o = list.options, depth = -1, ret = [], lft = 1;\n            var items = list.el.find(o.listNodeName).first().children(o.itemNodeName);\n\n            items.each(function () {\n                lft = traverse(this, depth + 1, lft);\n            });\n\n            ret = ret.sort(function(a,b){ return (a.lft - b.lft); });\n            return ret;\n\n            function traverse(item, depth, lft) {\n                var rgt = lft + 1, id, pid;\n\n                if ($(item).children(o.listNodeName).children(o.itemNodeName).length > 0 ) {\n                    depth++;\n                    $(item).children(o.listNodeName).children(o.itemNodeName).each(function () {\n                        rgt = traverse($(this), depth, rgt);\n                    });\n                    depth--;\n                }\n\n                id = $(item).attr('data-id');\n                if (isInt(id)) {\n                    id = parseInt(id);\n                }\n\n                pid = $(item).parent(o.listNodeName).parent(o.itemNodeName).attr('data-id') || '';\n                if (isInt(pid)) {\n                    id = parseInt(pid);\n                }\n\n                if (id) {\n                    ret.push({\"id\": id, \"parent_id\": pid, \"depth\": depth, \"lft\": lft, \"rgt\": rgt});\n                }\n\n                lft = rgt + 1;\n                return lft;\n            }\n\n            function isInt(value) {\n                return $.isNumeric(value) && Math.floor(value) == value;\n            }\n        },\n\n        returnOptions: function() {\n            return this.options;\n        },\n\n        serialise: function() {\n            return this.serialize();\n        },\n\n        toHierarchy: function(options) {\n\n            var o = $.extend({}, this.options, options),\n                ret = [];\n\n            $(this.element).children(o.items).each(function() {\n                var level = _recursiveItems(this);\n                ret.push(level);\n            });\n\n            return ret;\n\n            function _recursiveItems(item) {\n                var id = ($(item).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));\n                if (id) {\n                    var currentItem = {\n                        \"id\": id[2]\n                    };\n                    if ($(item).children(o.listType).children(o.items).length > 0) {\n                        currentItem.children = [];\n                        $(item).children(o.listType).children(o.items).each(function() {\n                            var level = _recursiveItems(this);\n                            currentItem.children.push(level);\n                        });\n                    }\n                    return currentItem;\n                }\n            }\n        },\n\n        toArray: function() {\n\n            var o = $.extend({}, this.options, this),\n                sDepth = o.startDepthCount || 0,\n                ret = [],\n                left = 2,\n                list = this,\n                element = list.el.find(list.options.listNodeName).first();\n\n            var items = element.children(list.options.itemNodeName);\n            items.each(function() {\n                left = _recursiveArray($(this), sDepth + 1, left);\n            });\n\n            ret = ret.sort(function(a, b) {\n                return (a.left - b.left);\n            });\n\n            return ret;\n\n            function _recursiveArray(item, depth, left) {\n\n                var right = left + 1,\n                    id,\n                    pid;\n\n                if (item.children(o.options.listNodeName).children(o.options.itemNodeName).length > 0) {\n                    depth++;\n                    item.children(o.options.listNodeName).children(o.options.itemNodeName).each(function() {\n                        right = _recursiveArray($(this), depth, right);\n                    });\n                    depth--;\n                }\n\n                id = item.data().id;\n\n\n                if (depth === sDepth + 1) {\n                    pid = o.rootID;\n                } else {\n\n                    var parentItem = (item.parent(o.options.listNodeName)\n                        .parent(o.options.itemNodeName)\n                        .data());\n                    pid = parentItem.id;\n\n                }\n\n                if (id) {\n                    ret.push({\n                        \"id\": id,\n                        \"parent_id\": pid,\n                        \"depth\": depth,\n                        \"left\": left,\n                        \"right\": right\n                    });\n                }\n\n                left = right + 1;\n                return left;\n            }\n\n        },\n\n        reset: function() {\n            this.mouse = {\n                offsetX: 0,\n                offsetY: 0,\n                startX: 0,\n                startY: 0,\n                lastX: 0,\n                lastY: 0,\n                nowX: 0,\n                nowY: 0,\n                distX: 0,\n                distY: 0,\n                dirAx: 0,\n                dirX: 0,\n                dirY: 0,\n                lastDirX: 0,\n                lastDirY: 0,\n                distAxX: 0,\n                distAxY: 0\n            };\n            this.isTouch = false;\n            this.moving = false;\n            this.dragEl = null;\n            this.dragRootEl = null;\n            this.dragDepth = 0;\n            this.hasNewRoot = false;\n            this.pointEl = null;\n        },\n\n        expandItem: function(li) {\n            li.removeClass(this.options.collapsedClass);\n        },\n\n        collapseItem: function(li) {\n            var lists = li.children(this.options.listNodeName);\n            if (lists.length) {\n                li.addClass(this.options.collapsedClass);\n            }\n        },\n\n        expandAll: function() {\n            var list = this;\n            list.el.find(list.options.itemNodeName).each(function() {\n                list.expandItem($(this));\n            });\n        },\n\n        collapseAll: function() {\n            var list = this;\n            list.el.find(list.options.itemNodeName).each(function() {\n                list.collapseItem($(this));\n            });\n        },\n\n        setParent: function(li) {\n            //Check if li is an element of itemNodeName type and has children\n            if (li.is(this.options.itemNodeName) && li.children(this.options.listNodeName).length) {\n                // make sure NOT showing two or more sets data-action buttons\n                li.children('[data-action]').remove();\n                li.prepend($(this.options.expandBtnHTML));\n                li.prepend($(this.options.collapseBtnHTML));\n            }\n        },\n\n        unsetParent: function(li) {\n            li.removeClass(this.options.collapsedClass);\n            li.children('[data-action]').remove();\n            li.children(this.options.listNodeName).remove();\n        },\n\n        dragStart: function(e) {\n            var mouse = this.mouse,\n                target = $(e.target),\n                dragItem = target.closest(this.options.itemNodeName),\n                position = {\n                    top  : e.pageY,\n                    left : e.pageX\n                };\n\n            var continueExecution = this.options.onDragStart.call(this, this.el, dragItem, position);\n\n            if (typeof continueExecution !== 'undefined' && continueExecution === false) {\n                return;\n            }\n\n            this.placeEl.css('height', dragItem.height());\n\n            mouse.offsetX = e.pageX - dragItem.offset().left;\n            mouse.offsetY = e.pageY - dragItem.offset().top;\n            mouse.startX = mouse.lastX = e.pageX;\n            mouse.startY = mouse.lastY = e.pageY;\n\n            this.dragRootEl = this.el;\n            this.dragEl = $(document.createElement(this.options.listNodeName)).addClass(this.options.listClass + ' ' + this.options.dragClass);\n            this.dragEl.css('width', dragItem.outerWidth());\n\n            this.setIndexOfItem(dragItem);\n\n            // fix for zepto.js\n            //dragItem.after(this.placeEl).detach().appendTo(this.dragEl);\n            dragItem.after(this.placeEl);\n            dragItem[0].parentNode.removeChild(dragItem[0]);\n            dragItem.appendTo(this.dragEl);\n\n            $(document.body).append(this.dragEl);\n            this.dragEl.css({\n                'left': e.pageX - mouse.offsetX,\n                'top': e.pageY - mouse.offsetY\n            });\n            // total depth of dragging item\n            var i, depth,\n                items = this.dragEl.find(this.options.itemNodeName);\n            for (i = 0; i < items.length; i++) {\n                depth = $(items[i]).parents(this.options.listNodeName).length;\n                if (depth > this.dragDepth) {\n                    this.dragDepth = depth;\n                }\n            }\n        },\n\n        //Create sublevel.\n        //  element : element which become parent\n        //  item    : something to place into new sublevel\n        createSubLevel: function(element, item) {\n            var list = $('<' + this.options.listNodeName + '/>').addClass(this.options.listClass);\n            if (item) list.append(item);\n            element.append(list);\n            this.setParent(element);\n            return list;\n        },\n\n        setIndexOfItem: function(item, index) {\n            index = index || [];\n\n            index.unshift(item.index());\n\n            if ($(item[0].parentNode)[0] !== this.dragRootEl[0]) {\n                this.setIndexOfItem($(item[0].parentNode), index);\n            }\n            else {\n                this.dragEl.data('indexOfItem', index);\n            }\n        },\n\n        restoreItemAtIndex: function(dragElement, indexArray) {\n            var currentEl = this.el,\n                lastIndex = indexArray.length - 1;\n\n            //Put drag element at current element position.\n            function placeElement(currentEl, dragElement) {\n                if (indexArray[lastIndex] === 0) {\n                    $(currentEl).prepend(dragElement.clone(true)); //using true saves added to element events.\n                }\n                else {\n                    $(currentEl.children[indexArray[lastIndex] - 1]).after(dragElement.clone(true)); //using true saves added to element events.\n                }\n            }\n            //Diggin through indexArray to get home for dragElement.\n            for (var i = 0; i < indexArray.length; i++) {\n                if (lastIndex === parseInt(i)) {\n                    placeElement(currentEl, dragElement);\n                    return;\n                }\n                //element can have no indexes, so we have to use conditional here to avoid errors.\n                //if element doesn't exist we defenetly need to add new list.\n                var element = (currentEl[0]) ? currentEl[0] : currentEl;\n                var nextEl  = element.children[indexArray[i]];\n                currentEl   = (!nextEl) ? this.createSubLevel($(element)) : nextEl;\n            }\n        },\n\n        dragStop: function(e) {\n            // fix for zepto.js\n            //this.placeEl.replaceWith(this.dragEl.children(this.options.itemNodeName + ':first').detach());\n            var position = {\n                top  : e.pageY,\n                left : e.pageX\n            };\n            //Get indexArray of item at drag start.\n            var srcIndex = this.dragEl.data('indexOfItem');\n\n            var el = this.dragEl.children(this.options.itemNodeName).first();\n\n            el[0].parentNode.removeChild(el[0]);\n\n            this.dragEl.remove(); //Remove dragEl, cause it can affect on indexing in html collection.\n\n            //Before drag stop callback\n            var continueExecution = this.options.beforeDragStop.call(this, this.el, el, this.placeEl.parent());\n            if (typeof continueExecution !== 'undefined' && continueExecution === false) {\n                var parent = this.placeEl.parent();\n                this.placeEl.remove();\n                if (!parent.children().length) {\n                    this.unsetParent(parent.parent());\n                }\n                this.restoreItemAtIndex(el, srcIndex);\n                this.reset();\n                return;\n            }\n\n            this.placeEl.replaceWith(el);\n\n            if (this.hasNewRoot) {\n                if (this.options.fixed === true) {\n                    this.restoreItemAtIndex(el, srcIndex);\n                }\n                else {\n                    this.el.trigger('lostItem');\n                }\n                this.dragRootEl.trigger('gainedItem');\n            }\n            else {\n                this.dragRootEl.trigger('change');\n            }\n\n            this.options.callback.call(this, this.dragRootEl, el, position);\n\n            this.reset();\n        },\n\n        dragMove: function(e) {\n            var list, parent, prev, next, depth,\n                opt = this.options,\n                mouse = this.mouse;\n\n            this.dragEl.css({\n                'left': e.pageX - mouse.offsetX,\n                'top': e.pageY - mouse.offsetY\n            });\n\n            // mouse position last events\n            mouse.lastX = mouse.nowX;\n            mouse.lastY = mouse.nowY;\n            // mouse position this events\n            mouse.nowX = e.pageX;\n            mouse.nowY = e.pageY;\n            // distance mouse moved between events\n            mouse.distX = mouse.nowX - mouse.lastX;\n            mouse.distY = mouse.nowY - mouse.lastY;\n            // direction mouse was moving\n            mouse.lastDirX = mouse.dirX;\n            mouse.lastDirY = mouse.dirY;\n            // direction mouse is now moving (on both axis)\n            mouse.dirX = mouse.distX === 0 ? 0 : mouse.distX > 0 ? 1 : -1;\n            mouse.dirY = mouse.distY === 0 ? 0 : mouse.distY > 0 ? 1 : -1;\n            // axis mouse is now moving on\n            var newAx = Math.abs(mouse.distX) > Math.abs(mouse.distY) ? 1 : 0;\n\n            // do nothing on first move\n            if (!mouse.moving) {\n                mouse.dirAx = newAx;\n                mouse.moving = true;\n                return;\n            }\n\n            // do scrolling if enable\n            if (opt.scroll) {\n                if (typeof window.jQuery.fn.scrollParent !== 'undefined') {\n                    var scrolled = false;\n                    var scrollParent = this.el.scrollParent()[0];\n                    if (scrollParent !== document && scrollParent.tagName !== 'HTML') {\n                        if ((opt.scrollTriggers.bottom + scrollParent.offsetHeight) - e.pageY < opt.scrollSensitivity)\n                            scrollParent.scrollTop = scrolled = scrollParent.scrollTop + opt.scrollSpeed;\n                        else if (e.pageY - opt.scrollTriggers.top < opt.scrollSensitivity)\n                            scrollParent.scrollTop = scrolled = scrollParent.scrollTop - opt.scrollSpeed;\n\n                        if ((opt.scrollTriggers.right + scrollParent.offsetWidth) - e.pageX < opt.scrollSensitivity)\n                            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + opt.scrollSpeed;\n                        else if (e.pageX - opt.scrollTriggers.left < opt.scrollSensitivity)\n                            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - opt.scrollSpeed;\n                    } else {\n                        if (e.pageY - $(document).scrollTop() < opt.scrollSensitivity)\n                            scrolled = $(document).scrollTop($(document).scrollTop() - opt.scrollSpeed);\n                        else if ($(window).height() - (e.pageY - $(document).scrollTop()) < opt.scrollSensitivity)\n                            scrolled = $(document).scrollTop($(document).scrollTop() + opt.scrollSpeed);\n\n                        if (e.pageX - $(document).scrollLeft() < opt.scrollSensitivity)\n                            scrolled = $(document).scrollLeft($(document).scrollLeft() - opt.scrollSpeed);\n                        else if ($(window).width() - (e.pageX - $(document).scrollLeft()) < opt.scrollSensitivity)\n                            scrolled = $(document).scrollLeft($(document).scrollLeft() + opt.scrollSpeed);\n                    }\n                } else {\n                    console.warn('To use scrolling you need to have scrollParent() function, check documentation for more information');\n                }\n            }\n\n            if (this.scrollTimer) {\n                clearTimeout(this.scrollTimer);\n            }\n\n            if (opt.scroll && scrolled) {\n                this.scrollTimer = setTimeout(function() {\n                    $(window).trigger(e);\n                }, 10);\n            }\n\n            // calc distance moved on this axis (and direction)\n            if (mouse.dirAx !== newAx) {\n                mouse.distAxX = 0;\n                mouse.distAxY = 0;\n            }\n            else {\n                mouse.distAxX += Math.abs(mouse.distX);\n                if (mouse.dirX !== 0 && mouse.dirX !== mouse.lastDirX) {\n                    mouse.distAxX = 0;\n                }\n                mouse.distAxY += Math.abs(mouse.distY);\n                if (mouse.dirY !== 0 && mouse.dirY !== mouse.lastDirY) {\n                    mouse.distAxY = 0;\n                }\n            }\n            mouse.dirAx = newAx;\n\n            /**\n             * move horizontal\n             */\n            if (mouse.dirAx && mouse.distAxX >= opt.threshold) {\n                // reset move distance on x-axis for new phase\n                mouse.distAxX = 0;\n                prev = this.placeEl.prev(opt.itemNodeName);\n                // increase horizontal level if previous sibling exists, is not collapsed, and can have children\n                if (mouse.distX > 0 && prev.length && !prev.hasClass(opt.collapsedClass) && !prev.hasClass(opt.noChildrenClass)) {\n                    // cannot increase level when item above is collapsed\n                    list = prev.find(opt.listNodeName).last();\n                    // check if depth limit has reached\n                    depth = this.placeEl.parents(opt.listNodeName).length;\n                    if (depth + this.dragDepth <= opt.maxDepth) {\n                        // create new sub-level if one doesn't exist\n                        if (!list.length) {\n                            this.createSubLevel(prev, this.placeEl);\n                        }\n                        else {\n                            // else append to next level up\n                            list = prev.children(opt.listNodeName).last();\n                            list.append(this.placeEl);\n                        }\n                    }\n                }\n                // decrease horizontal level\n                if (mouse.distX < 0) {\n                    // we can't decrease a level if an item preceeds the current one\n                    next = this.placeEl.next(opt.itemNodeName);\n                    if (!next.length) {\n                        parent = this.placeEl.parent();\n                        this.placeEl.closest(opt.itemNodeName).after(this.placeEl);\n                        if (!parent.children().length) {\n                            this.unsetParent(parent.parent());\n                        }\n                    }\n                }\n            }\n\n            var isEmpty = false;\n\n            // find list item under cursor\n            if (!hasPointerEvents) {\n                this.dragEl[0].style.visibility = 'hidden';\n            }\n            this.pointEl = $(document.elementFromPoint(e.pageX - document.body.scrollLeft, e.pageY - (window.pageYOffset || document.documentElement.scrollTop)));\n            if (!hasPointerEvents) {\n                this.dragEl[0].style.visibility = 'visible';\n            }\n            if (this.pointEl.hasClass(opt.handleClass)) {\n                this.pointEl = this.pointEl.closest(opt.itemNodeName);\n            }\n            if (this.pointEl.hasClass(opt.emptyClass)) {\n                isEmpty = true;\n            }\n            else if (!this.pointEl.length || !this.pointEl.hasClass(opt.itemClass)) {\n                return;\n            }\n\n            // find parent list of item under cursor\n            var pointElRoot = this.pointEl.closest('.' + opt.rootClass),\n                isNewRoot = this.dragRootEl.data('nestable-id') !== pointElRoot.data('nestable-id');\n\n            /**\n             * move vertical\n             */\n            if (!mouse.dirAx || isNewRoot || isEmpty) {\n                // check if groups match if dragging over new root\n                if (isNewRoot && opt.group !== pointElRoot.data('nestable-group')) {\n                    return;\n                }\n\n                // fixed item's depth, use for some list has specific type, eg:'Volume, Section, Chapter ...'\n                if (this.options.fixedDepth && this.dragDepth + 1 !== this.pointEl.parents(opt.listNodeName).length) {\n                    return;\n                }\n\n                // check depth limit\n                depth = this.dragDepth - 1 + this.pointEl.parents(opt.listNodeName).length;\n                if (depth > opt.maxDepth) {\n                    return;\n                }\n                var before = e.pageY < (this.pointEl.offset().top + this.pointEl.height() / 2);\n                parent = this.placeEl.parent();\n                // if empty create new list to replace empty placeholder\n                if (isEmpty) {\n                    list = $(document.createElement(opt.listNodeName)).addClass(opt.listClass);\n                    list.append(this.placeEl);\n                    this.pointEl.replaceWith(list);\n                }\n                else if (before) {\n                    this.pointEl.before(this.placeEl);\n                }\n                else {\n                    this.pointEl.after(this.placeEl);\n                }\n                if (!parent.children().length) {\n                    this.unsetParent(parent.parent());\n                }\n                if (!this.dragRootEl.find(opt.itemNodeName).length) {\n                    this.appendEmptyElement(this.dragRootEl);\n                }\n                // parent root list has changed\n                this.dragRootEl = pointElRoot;\n                if (isNewRoot) {\n                    this.hasNewRoot = this.el[0] !== this.dragRootEl[0];\n                }\n            }\n        },\n\n        // Append the .dd-empty div to the list so it can be populated and styled\n        appendEmptyElement: function(element) {\n            element.append('<div class=\"' + this.options.emptyClass + '\"/>');\n        }\n    };\n\n    $.fn.nestable = function(params) {\n        var lists  = this,\n            retval = this,\n            args   = arguments;\n\n        if (!('Nestable' in window)) {\n            window.Nestable = {};\n            Nestable.counter = 0;\n        }\n\n        lists.each(function() {\n            var plugin = $(this).data(\"nestable\");\n\n            if (!plugin) {\n                Nestable.counter++;\n                $(this).data(\"nestable\", new Plugin(this, params));\n                $(this).data(\"nestable-id\", Nestable.counter);\n            }\n            else {\n                if (typeof params === 'string' && typeof plugin[params] === 'function') {\n                    if (args.length > 1){\n                        var pluginArgs = [];\n                        for (var i = 1; i < args.length; i++) {\n                            pluginArgs.push(args[i]);\n                        }\n                        retval = plugin[params].apply(plugin, pluginArgs);\n                    }\n                    else {\n                        retval = plugin[params]();\n                    }\n                }\n            }\n        });\n\n        return retval || lists;\n    };\n\n})(window.jQuery || window.Zepto, window, document);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmVzdGFibGUyL2pxdWVyeS5uZXN0YWJsZS5qcz9lODY0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EseUNBQXlDLG9EQUFvRDtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0NBQXNDO0FBQ3RDLHlDQUF5QztBQUN6Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXN0YWJsZTIvanF1ZXJ5Lm5lc3RhYmxlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBOZXN0YWJsZSBqUXVlcnkgUGx1Z2luIC0gQ29weXJpZ2h0IChjKSAyMDE0IFJhbW9uIFNtaXQgLSBodHRwczovL2dpdGh1Yi5jb20vUmFtb25TbWl0L05lc3RhYmxlXG4gKi9cblxuKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICAgIHZhciBoYXNUb3VjaCA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IENTUyBwb2ludGVyLWV2ZW50cyBwcm9wZXJ0eVxuICAgICAqIGV2ZW50cyBhcmUgbm9ybWFsbHkgZGlzYWJsZWQgb24gdGhlIGRyYWdnaW5nIGVsZW1lbnQgdG8gYXZvaWQgY29uZmxpY3RzXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2F1c2kvRmVhdHVyZS1kZXRlY3Rpb24tdGVjaG5pcXVlLWZvci1wb2ludGVyLWV2ZW50cy9ibG9iL21hc3Rlci9tb2Rlcm5penItcG9pbnRlcmV2ZW50cy5qc1xuICAgICAqL1xuICAgIHZhciBoYXNQb2ludGVyRXZlbnRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBpZiAoISgncG9pbnRlckV2ZW50cycgaW4gZWwuc3R5bGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICd4JztcbiAgICAgICAgZG9jRWwuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICB2YXIgc3VwcG9ydHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpLnBvaW50ZXJFdmVudHMgPT09ICdhdXRvJztcbiAgICAgICAgZG9jRWwucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICByZXR1cm4gISFzdXBwb3J0cztcbiAgICB9KSgpO1xuXG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBjb250ZW50Q2FsbGJhY2s6IGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbS5jb250ZW50IHx8ICcnID8gaXRlbS5jb250ZW50IDogaXRlbS5pZDt9LFxuICAgICAgICBsaXN0Tm9kZU5hbWU6ICdvbCcsXG4gICAgICAgIGl0ZW1Ob2RlTmFtZTogJ2xpJyxcbiAgICAgICAgaGFuZGxlTm9kZU5hbWU6ICdkaXYnLFxuICAgICAgICBjb250ZW50Tm9kZU5hbWU6ICdzcGFuJyxcbiAgICAgICAgcm9vdENsYXNzOiAnZGQnLFxuICAgICAgICBsaXN0Q2xhc3M6ICdkZC1saXN0JyxcbiAgICAgICAgaXRlbUNsYXNzOiAnZGQtaXRlbScsXG4gICAgICAgIGRyYWdDbGFzczogJ2RkLWRyYWdlbCcsXG4gICAgICAgIGhhbmRsZUNsYXNzOiAnZGQtaGFuZGxlJyxcbiAgICAgICAgY29udGVudENsYXNzOiAnZGQtY29udGVudCcsXG4gICAgICAgIGNvbGxhcHNlZENsYXNzOiAnZGQtY29sbGFwc2VkJyxcbiAgICAgICAgcGxhY2VDbGFzczogJ2RkLXBsYWNlaG9sZGVyJyxcbiAgICAgICAgbm9EcmFnQ2xhc3M6ICdkZC1ub2RyYWcnLFxuICAgICAgICBub0NoaWxkcmVuQ2xhc3M6ICdkZC1ub2NoaWxkcmVuJyxcbiAgICAgICAgZW1wdHlDbGFzczogJ2RkLWVtcHR5JyxcbiAgICAgICAgZXhwYW5kQnRuSFRNTDogJzxidXR0b24gY2xhc3M9XCJkZC1leHBhbmRcIiBkYXRhLWFjdGlvbj1cImV4cGFuZFwiIHR5cGU9XCJidXR0b25cIj5FeHBhbmQ8L2J1dHRvbj4nLFxuICAgICAgICBjb2xsYXBzZUJ0bkhUTUw6ICc8YnV0dG9uIGNsYXNzPVwiZGQtY29sbGFwc2VcIiBkYXRhLWFjdGlvbj1cImNvbGxhcHNlXCIgdHlwZT1cImJ1dHRvblwiPkNvbGxhcHNlPC9idXR0b24+JyxcbiAgICAgICAgZ3JvdXA6IDAsXG4gICAgICAgIG1heERlcHRoOiA1LFxuICAgICAgICB0aHJlc2hvbGQ6IDIwLFxuICAgICAgICBmaXhlZERlcHRoOiBmYWxzZSwgLy9maXhlZCBpdGVtJ3MgZGVwdGhcbiAgICAgICAgZml4ZWQ6IGZhbHNlLFxuICAgICAgICBpbmNsdWRlQ29udGVudDogZmFsc2UsXG4gICAgICAgIHNjcm9sbDogZmFsc2UsXG4gICAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAxLFxuICAgICAgICBzY3JvbGxTcGVlZDogNSxcbiAgICAgICAgc2Nyb2xsVHJpZ2dlcnM6IHtcbiAgICAgICAgICAgIHRvcDogNDAsXG4gICAgICAgICAgICBsZWZ0OiA0MCxcbiAgICAgICAgICAgIHJpZ2h0OiAtNDAsXG4gICAgICAgICAgICBib3R0b206IC00MFxuICAgICAgICB9LFxuICAgICAgICBlZmZlY3Q6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogJ25vbmUnLFxuICAgICAgICAgICAgdGltZTogJ3Nsb3cnXG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbihsLCBlLCBwKSB7fSxcbiAgICAgICAgb25EcmFnU3RhcnQ6IGZ1bmN0aW9uKGwsIGUsIHApIHt9LFxuICAgICAgICBiZWZvcmVEcmFnU3RvcDogZnVuY3Rpb24obCwgZSwgcCkge30sXG4gICAgICAgIGxpc3RSZW5kZXJlcjogZnVuY3Rpb24oY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gJzwnICsgb3B0aW9ucy5saXN0Tm9kZU5hbWUgKyAnIGNsYXNzPVwiJyArIG9wdGlvbnMubGlzdENsYXNzICsgJ1wiPic7XG4gICAgICAgICAgICBodG1sICs9IGNoaWxkcmVuO1xuICAgICAgICAgICAgaHRtbCArPSAnPC8nICsgb3B0aW9ucy5saXN0Tm9kZU5hbWUgKyAnPic7XG5cbiAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9LFxuICAgICAgICBpdGVtUmVuZGVyZXI6IGZ1bmN0aW9uKGl0ZW1fYXR0cnMsIGNvbnRlbnQsIGNoaWxkcmVuLCBvcHRpb25zLCBpdGVtKSB7XG4gICAgICAgICAgICB2YXIgaXRlbV9hdHRyc19zdHJpbmcgPSAkLm1hcChpdGVtX2F0dHJzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgJyArIGtleSArICc9XCInICsgdmFsdWUgKyAnXCInO1xuICAgICAgICAgICAgfSkuam9pbignICcpO1xuXG4gICAgICAgICAgICB2YXIgaHRtbCA9ICc8JyArIG9wdGlvbnMuaXRlbU5vZGVOYW1lICsgaXRlbV9hdHRyc19zdHJpbmcgKyAnPic7XG4gICAgICAgICAgICBodG1sICs9ICc8JyArIG9wdGlvbnMuaGFuZGxlTm9kZU5hbWUgKyAnIGNsYXNzPVwiJyArIG9wdGlvbnMuaGFuZGxlQ2xhc3MgKyAnXCI+JztcbiAgICAgICAgICAgIGh0bWwgKz0gJzwnICsgb3B0aW9ucy5jb250ZW50Tm9kZU5hbWUgKyAnIGNsYXNzPVwiJyArIG9wdGlvbnMuY29udGVudENsYXNzICsgJ1wiPic7XG4gICAgICAgICAgICBodG1sICs9IGNvbnRlbnQ7XG4gICAgICAgICAgICBodG1sICs9ICc8LycgKyBvcHRpb25zLmNvbnRlbnROb2RlTmFtZSArICc+JztcbiAgICAgICAgICAgIGh0bWwgKz0gJzwvJyArIG9wdGlvbnMuaGFuZGxlTm9kZU5hbWUgKyAnPic7XG4gICAgICAgICAgICBodG1sICs9IGNoaWxkcmVuO1xuICAgICAgICAgICAgaHRtbCArPSAnPC8nICsgb3B0aW9ucy5pdGVtTm9kZU5hbWUgKyAnPic7XG5cbiAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFBsdWdpbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudyAgPSAkKGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5lbCA9ICQoZWxlbWVudCk7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJvb3RDbGFzcyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucm9vdENsYXNzICE9PSAnZGQnKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxpc3RDbGFzcyAgICAgICA9IG9wdGlvbnMubGlzdENsYXNzID8gb3B0aW9ucy5saXN0Q2xhc3MgOiBvcHRpb25zLnJvb3RDbGFzcyArICctbGlzdCc7XG4gICAgICAgICAgICBvcHRpb25zLml0ZW1DbGFzcyAgICAgICA9IG9wdGlvbnMuaXRlbUNsYXNzID8gb3B0aW9ucy5pdGVtQ2xhc3MgOiBvcHRpb25zLnJvb3RDbGFzcyArICctaXRlbSc7XG4gICAgICAgICAgICBvcHRpb25zLmRyYWdDbGFzcyAgICAgICA9IG9wdGlvbnMuZHJhZ0NsYXNzID8gb3B0aW9ucy5kcmFnQ2xhc3MgOiBvcHRpb25zLnJvb3RDbGFzcyArICctZHJhZ2VsJztcbiAgICAgICAgICAgIG9wdGlvbnMuaGFuZGxlQ2xhc3MgICAgID0gb3B0aW9ucy5oYW5kbGVDbGFzcyA/IG9wdGlvbnMuaGFuZGxlQ2xhc3MgOiBvcHRpb25zLnJvb3RDbGFzcyArICctaGFuZGxlJztcbiAgICAgICAgICAgIG9wdGlvbnMuY29sbGFwc2VkQ2xhc3MgID0gb3B0aW9ucy5jb2xsYXBzZWRDbGFzcyA/IG9wdGlvbnMuY29sbGFwc2VkQ2xhc3MgOiBvcHRpb25zLnJvb3RDbGFzcyArICctY29sbGFwc2VkJztcbiAgICAgICAgICAgIG9wdGlvbnMucGxhY2VDbGFzcyAgICAgID0gb3B0aW9ucy5wbGFjZUNsYXNzID8gb3B0aW9ucy5wbGFjZUNsYXNzIDogb3B0aW9ucy5yb290Q2xhc3MgKyAnLXBsYWNlaG9sZGVyJztcbiAgICAgICAgICAgIG9wdGlvbnMubm9EcmFnQ2xhc3MgICAgID0gb3B0aW9ucy5ub0RyYWdDbGFzcyA/IG9wdGlvbnMubm9EcmFnQ2xhc3MgOiBvcHRpb25zLnJvb3RDbGFzcyArICctbm9kcmFnJztcbiAgICAgICAgICAgIG9wdGlvbnMubm9DaGlsZHJlbkNsYXNzID0gb3B0aW9ucy5ub0NoaWxkcmVuQ2xhc3MgPyBvcHRpb25zLm5vQ2hpbGRyZW5DbGFzcyA6IG9wdGlvbnMucm9vdENsYXNzICsgJy1ub2NoaWxkcmVuJztcbiAgICAgICAgICAgIG9wdGlvbnMuZW1wdHlDbGFzcyAgICAgID0gb3B0aW9ucy5lbXB0eUNsYXNzID8gb3B0aW9ucy5lbXB0eUNsYXNzIDogb3B0aW9ucy5yb290Q2xhc3MgKyAnLWVtcHR5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYnVpbGQgSFRNTCBmcm9tIHNlcmlhbGl6ZWQgSlNPTiBpZiBwYXNzZWRcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5qc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBQbHVnaW4ucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzO1xuXG4gICAgICAgICAgICBsaXN0LnJlc2V0KCk7XG4gICAgICAgICAgICBsaXN0LmVsLmRhdGEoJ25lc3RhYmxlLWdyb3VwJywgdGhpcy5vcHRpb25zLmdyb3VwKTtcbiAgICAgICAgICAgIGxpc3QucGxhY2VFbCA9ICQoJzxkaXYgY2xhc3M9XCInICsgbGlzdC5vcHRpb25zLnBsYWNlQ2xhc3MgKyAnXCIvPicpO1xuXG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmVsLmZpbmQobGlzdC5vcHRpb25zLml0ZW1Ob2RlTmFtZSk7XG4gICAgICAgICAgICAkLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGssIGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSAkKGVsKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gaXRlbS5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBsaXN0LnNldFBhcmVudChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lmhhc0NsYXNzKGxpc3Qub3B0aW9ucy5jb2xsYXBzZWRDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5jb2xsYXBzZUl0ZW0ocGFyZW50LnBhcmVudCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSAuZGQtZW1wdHkgZGl2IGlmIHRoZSBsaXN0IGRvbid0IGhhdmUgYW55IGl0ZW1zIG9uIGluaXRcbiAgICAgICAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFbXB0eUVsZW1lbnQodGhpcy5lbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpc3QuZWwub24oJ2NsaWNrJywgJ2J1dHRvbicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdC5kcmFnRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gJChlLmN1cnJlbnRUYXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSB0YXJnZXQuZGF0YSgnYWN0aW9uJyksXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB0YXJnZXQucGFyZW50cyhsaXN0Lm9wdGlvbnMuaXRlbU5vZGVOYW1lKS5lcSgwKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAnY29sbGFwc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuY29sbGFwc2VJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAnZXhwYW5kJykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LmV4cGFuZEl0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBvblN0YXJ0RXZlbnQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9ICQoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlLmhhc0NsYXNzKGxpc3Qub3B0aW9ucy5oYW5kbGVDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZS5jbG9zZXN0KCcuJyArIGxpc3Qub3B0aW9ucy5ub0RyYWdDbGFzcykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gaGFuZGxlLmNsb3Nlc3QoJy4nICsgbGlzdC5vcHRpb25zLmhhbmRsZUNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGUubGVuZ3RoIHx8IGxpc3QuZHJhZ0VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaXN0LmlzVG91Y2ggPSAvXnRvdWNoLy50ZXN0KGUudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3QuaXNUb3VjaCAmJiBlLnRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbGlzdC5kcmFnU3RhcnQoZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgb25Nb3ZlRXZlbnQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3QuZHJhZ0VsKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5kcmFnTW92ZShlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgb25FbmRFdmVudCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdC5kcmFnRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0LmRyYWdTdG9wKGUudG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0gOiBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaGFzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICBsaXN0LmVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblN0YXJ0RXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Nb3ZlRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvbkVuZEV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgb25FbmRFdmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaXN0LmVsLm9uKCdtb3VzZWRvd24nLCBvblN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgbGlzdC53Lm9uKCdtb3VzZW1vdmUnLCBvbk1vdmVFdmVudCk7XG4gICAgICAgICAgICBsaXN0Lncub24oJ21vdXNldXAnLCBvbkVuZEV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIGRlc3Ryb3lOZXN0YWJsZSA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5lbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25TdGFydEV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbk1vdmVFdmVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvbkVuZEV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIG9uRW5kRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaXN0LmVsLm9mZignbW91c2Vkb3duJywgb25TdGFydEV2ZW50KTtcbiAgICAgICAgICAgICAgICBsaXN0Lncub2ZmKCdtb3VzZW1vdmUnLCBvbk1vdmVFdmVudCk7XG4gICAgICAgICAgICAgICAgbGlzdC53Lm9mZignbW91c2V1cCcsIG9uRW5kRXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgbGlzdC5lbC5vZmYoJ2NsaWNrJyk7XG4gICAgICAgICAgICAgICAgbGlzdC5lbC51bmJpbmQoJ2Rlc3Ryb3ktbmVzdGFibGUnKTtcblxuICAgICAgICAgICAgICAgIGxpc3QuZWwuZGF0YShcIm5lc3RhYmxlXCIsIG51bGwpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbGlzdC5lbC5iaW5kKCdkZXN0cm95LW5lc3RhYmxlJywgZGVzdHJveU5lc3RhYmxlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZWwudHJpZ2dlcignZGVzdHJveS1uZXN0YWJsZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKGl0ZW0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBsaXN0Q2xhc3NTZWxlY3RvciA9ICcuJyArIHRoaXMub3B0aW9ucy5saXN0Q2xhc3M7XG4gICAgICAgICAgICB2YXIgdHJlZSA9ICQodGhpcy5lbCkuY2hpbGRyZW4obGlzdENsYXNzU2VsZWN0b3IpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnRfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmZpbmQoJ1tkYXRhLWlkPVwiJyArIGl0ZW0ucGFyZW50X2lkICsgJ1wiXScpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtLnBhcmVudF9pZDtcblxuICAgICAgICAgICAgICAgIGlmICh0cmVlLmNoaWxkcmVuKGxpc3RDbGFzc1NlbGVjdG9yKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuYXBwZW5kKHRoaXMub3B0aW9ucy5saXN0UmVuZGVyZXIoJycsIHRoaXMub3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmZpbmQobGlzdENsYXNzU2VsZWN0b3IgKyAnOmZpcnN0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJlbnQodHJlZS5wYXJlbnQoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyZWUuYXBwZW5kKHRoaXMuX2J1aWxkSXRlbShpdGVtLCB0aGlzLm9wdGlvbnMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlOiBmdW5jdGlvbiAoaXRlbSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGh0bWwgPSB0aGlzLl9idWlsZEl0ZW0oaXRlbSwgdGhpcy5vcHRpb25zKTtcblxuICAgICAgICAgICAgdGhpcy5fZ2V0SXRlbUJ5SWQoaXRlbS5pZClcbiAgICAgICAgICAgICAgICAucmVwbGFjZVdpdGgoaHRtbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9yZW1vdmVzIGl0ZW0gYW5kIGFkZGl0aW9uYWwgZWxlbWVudHMgZnJvbSBsaXN0XG4gICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChpdGVtKXtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGVsICAgPSB0aGlzLmVsO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgaXRlbVxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0gfHwgdGhpcztcbiAgICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGVtcHR5TGlzdHNTZWxlY3RvciA9ICcuJyArIG9wdHMubGlzdENsYXNzXG4gICAgICAgICAgICAgICAgKyAnIC4nICsgb3B0cy5saXN0Q2xhc3MgKyAnOm5vdCg6aGFzKCopKSc7XG4gICAgICAgICAgICAkKGVsKS5maW5kKGVtcHR5TGlzdHNTZWxlY3RvcikucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBidXR0b25zIGlmIHBhcmVudHMgZG8gbm90IGhhdmUgY2hpbGRyZW5cbiAgICAgICAgICAgIHZhciBidXR0b25zU2VsZWN0b3IgPSAnW2RhdGEtYWN0aW9uPVwiZXhwYW5kXCJdLCBbZGF0YS1hY3Rpb249XCJjb2xsYXBzZVwiXSc7XG4gICAgICAgICAgICAkKGVsKS5maW5kKGJ1dHRvbnNTZWxlY3RvcikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2libGluZ3MgPSAkKHRoaXMpLnNpYmxpbmdzKCcuJyArIG9wdHMubGlzdENsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2libGluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy9yZW1vdmVzIGl0ZW0gYnkgaXRlbUlkIGFuZCBydW4gY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChpdGVtSWQsIGNhbGxiYWNrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fZ2V0SXRlbUJ5SWQoaXRlbUlkKTtcblxuICAgICAgICAgICAgLy9hbmltYXRpb24gc3R5bGVcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBvcHRzLmVmZmVjdC5hbmltYXRpb24gfHwgJ2ZhZGUnO1xuXG4gICAgICAgICAgICAvL2FuaW1hdGlvbiB0aW1lXG4gICAgICAgICAgICB2YXIgdGltZSA9IG9wdHMuZWZmZWN0LnRpbWUgfHwgJ3Nsb3cnO1xuXG4gICAgICAgICAgICAvL2FkZCBmYWRlT3V0IGVmZmVjdCB3aGVuIHJlbW92aW5nXG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uID09PSAnZmFkZScpe1xuICAgICAgICAgICAgICAgIGl0ZW0uZmFkZU91dCh0aW1lLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvL3JlbW92ZXMgYWxsIGl0ZW1zIGZyb20gdGhlIGxpc3QgYW5kIHJ1biBjYWxsYmFjayBhdCB0aGUgZW5kXG4gICAgICAgIHJlbW92ZUFsbDogZnVuY3Rpb24oY2FsbGJhY2spe1xuXG4gICAgICAgICAgICB2YXIgbGlzdCAgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG9wdHMgID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG5vZGUgID0gbGlzdC5lbC5maW5kKG9wdHMubGlzdE5vZGVOYW1lKS5maXJzdCgpLFxuICAgICAgICAgICAgICAgIGl0ZW1zID0gbm9kZS5jaGlsZHJlbihvcHRzLml0ZW1Ob2RlTmFtZSk7XG5cbiAgICAgICAgICAgIC8vYW5pbWF0aW9uIHN0eWxlXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gb3B0cy5lZmZlY3QuYW5pbWF0aW9uIHx8ICdmYWRlJztcblxuICAgICAgICAgICAgLy9hbmltYXRpb24gdGltZVxuICAgICAgICAgICAgdmFyIHRpbWUgPSBvcHRzLmVmZmVjdC50aW1lIHx8ICdzbG93JztcblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKCl7XG4gICAgICAgICAgICAgICAgLy9SZW1vdmVzIGVhY2ggaXRlbSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucmVtb3ZlSXRlbSgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvL05vdyB3ZSBjYW4gYWdhaW4gc2hvdyBvdXIgbm9kZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgbm9kZS5zaG93KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2FkZCBmYWRlT3V0IGVmZmVjdCB3aGVuIHJlbW92aW5nXG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uID09PSAnZmFkZScpe1xuICAgICAgICAgICAgICAgIG5vZGUuZmFkZU91dCh0aW1lLCByZW1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEl0ZW1CeUlkOiBmdW5jdGlvbihpdGVtSWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMuZWwpLmNoaWxkcmVuKCcuJyArIHRoaXMub3B0aW9ucy5saXN0Q2xhc3MpXG4gICAgICAgICAgICAgICAgLmZpbmQoJ1tkYXRhLWlkPVwiJyArIGl0ZW1JZCArICdcIl0nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYnVpbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGpzb24gPSB0aGlzLm9wdGlvbnMuanNvbjtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkKHRoaXMuZWwpLmh0bWwodGhpcy5fYnVpbGRMaXN0KGpzb24sIHRoaXMub3B0aW9ucykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9idWlsZExpc3Q6IGZ1bmN0aW9uKGl0ZW1zLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSAnJztcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgJC5lYWNoKGl0ZW1zLCBmdW5jdGlvbihpbmRleCwgc3ViKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gKz0gdGhhdC5fYnVpbGRJdGVtKHN1Yiwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubGlzdFJlbmRlcmVyKGNoaWxkcmVuLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYnVpbGRJdGVtOiBmdW5jdGlvbihpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0ge1xuICAgICAgICAgICAgICAgICAgICAnJic6ICcmYW1wOycsXG4gICAgICAgICAgICAgICAgICAgICc8JzogJyZsdDsnLFxuICAgICAgICAgICAgICAgICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICAgICAgICAgICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICAgICAgICAgICAgICAgIFwiJ1wiOiAnJiMwMzk7J1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCArIFwiXCIucmVwbGFjZSgvWyY8PlwiJ10vZywgZnVuY3Rpb24obSkgeyByZXR1cm4gbWFwW21dOyB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZmlsdGVyQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld19jbGFzc2VzID0ge307XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgICAgICAgbmV3X2NsYXNzZXNbY2xhc3Nlc1trXV0gPSBjbGFzc2VzW2tdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdfY2xhc3NlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ2xhc3Nlc1N0cmluZyhpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBpdGVtLmNsYXNzZXMgfHwge307XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBbY2xhc3Nlc107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1fY2xhc3NlcyA9IGZpbHRlckNsYXNzZXMoY2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgaXRlbV9jbGFzc2VzW29wdGlvbnMuaXRlbUNsYXNzXSA9IG9wdGlvbnMuaXRlbUNsYXNzO1xuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGNsYXNzIHN0cmluZ1xuICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChpdGVtX2NsYXNzZXMsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRGF0YUF0dHJzKGF0dHIpIHtcbiAgICAgICAgICAgICAgICBhdHRyID0gJC5leHRlbmQoe30sIGF0dHIpO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGF0dHIuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgZGVsZXRlIGF0dHIuY2xhc3NlcztcbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0ci5jb250ZW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFfYXR0cnMgPSB7fTtcblxuICAgICAgICAgICAgICAgICQuZWFjaChhdHRyLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRhdGFfYXR0cnNbXCJkYXRhLVwiICsga2V5XSA9IGVzY2FwZUh0bWwodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfYXR0cnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpdGVtX2F0dHJzID0gY3JlYXRlRGF0YUF0dHJzKGl0ZW0pO1xuICAgICAgICAgICAgaXRlbV9hdHRyc1tcImNsYXNzXCJdID0gY3JlYXRlQ2xhc3Nlc1N0cmluZyhpdGVtLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBvcHRpb25zLmNvbnRlbnRDYWxsYmFjayhpdGVtKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2J1aWxkTGlzdChpdGVtLmNoaWxkcmVuLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBodG1sID0gJChvcHRpb25zLml0ZW1SZW5kZXJlcihpdGVtX2F0dHJzLCBjb250ZW50LCBjaGlsZHJlbiwgb3B0aW9ucywgaXRlbSkpO1xuXG4gICAgICAgICAgICB0aGlzLnNldFBhcmVudChodG1sKTtcblxuICAgICAgICAgICAgcmV0dXJuIGh0bWxbMF0ub3V0ZXJIVE1MO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSwgbGlzdCA9IHRoaXMsIHN0ZXAgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IGxldmVsLmNoaWxkcmVuKGxpc3Qub3B0aW9ucy5pdGVtTm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaSA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gJC5leHRlbmQoe30sIGxpLmRhdGEoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWIgPSBsaS5jaGlsZHJlbihsaXN0Lm9wdGlvbnMubGlzdE5vZGVOYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdC5vcHRpb25zLmluY2x1ZGVDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGxpLmZpbmQoJy4nICsgbGlzdC5vcHRpb25zLmNvbnRlbnRDbGFzcykuaHRtbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jaGlsZHJlbiA9IHN0ZXAoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhID0gc3RlcChsaXN0LmVsLmZpbmQobGlzdC5vcHRpb25zLmxpc3ROb2RlTmFtZSkuZmlyc3QoKSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICBhc05lc3RlZFNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMsIG8gPSBsaXN0Lm9wdGlvbnMsIGRlcHRoID0gLTEsIHJldCA9IFtdLCBsZnQgPSAxO1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gbGlzdC5lbC5maW5kKG8ubGlzdE5vZGVOYW1lKS5maXJzdCgpLmNoaWxkcmVuKG8uaXRlbU5vZGVOYW1lKTtcblxuICAgICAgICAgICAgaXRlbXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbGZ0ID0gdHJhdmVyc2UodGhpcywgZGVwdGggKyAxLCBsZnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldCA9IHJldC5zb3J0KGZ1bmN0aW9uKGEsYil7IHJldHVybiAoYS5sZnQgLSBiLmxmdCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gdHJhdmVyc2UoaXRlbSwgZGVwdGgsIGxmdCkge1xuICAgICAgICAgICAgICAgIHZhciByZ3QgPSBsZnQgKyAxLCBpZCwgcGlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCQoaXRlbSkuY2hpbGRyZW4oby5saXN0Tm9kZU5hbWUpLmNoaWxkcmVuKG8uaXRlbU5vZGVOYW1lKS5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICAkKGl0ZW0pLmNoaWxkcmVuKG8ubGlzdE5vZGVOYW1lKS5jaGlsZHJlbihvLml0ZW1Ob2RlTmFtZSkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZ3QgPSB0cmF2ZXJzZSgkKHRoaXMpLCBkZXB0aCwgcmd0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWQgPSAkKGl0ZW0pLmF0dHIoJ2RhdGEtaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gcGFyc2VJbnQoaWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBpZCA9ICQoaXRlbSkucGFyZW50KG8ubGlzdE5vZGVOYW1lKS5wYXJlbnQoby5pdGVtTm9kZU5hbWUpLmF0dHIoJ2RhdGEtaWQnKSB8fCAnJztcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnQocGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHBhcnNlSW50KHBpZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKHtcImlkXCI6IGlkLCBcInBhcmVudF9pZFwiOiBwaWQsIFwiZGVwdGhcIjogZGVwdGgsIFwibGZ0XCI6IGxmdCwgXCJyZ3RcIjogcmd0fSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGZ0ID0gcmd0ICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0ludCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmlzTnVtZXJpYyh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmV0dXJuT3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlcmlhbGlzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b0hpZXJhcmNoeTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgICAgICB2YXIgbyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIHJldCA9IFtdO1xuXG4gICAgICAgICAgICAkKHRoaXMuZWxlbWVudCkuY2hpbGRyZW4oby5pdGVtcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSBfcmVjdXJzaXZlSXRlbXModGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2gobGV2ZWwpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9yZWN1cnNpdmVJdGVtcyhpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gKCQoaXRlbSkuYXR0cihvLmF0dHJpYnV0ZSB8fCAnaWQnKSB8fCAnJykubWF0Y2goby5leHByZXNzaW9uIHx8ICgvKC4rKVstPV9dKC4rKS8pKTtcbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBpZFsyXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoJChpdGVtKS5jaGlsZHJlbihvLmxpc3RUeXBlKS5jaGlsZHJlbihvLml0ZW1zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SXRlbS5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChpdGVtKS5jaGlsZHJlbihvLmxpc3RUeXBlKS5jaGlsZHJlbihvLml0ZW1zKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IF9yZWN1cnNpdmVJdGVtcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SXRlbS5jaGlsZHJlbi5wdXNoKGxldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50SXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciBvID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgdGhpcyksXG4gICAgICAgICAgICAgICAgc0RlcHRoID0gby5zdGFydERlcHRoQ291bnQgfHwgMCxcbiAgICAgICAgICAgICAgICByZXQgPSBbXSxcbiAgICAgICAgICAgICAgICBsZWZ0ID0gMixcbiAgICAgICAgICAgICAgICBsaXN0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGlzdC5lbC5maW5kKGxpc3Qub3B0aW9ucy5saXN0Tm9kZU5hbWUpLmZpcnN0KCk7XG5cbiAgICAgICAgICAgIHZhciBpdGVtcyA9IGVsZW1lbnQuY2hpbGRyZW4obGlzdC5vcHRpb25zLml0ZW1Ob2RlTmFtZSk7XG4gICAgICAgICAgICBpdGVtcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBfcmVjdXJzaXZlQXJyYXkoJCh0aGlzKSwgc0RlcHRoICsgMSwgbGVmdCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0ID0gcmV0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYS5sZWZ0IC0gYi5sZWZ0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBfcmVjdXJzaXZlQXJyYXkoaXRlbSwgZGVwdGgsIGxlZnQpIHtcblxuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyAxLFxuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgcGlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4oby5vcHRpb25zLmxpc3ROb2RlTmFtZSkuY2hpbGRyZW4oby5vcHRpb25zLml0ZW1Ob2RlTmFtZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuKG8ub3B0aW9ucy5saXN0Tm9kZU5hbWUpLmNoaWxkcmVuKG8ub3B0aW9ucy5pdGVtTm9kZU5hbWUpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IF9yZWN1cnNpdmVBcnJheSgkKHRoaXMpLCBkZXB0aCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZCA9IGl0ZW0uZGF0YSgpLmlkO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT09IHNEZXB0aCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGlkID0gby5yb290SUQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50SXRlbSA9IChpdGVtLnBhcmVudChvLm9wdGlvbnMubGlzdE5vZGVOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnBhcmVudChvLm9wdGlvbnMuaXRlbU5vZGVOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoKSk7XG4gICAgICAgICAgICAgICAgICAgIHBpZCA9IHBhcmVudEl0ZW0uaWQ7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicGFyZW50X2lkXCI6IHBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogZGVwdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxlZnRcIjogbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmlnaHRcIjogcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGVmdCA9IHJpZ2h0ICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubW91c2UgPSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0WDogMCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IDAsXG4gICAgICAgICAgICAgICAgbGFzdFg6IDAsXG4gICAgICAgICAgICAgICAgbGFzdFk6IDAsXG4gICAgICAgICAgICAgICAgbm93WDogMCxcbiAgICAgICAgICAgICAgICBub3dZOiAwLFxuICAgICAgICAgICAgICAgIGRpc3RYOiAwLFxuICAgICAgICAgICAgICAgIGRpc3RZOiAwLFxuICAgICAgICAgICAgICAgIGRpckF4OiAwLFxuICAgICAgICAgICAgICAgIGRpclg6IDAsXG4gICAgICAgICAgICAgICAgZGlyWTogMCxcbiAgICAgICAgICAgICAgICBsYXN0RGlyWDogMCxcbiAgICAgICAgICAgICAgICBsYXN0RGlyWTogMCxcbiAgICAgICAgICAgICAgICBkaXN0QXhYOiAwLFxuICAgICAgICAgICAgICAgIGRpc3RBeFk6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmlzVG91Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyYWdSb290RWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kcmFnRGVwdGggPSAwO1xuICAgICAgICAgICAgdGhpcy5oYXNOZXdSb290ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBvaW50RWwgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV4cGFuZEl0ZW06IGZ1bmN0aW9uKGxpKSB7XG4gICAgICAgICAgICBsaS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY29sbGFwc2VkQ2xhc3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbGxhcHNlSXRlbTogZnVuY3Rpb24obGkpIHtcbiAgICAgICAgICAgIHZhciBsaXN0cyA9IGxpLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5saXN0Tm9kZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGxpc3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jb2xsYXBzZWRDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXhwYW5kQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcztcbiAgICAgICAgICAgIGxpc3QuZWwuZmluZChsaXN0Lm9wdGlvbnMuaXRlbU5vZGVOYW1lKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxpc3QuZXhwYW5kSXRlbSgkKHRoaXMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbGxhcHNlQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcztcbiAgICAgICAgICAgIGxpc3QuZWwuZmluZChsaXN0Lm9wdGlvbnMuaXRlbU5vZGVOYW1lKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxpc3QuY29sbGFwc2VJdGVtKCQodGhpcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UGFyZW50OiBmdW5jdGlvbihsaSkge1xuICAgICAgICAgICAgLy9DaGVjayBpZiBsaSBpcyBhbiBlbGVtZW50IG9mIGl0ZW1Ob2RlTmFtZSB0eXBlIGFuZCBoYXMgY2hpbGRyZW5cbiAgICAgICAgICAgIGlmIChsaS5pcyh0aGlzLm9wdGlvbnMuaXRlbU5vZGVOYW1lKSAmJiBsaS5jaGlsZHJlbih0aGlzLm9wdGlvbnMubGlzdE5vZGVOYW1lKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgTk9UIHNob3dpbmcgdHdvIG9yIG1vcmUgc2V0cyBkYXRhLWFjdGlvbiBidXR0b25zXG4gICAgICAgICAgICAgICAgbGkuY2hpbGRyZW4oJ1tkYXRhLWFjdGlvbl0nKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBsaS5wcmVwZW5kKCQodGhpcy5vcHRpb25zLmV4cGFuZEJ0bkhUTUwpKTtcbiAgICAgICAgICAgICAgICBsaS5wcmVwZW5kKCQodGhpcy5vcHRpb25zLmNvbGxhcHNlQnRuSFRNTCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuc2V0UGFyZW50OiBmdW5jdGlvbihsaSkge1xuICAgICAgICAgICAgbGkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmNvbGxhcHNlZENsYXNzKTtcbiAgICAgICAgICAgIGxpLmNoaWxkcmVuKCdbZGF0YS1hY3Rpb25dJykucmVtb3ZlKCk7XG4gICAgICAgICAgICBsaS5jaGlsZHJlbih0aGlzLm9wdGlvbnMubGlzdE5vZGVOYW1lKS5yZW1vdmUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IHRoaXMubW91c2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gJChlLnRhcmdldCksXG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW0gPSB0YXJnZXQuY2xvc2VzdCh0aGlzLm9wdGlvbnMuaXRlbU5vZGVOYW1lKSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wICA6IGUucGFnZVksXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgOiBlLnBhZ2VYXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNvbnRpbnVlRXhlY3V0aW9uID0gdGhpcy5vcHRpb25zLm9uRHJhZ1N0YXJ0LmNhbGwodGhpcywgdGhpcy5lbCwgZHJhZ0l0ZW0sIHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250aW51ZUV4ZWN1dGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgY29udGludWVFeGVjdXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBsYWNlRWwuY3NzKCdoZWlnaHQnLCBkcmFnSXRlbS5oZWlnaHQoKSk7XG5cbiAgICAgICAgICAgIG1vdXNlLm9mZnNldFggPSBlLnBhZ2VYIC0gZHJhZ0l0ZW0ub2Zmc2V0KCkubGVmdDtcbiAgICAgICAgICAgIG1vdXNlLm9mZnNldFkgPSBlLnBhZ2VZIC0gZHJhZ0l0ZW0ub2Zmc2V0KCkudG9wO1xuICAgICAgICAgICAgbW91c2Uuc3RhcnRYID0gbW91c2UubGFzdFggPSBlLnBhZ2VYO1xuICAgICAgICAgICAgbW91c2Uuc3RhcnRZID0gbW91c2UubGFzdFkgPSBlLnBhZ2VZO1xuXG4gICAgICAgICAgICB0aGlzLmRyYWdSb290RWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgdGhpcy5kcmFnRWwgPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5vcHRpb25zLmxpc3ROb2RlTmFtZSkpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5saXN0Q2xhc3MgKyAnICcgKyB0aGlzLm9wdGlvbnMuZHJhZ0NsYXNzKTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VsLmNzcygnd2lkdGgnLCBkcmFnSXRlbS5vdXRlcldpZHRoKCkpO1xuXG4gICAgICAgICAgICB0aGlzLnNldEluZGV4T2ZJdGVtKGRyYWdJdGVtKTtcblxuICAgICAgICAgICAgLy8gZml4IGZvciB6ZXB0by5qc1xuICAgICAgICAgICAgLy9kcmFnSXRlbS5hZnRlcih0aGlzLnBsYWNlRWwpLmRldGFjaCgpLmFwcGVuZFRvKHRoaXMuZHJhZ0VsKTtcbiAgICAgICAgICAgIGRyYWdJdGVtLmFmdGVyKHRoaXMucGxhY2VFbCk7XG4gICAgICAgICAgICBkcmFnSXRlbVswXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdJdGVtWzBdKTtcbiAgICAgICAgICAgIGRyYWdJdGVtLmFwcGVuZFRvKHRoaXMuZHJhZ0VsKTtcblxuICAgICAgICAgICAgJChkb2N1bWVudC5ib2R5KS5hcHBlbmQodGhpcy5kcmFnRWwpO1xuICAgICAgICAgICAgdGhpcy5kcmFnRWwuY3NzKHtcbiAgICAgICAgICAgICAgICAnbGVmdCc6IGUucGFnZVggLSBtb3VzZS5vZmZzZXRYLFxuICAgICAgICAgICAgICAgICd0b3AnOiBlLnBhZ2VZIC0gbW91c2Uub2Zmc2V0WVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0b3RhbCBkZXB0aCBvZiBkcmFnZ2luZyBpdGVtXG4gICAgICAgICAgICB2YXIgaSwgZGVwdGgsXG4gICAgICAgICAgICAgICAgaXRlbXMgPSB0aGlzLmRyYWdFbC5maW5kKHRoaXMub3B0aW9ucy5pdGVtTm9kZU5hbWUpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVwdGggPSAkKGl0ZW1zW2ldKS5wYXJlbnRzKHRoaXMub3B0aW9ucy5saXN0Tm9kZU5hbWUpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPiB0aGlzLmRyYWdEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdEZXB0aCA9IGRlcHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvL0NyZWF0ZSBzdWJsZXZlbC5cbiAgICAgICAgLy8gIGVsZW1lbnQgOiBlbGVtZW50IHdoaWNoIGJlY29tZSBwYXJlbnRcbiAgICAgICAgLy8gIGl0ZW0gICAgOiBzb21ldGhpbmcgdG8gcGxhY2UgaW50byBuZXcgc3VibGV2ZWxcbiAgICAgICAgY3JlYXRlU3ViTGV2ZWw6IGZ1bmN0aW9uKGVsZW1lbnQsIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gJCgnPCcgKyB0aGlzLm9wdGlvbnMubGlzdE5vZGVOYW1lICsgJy8+JykuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxpc3RDbGFzcyk7XG4gICAgICAgICAgICBpZiAoaXRlbSkgbGlzdC5hcHBlbmQoaXRlbSk7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZChsaXN0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0SW5kZXhPZkl0ZW06IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4IHx8IFtdO1xuXG4gICAgICAgICAgICBpbmRleC51bnNoaWZ0KGl0ZW0uaW5kZXgoKSk7XG5cbiAgICAgICAgICAgIGlmICgkKGl0ZW1bMF0ucGFyZW50Tm9kZSlbMF0gIT09IHRoaXMuZHJhZ1Jvb3RFbFswXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5kZXhPZkl0ZW0oJChpdGVtWzBdLnBhcmVudE5vZGUpLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdFbC5kYXRhKCdpbmRleE9mSXRlbScsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZXN0b3JlSXRlbUF0SW5kZXg6IGZ1bmN0aW9uKGRyYWdFbGVtZW50LCBpbmRleEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEVsID0gdGhpcy5lbCxcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleEFycmF5Lmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIC8vUHV0IGRyYWcgZWxlbWVudCBhdCBjdXJyZW50IGVsZW1lbnQgcG9zaXRpb24uXG4gICAgICAgICAgICBmdW5jdGlvbiBwbGFjZUVsZW1lbnQoY3VycmVudEVsLCBkcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleEFycmF5W2xhc3RJbmRleF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgJChjdXJyZW50RWwpLnByZXBlbmQoZHJhZ0VsZW1lbnQuY2xvbmUodHJ1ZSkpOyAvL3VzaW5nIHRydWUgc2F2ZXMgYWRkZWQgdG8gZWxlbWVudCBldmVudHMuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkKGN1cnJlbnRFbC5jaGlsZHJlbltpbmRleEFycmF5W2xhc3RJbmRleF0gLSAxXSkuYWZ0ZXIoZHJhZ0VsZW1lbnQuY2xvbmUodHJ1ZSkpOyAvL3VzaW5nIHRydWUgc2F2ZXMgYWRkZWQgdG8gZWxlbWVudCBldmVudHMuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9EaWdnaW4gdGhyb3VnaCBpbmRleEFycmF5IHRvIGdldCBob21lIGZvciBkcmFnRWxlbWVudC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXhBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPT09IHBhcnNlSW50KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlRWxlbWVudChjdXJyZW50RWwsIGRyYWdFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2VsZW1lbnQgY2FuIGhhdmUgbm8gaW5kZXhlcywgc28gd2UgaGF2ZSB0byB1c2UgY29uZGl0aW9uYWwgaGVyZSB0byBhdm9pZCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgLy9pZiBlbGVtZW50IGRvZXNuJ3QgZXhpc3Qgd2UgZGVmZW5ldGx5IG5lZWQgdG8gYWRkIG5ldyBsaXN0LlxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gKGN1cnJlbnRFbFswXSkgPyBjdXJyZW50RWxbMF0gOiBjdXJyZW50RWw7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRFbCAgPSBlbGVtZW50LmNoaWxkcmVuW2luZGV4QXJyYXlbaV1dO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRFbCAgID0gKCFuZXh0RWwpID8gdGhpcy5jcmVhdGVTdWJMZXZlbCgkKGVsZW1lbnQpKSA6IG5leHRFbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkcmFnU3RvcDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy8gZml4IGZvciB6ZXB0by5qc1xuICAgICAgICAgICAgLy90aGlzLnBsYWNlRWwucmVwbGFjZVdpdGgodGhpcy5kcmFnRWwuY2hpbGRyZW4odGhpcy5vcHRpb25zLml0ZW1Ob2RlTmFtZSArICc6Zmlyc3QnKS5kZXRhY2goKSk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgdG9wICA6IGUucGFnZVksXG4gICAgICAgICAgICAgICAgbGVmdCA6IGUucGFnZVhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvL0dldCBpbmRleEFycmF5IG9mIGl0ZW0gYXQgZHJhZyBzdGFydC5cbiAgICAgICAgICAgIHZhciBzcmNJbmRleCA9IHRoaXMuZHJhZ0VsLmRhdGEoJ2luZGV4T2ZJdGVtJyk7XG5cbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZHJhZ0VsLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5pdGVtTm9kZU5hbWUpLmZpcnN0KCk7XG5cbiAgICAgICAgICAgIGVsWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxbMF0pO1xuXG4gICAgICAgICAgICB0aGlzLmRyYWdFbC5yZW1vdmUoKTsgLy9SZW1vdmUgZHJhZ0VsLCBjYXVzZSBpdCBjYW4gYWZmZWN0IG9uIGluZGV4aW5nIGluIGh0bWwgY29sbGVjdGlvbi5cblxuICAgICAgICAgICAgLy9CZWZvcmUgZHJhZyBzdG9wIGNhbGxiYWNrXG4gICAgICAgICAgICB2YXIgY29udGludWVFeGVjdXRpb24gPSB0aGlzLm9wdGlvbnMuYmVmb3JlRHJhZ1N0b3AuY2FsbCh0aGlzLCB0aGlzLmVsLCBlbCwgdGhpcy5wbGFjZUVsLnBhcmVudCgpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGludWVFeGVjdXRpb24gIT09ICd1bmRlZmluZWQnICYmIGNvbnRpbnVlRXhlY3V0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBsYWNlRWwucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZUVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50LmNoaWxkcmVuKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zZXRQYXJlbnQocGFyZW50LnBhcmVudCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlSXRlbUF0SW5kZXgoZWwsIHNyY0luZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBsYWNlRWwucmVwbGFjZVdpdGgoZWwpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNOZXdSb290KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5maXhlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVJdGVtQXRJbmRleChlbCwgc3JjSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC50cmlnZ2VyKCdsb3N0SXRlbScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdSb290RWwudHJpZ2dlcignZ2FpbmVkSXRlbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnUm9vdEVsLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLmRyYWdSb290RWwsIGVsLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmFnTW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGxpc3QsIHBhcmVudCwgcHJldiwgbmV4dCwgZGVwdGgsXG4gICAgICAgICAgICAgICAgb3B0ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG1vdXNlID0gdGhpcy5tb3VzZTtcblxuICAgICAgICAgICAgdGhpcy5kcmFnRWwuY3NzKHtcbiAgICAgICAgICAgICAgICAnbGVmdCc6IGUucGFnZVggLSBtb3VzZS5vZmZzZXRYLFxuICAgICAgICAgICAgICAgICd0b3AnOiBlLnBhZ2VZIC0gbW91c2Uub2Zmc2V0WVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIG1vdXNlIHBvc2l0aW9uIGxhc3QgZXZlbnRzXG4gICAgICAgICAgICBtb3VzZS5sYXN0WCA9IG1vdXNlLm5vd1g7XG4gICAgICAgICAgICBtb3VzZS5sYXN0WSA9IG1vdXNlLm5vd1k7XG4gICAgICAgICAgICAvLyBtb3VzZSBwb3NpdGlvbiB0aGlzIGV2ZW50c1xuICAgICAgICAgICAgbW91c2Uubm93WCA9IGUucGFnZVg7XG4gICAgICAgICAgICBtb3VzZS5ub3dZID0gZS5wYWdlWTtcbiAgICAgICAgICAgIC8vIGRpc3RhbmNlIG1vdXNlIG1vdmVkIGJldHdlZW4gZXZlbnRzXG4gICAgICAgICAgICBtb3VzZS5kaXN0WCA9IG1vdXNlLm5vd1ggLSBtb3VzZS5sYXN0WDtcbiAgICAgICAgICAgIG1vdXNlLmRpc3RZID0gbW91c2Uubm93WSAtIG1vdXNlLmxhc3RZO1xuICAgICAgICAgICAgLy8gZGlyZWN0aW9uIG1vdXNlIHdhcyBtb3ZpbmdcbiAgICAgICAgICAgIG1vdXNlLmxhc3REaXJYID0gbW91c2UuZGlyWDtcbiAgICAgICAgICAgIG1vdXNlLmxhc3REaXJZID0gbW91c2UuZGlyWTtcbiAgICAgICAgICAgIC8vIGRpcmVjdGlvbiBtb3VzZSBpcyBub3cgbW92aW5nIChvbiBib3RoIGF4aXMpXG4gICAgICAgICAgICBtb3VzZS5kaXJYID0gbW91c2UuZGlzdFggPT09IDAgPyAwIDogbW91c2UuZGlzdFggPiAwID8gMSA6IC0xO1xuICAgICAgICAgICAgbW91c2UuZGlyWSA9IG1vdXNlLmRpc3RZID09PSAwID8gMCA6IG1vdXNlLmRpc3RZID4gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgIC8vIGF4aXMgbW91c2UgaXMgbm93IG1vdmluZyBvblxuICAgICAgICAgICAgdmFyIG5ld0F4ID0gTWF0aC5hYnMobW91c2UuZGlzdFgpID4gTWF0aC5hYnMobW91c2UuZGlzdFkpID8gMSA6IDA7XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcgb24gZmlyc3QgbW92ZVxuICAgICAgICAgICAgaWYgKCFtb3VzZS5tb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICBtb3VzZS5kaXJBeCA9IG5ld0F4O1xuICAgICAgICAgICAgICAgIG1vdXNlLm1vdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkbyBzY3JvbGxpbmcgaWYgZW5hYmxlXG4gICAgICAgICAgICBpZiAob3B0LnNjcm9sbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmpRdWVyeS5mbi5zY3JvbGxQYXJlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsUGFyZW50ID0gdGhpcy5lbC5zY3JvbGxQYXJlbnQoKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbFBhcmVudCAhPT0gZG9jdW1lbnQgJiYgc2Nyb2xsUGFyZW50LnRhZ05hbWUgIT09ICdIVE1MJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvcHQuc2Nyb2xsVHJpZ2dlcnMuYm90dG9tICsgc2Nyb2xsUGFyZW50Lm9mZnNldEhlaWdodCkgLSBlLnBhZ2VZIDwgb3B0LnNjcm9sbFNlbnNpdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgKyBvcHQuc2Nyb2xsU3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlLnBhZ2VZIC0gb3B0LnNjcm9sbFRyaWdnZXJzLnRvcCA8IG9wdC5zY3JvbGxTZW5zaXRpdml0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wIC0gb3B0LnNjcm9sbFNwZWVkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9wdC5zY3JvbGxUcmlnZ2Vycy5yaWdodCArIHNjcm9sbFBhcmVudC5vZmZzZXRXaWR0aCkgLSBlLnBhZ2VYIDwgb3B0LnNjcm9sbFNlbnNpdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCArIG9wdC5zY3JvbGxTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUucGFnZVggLSBvcHQuc2Nyb2xsVHJpZ2dlcnMubGVmdCA8IG9wdC5zY3JvbGxTZW5zaXRpdml0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgLSBvcHQuc2Nyb2xsU3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5wYWdlWSAtICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDwgb3B0LnNjcm9sbFNlbnNpdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIC0gb3B0LnNjcm9sbFNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCQod2luZG93KS5oZWlnaHQoKSAtIChlLnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkpIDwgb3B0LnNjcm9sbFNlbnNpdGl2aXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpICsgb3B0LnNjcm9sbFNwZWVkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgPCBvcHQuc2Nyb2xsU2Vuc2l0aXZpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSAtIG9wdC5zY3JvbGxTcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgkKHdpbmRvdykud2lkdGgoKSAtIChlLnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpKSA8IG9wdC5zY3JvbGxTZW5zaXRpdml0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpICsgb3B0LnNjcm9sbFNwZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVG8gdXNlIHNjcm9sbGluZyB5b3UgbmVlZCB0byBoYXZlIHNjcm9sbFBhcmVudCgpIGZ1bmN0aW9uLCBjaGVjayBkb2N1bWVudGF0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxUaW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNjcm9sbFRpbWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdC5zY3JvbGwgJiYgc2Nyb2xsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoZSk7XG4gICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxjIGRpc3RhbmNlIG1vdmVkIG9uIHRoaXMgYXhpcyAoYW5kIGRpcmVjdGlvbilcbiAgICAgICAgICAgIGlmIChtb3VzZS5kaXJBeCAhPT0gbmV3QXgpIHtcbiAgICAgICAgICAgICAgICBtb3VzZS5kaXN0QXhYID0gMDtcbiAgICAgICAgICAgICAgICBtb3VzZS5kaXN0QXhZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdXNlLmRpc3RBeFggKz0gTWF0aC5hYnMobW91c2UuZGlzdFgpO1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZS5kaXJYICE9PSAwICYmIG1vdXNlLmRpclggIT09IG1vdXNlLmxhc3REaXJYKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlLmRpc3RBeFggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb3VzZS5kaXN0QXhZICs9IE1hdGguYWJzKG1vdXNlLmRpc3RZKTtcbiAgICAgICAgICAgICAgICBpZiAobW91c2UuZGlyWSAhPT0gMCAmJiBtb3VzZS5kaXJZICE9PSBtb3VzZS5sYXN0RGlyWSkge1xuICAgICAgICAgICAgICAgICAgICBtb3VzZS5kaXN0QXhZID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb3VzZS5kaXJBeCA9IG5ld0F4O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIG1vdmUgaG9yaXpvbnRhbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobW91c2UuZGlyQXggJiYgbW91c2UuZGlzdEF4WCA+PSBvcHQudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgbW92ZSBkaXN0YW5jZSBvbiB4LWF4aXMgZm9yIG5ldyBwaGFzZVxuICAgICAgICAgICAgICAgIG1vdXNlLmRpc3RBeFggPSAwO1xuICAgICAgICAgICAgICAgIHByZXYgPSB0aGlzLnBsYWNlRWwucHJldihvcHQuaXRlbU5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBpbmNyZWFzZSBob3Jpem9udGFsIGxldmVsIGlmIHByZXZpb3VzIHNpYmxpbmcgZXhpc3RzLCBpcyBub3QgY29sbGFwc2VkLCBhbmQgY2FuIGhhdmUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBpZiAobW91c2UuZGlzdFggPiAwICYmIHByZXYubGVuZ3RoICYmICFwcmV2Lmhhc0NsYXNzKG9wdC5jb2xsYXBzZWRDbGFzcykgJiYgIXByZXYuaGFzQ2xhc3Mob3B0Lm5vQ2hpbGRyZW5DbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2Fubm90IGluY3JlYXNlIGxldmVsIHdoZW4gaXRlbSBhYm92ZSBpcyBjb2xsYXBzZWRcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHByZXYuZmluZChvcHQubGlzdE5vZGVOYW1lKS5sYXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlcHRoIGxpbWl0IGhhcyByZWFjaGVkXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoID0gdGhpcy5wbGFjZUVsLnBhcmVudHMob3B0Lmxpc3ROb2RlTmFtZSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggKyB0aGlzLmRyYWdEZXB0aCA8PSBvcHQubWF4RGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgc3ViLWxldmVsIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTdWJMZXZlbChwcmV2LCB0aGlzLnBsYWNlRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBhcHBlbmQgdG8gbmV4dCBsZXZlbCB1cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBwcmV2LmNoaWxkcmVuKG9wdC5saXN0Tm9kZU5hbWUpLmxhc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LmFwcGVuZCh0aGlzLnBsYWNlRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRlY3JlYXNlIGhvcml6b250YWwgbGV2ZWxcbiAgICAgICAgICAgICAgICBpZiAobW91c2UuZGlzdFggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IGRlY3JlYXNlIGEgbGV2ZWwgaWYgYW4gaXRlbSBwcmVjZWVkcyB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMucGxhY2VFbC5uZXh0KG9wdC5pdGVtTm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBsYWNlRWwucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYWNlRWwuY2xvc2VzdChvcHQuaXRlbU5vZGVOYW1lKS5hZnRlcih0aGlzLnBsYWNlRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQuY2hpbGRyZW4oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc2V0UGFyZW50KHBhcmVudC5wYXJlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgbGlzdCBpdGVtIHVuZGVyIGN1cnNvclxuICAgICAgICAgICAgaWYgKCFoYXNQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnRWxbMF0uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb2ludEVsID0gJChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUucGFnZVggLSBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsIGUucGFnZVkgLSAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApKSk7XG4gICAgICAgICAgICBpZiAoIWhhc1BvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdFbFswXS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRFbC5oYXNDbGFzcyhvcHQuaGFuZGxlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludEVsID0gdGhpcy5wb2ludEVsLmNsb3Nlc3Qob3B0Lml0ZW1Ob2RlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb2ludEVsLmhhc0NsYXNzKG9wdC5lbXB0eUNsYXNzKSkge1xuICAgICAgICAgICAgICAgIGlzRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMucG9pbnRFbC5sZW5ndGggfHwgIXRoaXMucG9pbnRFbC5oYXNDbGFzcyhvcHQuaXRlbUNsYXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmluZCBwYXJlbnQgbGlzdCBvZiBpdGVtIHVuZGVyIGN1cnNvclxuICAgICAgICAgICAgdmFyIHBvaW50RWxSb290ID0gdGhpcy5wb2ludEVsLmNsb3Nlc3QoJy4nICsgb3B0LnJvb3RDbGFzcyksXG4gICAgICAgICAgICAgICAgaXNOZXdSb290ID0gdGhpcy5kcmFnUm9vdEVsLmRhdGEoJ25lc3RhYmxlLWlkJykgIT09IHBvaW50RWxSb290LmRhdGEoJ25lc3RhYmxlLWlkJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogbW92ZSB2ZXJ0aWNhbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIW1vdXNlLmRpckF4IHx8IGlzTmV3Um9vdCB8fCBpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZ3JvdXBzIG1hdGNoIGlmIGRyYWdnaW5nIG92ZXIgbmV3IHJvb3RcbiAgICAgICAgICAgICAgICBpZiAoaXNOZXdSb290ICYmIG9wdC5ncm91cCAhPT0gcG9pbnRFbFJvb3QuZGF0YSgnbmVzdGFibGUtZ3JvdXAnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZml4ZWQgaXRlbSdzIGRlcHRoLCB1c2UgZm9yIHNvbWUgbGlzdCBoYXMgc3BlY2lmaWMgdHlwZSwgZWc6J1ZvbHVtZSwgU2VjdGlvbiwgQ2hhcHRlciAuLi4nXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5maXhlZERlcHRoICYmIHRoaXMuZHJhZ0RlcHRoICsgMSAhPT0gdGhpcy5wb2ludEVsLnBhcmVudHMob3B0Lmxpc3ROb2RlTmFtZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBkZXB0aCBsaW1pdFxuICAgICAgICAgICAgICAgIGRlcHRoID0gdGhpcy5kcmFnRGVwdGggLSAxICsgdGhpcy5wb2ludEVsLnBhcmVudHMob3B0Lmxpc3ROb2RlTmFtZSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+IG9wdC5tYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBlLnBhZ2VZIDwgKHRoaXMucG9pbnRFbC5vZmZzZXQoKS50b3AgKyB0aGlzLnBvaW50RWwuaGVpZ2h0KCkgLyAyKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBsYWNlRWwucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgZW1wdHkgY3JlYXRlIG5ldyBsaXN0IHRvIHJlcGxhY2UgZW1wdHkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KG9wdC5saXN0Tm9kZU5hbWUpKS5hZGRDbGFzcyhvcHQubGlzdENsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5hcHBlbmQodGhpcy5wbGFjZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEVsLnJlcGxhY2VXaXRoKGxpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEVsLmJlZm9yZSh0aGlzLnBsYWNlRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEVsLmFmdGVyKHRoaXMucGxhY2VFbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50LmNoaWxkcmVuKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zZXRQYXJlbnQocGFyZW50LnBhcmVudCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRyYWdSb290RWwuZmluZChvcHQuaXRlbU5vZGVOYW1lKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFbXB0eUVsZW1lbnQodGhpcy5kcmFnUm9vdEVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IHJvb3QgbGlzdCBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1Jvb3RFbCA9IHBvaW50RWxSb290O1xuICAgICAgICAgICAgICAgIGlmIChpc05ld1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNOZXdSb290ID0gdGhpcy5lbFswXSAhPT0gdGhpcy5kcmFnUm9vdEVsWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBcHBlbmQgdGhlIC5kZC1lbXB0eSBkaXYgdG8gdGhlIGxpc3Qgc28gaXQgY2FuIGJlIHBvcHVsYXRlZCBhbmQgc3R5bGVkXG4gICAgICAgIGFwcGVuZEVtcHR5RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmQoJzxkaXYgY2xhc3M9XCInICsgdGhpcy5vcHRpb25zLmVtcHR5Q2xhc3MgKyAnXCIvPicpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4ubmVzdGFibGUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxpc3RzICA9IHRoaXMsXG4gICAgICAgICAgICByZXR2YWwgPSB0aGlzLFxuICAgICAgICAgICAgYXJncyAgID0gYXJndW1lbnRzO1xuXG4gICAgICAgIGlmICghKCdOZXN0YWJsZScgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgd2luZG93Lk5lc3RhYmxlID0ge307XG4gICAgICAgICAgICBOZXN0YWJsZS5jb3VudGVyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gJCh0aGlzKS5kYXRhKFwibmVzdGFibGVcIik7XG5cbiAgICAgICAgICAgIGlmICghcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgTmVzdGFibGUuY291bnRlcisrO1xuICAgICAgICAgICAgICAgICQodGhpcykuZGF0YShcIm5lc3RhYmxlXCIsIG5ldyBQbHVnaW4odGhpcywgcGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5kYXRhKFwibmVzdGFibGUtaWRcIiwgTmVzdGFibGUuY291bnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHBsdWdpbltwYXJhbXNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpbkFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbkFyZ3MucHVzaChhcmdzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHBsdWdpbltwYXJhbXNdLmFwcGx5KHBsdWdpbiwgcGx1Z2luQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBwbHVnaW5bcGFyYW1zXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmV0dmFsIHx8IGxpc3RzO1xuICAgIH07XG5cbn0pKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvLCB3aW5kb3csIGRvY3VtZW50KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/nestable2/jquery.nestable.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyx1REFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0EsS0FBSyxLQUF3QyxFQUFFLEVBRTdDOztBQUVGLFFBQVEsc0JBQWlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcmVudCkge1xuICBpZiAocGFyZW50KXtcbiAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQsIHBhcmVudCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlLCB0YXJnZXQpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXG5cdGlmKG9wdGlvbnMuYXR0cnMubm9uY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBub25jZSA9IGdldE5vbmNlKCk7XG5cdFx0aWYgKG5vbmNlKSB7XG5cdFx0XHRvcHRpb25zLmF0dHJzLm5vbmNlID0gbm9uY2U7XG5cdFx0fVxuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uY2UoKSB7XG5cdGlmICh0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gdHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nXG5cdFx0ID8gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcykgXG5cdFx0IDogb3B0aW9ucy50cmFuc2Zvcm0uZGVmYXVsdChvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./resources/js/admin/auto-complete-tag/mab-jquery-taginput.css":
/*!**********************************************************************!*\
  !*** ./resources/js/admin/auto-complete-tag/mab-jquery-taginput.css ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../../node_modules/css-loader??ref--6-1!../../../../node_modules/postcss-loader/src??ref--6-2!./mab-jquery-taginput.css */ \"./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js?!./resources/js/admin/auto-complete-tag/mab-jquery-taginput.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYWRtaW4vYXV0by1jb21wbGV0ZS10YWcvbWFiLWpxdWVyeS10YWdpbnB1dC5jc3M/MjM2ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHNSQUFtSjs7QUFFekssNENBQTRDLFFBQVM7O0FBRXJEO0FBQ0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDRHQUF5RDs7QUFFOUU7O0FBRUEsR0FBRyxLQUFVLEVBQUUiLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYWRtaW4vYXV0by1jb21wbGV0ZS10YWcvbWFiLWpxdWVyeS10YWdpbnB1dC5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNi0yIS4vbWFiLWpxdWVyeS10YWdpbnB1dC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTYtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTYtMiEuL21hYi1qcXVlcnktdGFnaW5wdXQuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNi0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNi0yIS4vbWFiLWpxdWVyeS10YWdpbnB1dC5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/admin/auto-complete-tag/mab-jquery-taginput.css\n");

/***/ }),

/***/ "./resources/js/admin/auto-complete-tag/mab-jquery-taginput.js":
/*!*********************************************************************!*\
  !*** ./resources/js/admin/auto-complete-tag/mab-jquery-taginput.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\r\n * jQuery lightweight plugin boilerplate\r\n * Original author: @ajpiano\r\n * Further changes, comments: @addyosmani\r\n * Licensed under the MIT license\r\n */\n;\n\n(function ($, window, document, undefined) {\n  // Create the defaults once\n  var pluginName = 'tagInput',\n      defaults = {\n    tagDataSeparator: '|',\n    allowDuplicates: false,\n    typeahead: false,\n    typeaheadOptions: null,\n    typeaheadDatasetOptions: null,\n    onTagDataChanged: function onTagDataChanged(added, removed) {// Within the callback, 'this' will be the tag data input instance, \n      // so updated tag data can be accessed using this.val()\n    }\n  },\n      // Lookup variables to make keycode handling more readable\n  KEYCODES = {\n    ENTER: 13,\n    TAB: 9,\n    BACKSPACE: 8\n  }; // The actual plugin constructor\n\n  function Plugin(element, options) {\n    this.options = $.extend({}, defaults, options);\n    this._defaults = defaults;\n    this._name = pluginName;\n    this.input = this.init(element).find('input.mab-jquery-taginput-data');\n  } // Remove all entries from an array with a specific value\n\n\n  var _cleanArray = function _cleanArray(arr, deleteValue) {\n    // If no value has been specified, remove all empty strings\n    if (typeof deleteValue === 'undefined') deleteValue = '';\n\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == deleteValue) {\n        arr.splice(i, 1);\n        i--;\n      }\n    }\n\n    return arr;\n  }; // Function to create the HTML representing the tag input control\n\n\n  var _createTagInput = function _createTagInput(input, tagDataSeparator) {\n    var tags = _cleanArray(input.val().split(tagDataSeparator));\n\n    var tagLabels = $.map(tags, _createTag).join('');\n    return $('<div class=\"mab-jquery-taginput' + (input.attr('class') ? ' ' + input.attr('class') : '') + '\">' + tagLabels + '<input class=\"mab-jquery-taginput-data\" type=\"hidden\" name=\"' + input.attr('name') + '\" id=\"' + input.attr('name') + '\" value=\"' + input.val() + '\">' + '<input class=\"mab-jquery-taginput-input\" type=\"text\"' + (input.is('[placeholder]') ? ' placeholder=\"' + input.attr('placeholder') : '') + '\">' + '</div>');\n  }; // Create HTML representing a tag\n\n\n  var _createTag = function _createTag(tag) {\n    return '<span class=\"label label-primary\" data-tag=\"' + tag + '\">' + tag + ' <span class=\"glyphicon glyphicon-remove\"></span></span>';\n  }; // Shortcut function to clear text from the tag input and close the typeahead\n\n\n  var _resetTagInput = function _resetTagInput(input, usingTypeahead) {\n    if (usingTypeahead) {\n      input.typeahead('val', '');\n      input.typeahead('close');\n    } else {\n      input.val('');\n    }\n  };\n\n  var _addTagToDataField = function _addTagToDataField(tagDataField, separator, tag) {\n    // Concatenate the existing tag data string with the new tag\n    // if the field value wasn't an empty string\n    if ($.trim(tagDataField.val()) === '') tagDataField.val(tag);else tagDataField.val(tagDataField.val() + separator + tag);\n  };\n\n  var _removeTagFromDataField = function _removeTagFromDataField(tagDataField, separator, tag) {\n    // Slightly weird code, but basically we tack a pipe char onto the end\n    // of the current tag data string (so that our replace works even if the tag is\n    // the last in the string), remove the tag and return the new string minus \n    // the final character (which will always be a pipe character)\n    tagDataField.val((tagDataField.val() + separator).replace(tag + separator, '').slice(0, -1));\n  };\n\n  var _removeLastTagFromDataField = function _removeLastTagFromDataField(tagDataField, separator) {\n    // Split the data into an array, remove the last element and join it\n    // back together again with pipe characters\n    tagDataField.val(tagDataField.val().split(separator).slice(0, -1).join(separator));\n  };\n\n  Plugin.prototype = {\n    init: function init(element) {\n      // Boolean to determine whether typeahead.js integration is enabled\n      var usingTypeahead = this.options.typeahead; // Boolean to determine whether the same tag can be added to the input more than once\n\n      var allowDuplicates = this.options.allowDuplicates; // Character to use as a separator for the tag data (default is pipe '|')\n\n      var separator = this.options.tagDataSeparator; // Callback function to be fired on tag add/remove\n\n      var onTagDataChanged = this.options.onTagDataChanged; // Replace the original input with the tag input HTML\n\n      var originalInput = $(element);\n\n      var tagInputContainer = _createTagInput(originalInput, separator);\n\n      originalInput.replaceWith(tagInputContainer); // The text input element within the tag control\n\n      var tagInput = tagInputContainer.find('.mab-jquery-taginput-input'); // The hidden input which is used to store selected tag data\n\n      var tagData = tagInputContainer.find('.mab-jquery-taginput-data'); // Keep hold of the original placeholder text\n\n      var originalPlaceHolder = tagInput.attr('placeholder'); // Set up the typeahead if specified\n\n      if (usingTypeahead) tagInput.typeahead(this.options.typeaheadOptions, this.options.typeaheadDatasetOptions); // Handle keypress in the tag text input\n\n      tagInput.on('keypress', function (e) {\n        // If someone tries to type the character we're using as a data separator, \n        // don't let them! This avoids tags being unexpectedly split when they are saved.\n        if (e.keyCode == separator.charCodeAt(0)) return false;\n      }); // Handle keydown events on the tag text input\n\n      tagInput.on('keydown typeahead:selected', function (e) {\n        // Cache the reference to the input\n        var input = $(this); // If enter is hit, and the input is *not* empty (if the input *is* empty, \n        // we don't want to prevent the default action, which is submitting the form)\n\n        if (e.type === 'typeahead:selected' || e.keyCode == KEYCODES.ENTER && $.trim(input.val()) !== '') {\n          // Stop the form being submitted and prevent event bubbling\n          e.preventDefault();\n          e.stopPropagation();\n          var newTag = $.trim(input.val()); // Get the index of the tag in the tag data (-1 if not already present)\n\n          var tagIndex = $.inArray(newTag, tagData.val().split(separator)); // Don't allow the addition of duplicate tags unless explicitly specified\n\n          if (allowDuplicates || tagIndex === -1) {\n            // Insert a new tag span before the hidden input\n            tagData.before(_createTag(newTag));\n\n            _addTagToDataField(tagData, separator, newTag); // Reset the tag input\n\n\n            _resetTagInput(input, usingTypeahead);\n\n            input.attr('placeholder', '');\n            onTagDataChanged.call(tagData, newTag, null);\n          } else {\n            // Highlight the duplicate tag\n            var existing = tagInputContainer.find('span.label[data-tag=\"' + newTag + '\"]');\n            existing.removeClass('label-primary').addClass('label-danger'); // Reset the tag input\n\n            _resetTagInput(input, usingTypeahead);\n\n            setTimeout(function () {\n              existing.removeClass('label-danger').addClass('label-primary');\n            }, 1500);\n          }\n        } // If backspace is hit and there's nothing in the input (if the input *isn't* empty, \n        // we don't want to prevent the default action, which is deleting a character)\n\n\n        if (e.keyCode == KEYCODES.BACKSPACE && $.trim(input.val()) === '') {\n          // Remove the last tag span before the hidden data input\n          var tagRemoved = $.trim(tagData.prev('span.label').text());\n          tagData.prev('span.label').remove();\n\n          _removeLastTagFromDataField(tagData, separator); // Reset the tag input\n\n\n          _resetTagInput(input, usingTypeahead);\n\n          if (tagData.val() === '') input.attr('placeholder', originalPlaceHolder);\n          onTagDataChanged.call(tagData, null, tagRemoved);\n        }\n      }); // Handle focus and blur on the text input\n\n      tagInputContainer.on('focus', 'input[type=text]', function (e) {\n        // Remove the narrowing class, restoring input to its original width\n        tagInputContainer.find('input[type=text]').removeClass('h');\n      }).on('blur', 'input[type=text]', function (e) {\n        // When the tag text input loses focus, add a class which narrows it\n        // to 1px wide (this is to avoid odd visual effects when the tags in \n        // the control wraps onto multiple lines)\n        if (tagData.val() !== '') tagInputContainer.find('input[type=text]').addClass('h'); // Reset the tag input\n\n        _resetTagInput(tagInput, usingTypeahead);\n      }); // Focus the text input when the control container is clicked, which triggers\n      // the show/hide behaviours defined in the handlers above\n\n      tagInputContainer.on('click', function (e) {\n        if (usingTypeahead) tagInputContainer.find('input[type=text].tt-input').focus();else tagInputContainer.find('input[type=text]').focus();\n      }); // Handle tag delete icon click\n\n      tagInputContainer.on('click', 'span.glyphicon', function (e) {\n        // Don't bubble the click event up to the input container\n        // This would cause the text input to be shown by the container's click event\n        e.stopPropagation(); // Get the text of the tag to be removed (parent of this is the label span)\n\n        var tag = $(this).parent();\n        var tagText = $.trim(tag.text());\n\n        _removeTagFromDataField(tagData, separator, tagText);\n\n        tag.remove();\n        onTagDataChanged.call(tagData, null, tagText);\n      }); // If the control already has some tags in it\n\n      if (tagData.val() !== '') {\n        // Remove the placeholder text\n        tagInput.attr('placeholder', ''); // Initially blur the text input so it's hidden on load\n\n        tagInputContainer.find('input[type=text]').blur();\n      }\n\n      return tagInputContainer;\n    }\n  }; // A really lightweight plugin wrapper around the constructor,\n  // preventing against multiple instantiations\n\n  $.fn[pluginName] = function (options) {\n    return this.each(function () {\n      var input = $(this);\n\n      if (!input.data(\"plugin_\" + pluginName)) {\n        var instance = new Plugin(this, options);\n        instance.input.data(\"plugin_\" + pluginName, instance);\n      }\n    });\n  };\n})(jQuery, window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYWRtaW4vYXV0by1jb21wbGV0ZS10YWcvbWFiLWpxdWVyeS10YWdpbnB1dC5qcz9kZjk0Il0sIm5hbWVzIjpbIiQiLCJ3aW5kb3ciLCJkb2N1bWVudCIsInVuZGVmaW5lZCIsInBsdWdpbk5hbWUiLCJkZWZhdWx0cyIsInRhZ0RhdGFTZXBhcmF0b3IiLCJhbGxvd0R1cGxpY2F0ZXMiLCJ0eXBlYWhlYWQiLCJ0eXBlYWhlYWRPcHRpb25zIiwidHlwZWFoZWFkRGF0YXNldE9wdGlvbnMiLCJvblRhZ0RhdGFDaGFuZ2VkIiwiYWRkZWQiLCJyZW1vdmVkIiwiS0VZQ09ERVMiLCJFTlRFUiIsIlRBQiIsIkJBQ0tTUEFDRSIsIlBsdWdpbiIsImVsZW1lbnQiLCJvcHRpb25zIiwiZXh0ZW5kIiwiX2RlZmF1bHRzIiwiX25hbWUiLCJpbnB1dCIsImluaXQiLCJmaW5kIiwiX2NsZWFuQXJyYXkiLCJhcnIiLCJkZWxldGVWYWx1ZSIsImkiLCJsZW5ndGgiLCJzcGxpY2UiLCJfY3JlYXRlVGFnSW5wdXQiLCJ0YWdzIiwidmFsIiwic3BsaXQiLCJ0YWdMYWJlbHMiLCJtYXAiLCJfY3JlYXRlVGFnIiwiam9pbiIsImF0dHIiLCJpcyIsInRhZyIsIl9yZXNldFRhZ0lucHV0IiwidXNpbmdUeXBlYWhlYWQiLCJfYWRkVGFnVG9EYXRhRmllbGQiLCJ0YWdEYXRhRmllbGQiLCJzZXBhcmF0b3IiLCJ0cmltIiwiX3JlbW92ZVRhZ0Zyb21EYXRhRmllbGQiLCJyZXBsYWNlIiwic2xpY2UiLCJfcmVtb3ZlTGFzdFRhZ0Zyb21EYXRhRmllbGQiLCJwcm90b3R5cGUiLCJvcmlnaW5hbElucHV0IiwidGFnSW5wdXRDb250YWluZXIiLCJyZXBsYWNlV2l0aCIsInRhZ0lucHV0IiwidGFnRGF0YSIsIm9yaWdpbmFsUGxhY2VIb2xkZXIiLCJvbiIsImUiLCJrZXlDb2RlIiwiY2hhckNvZGVBdCIsInR5cGUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIm5ld1RhZyIsInRhZ0luZGV4IiwiaW5BcnJheSIsImJlZm9yZSIsImNhbGwiLCJleGlzdGluZyIsInJlbW92ZUNsYXNzIiwiYWRkQ2xhc3MiLCJzZXRUaW1lb3V0IiwidGFnUmVtb3ZlZCIsInByZXYiLCJ0ZXh0IiwicmVtb3ZlIiwiZm9jdXMiLCJwYXJlbnQiLCJ0YWdUZXh0IiwiYmx1ciIsImZuIiwiZWFjaCIsImRhdGEiLCJpbnN0YW5jZSIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU9BOztBQUFDLENBQUMsVUFBV0EsQ0FBWCxFQUFjQyxNQUFkLEVBQXNCQyxRQUF0QixFQUFnQ0MsU0FBaEMsRUFBNEM7QUFFMUM7QUFDQSxNQUFJQyxVQUFVLEdBQUcsVUFBakI7QUFBQSxNQUNJQyxRQUFRLEdBQUc7QUFDUEMsb0JBQWdCLEVBQUUsR0FEWDtBQUVQQyxtQkFBZSxFQUFFLEtBRlY7QUFHUEMsYUFBUyxFQUFFLEtBSEo7QUFJUEMsb0JBQWdCLEVBQUUsSUFKWDtBQUtQQywyQkFBdUIsRUFBRSxJQUxsQjtBQU1QQyxvQkFBZ0IsRUFBRSwwQkFBU0MsS0FBVCxFQUFnQkMsT0FBaEIsRUFBeUIsQ0FDdkM7QUFDQTtBQUNIO0FBVE0sR0FEZjtBQUFBLE1BWUk7QUFDQUMsVUFBUSxHQUFHO0FBQ1BDLFNBQUssRUFBRSxFQURBO0FBRVBDLE9BQUcsRUFBRSxDQUZFO0FBR1BDLGFBQVMsRUFBRTtBQUhKLEdBYmYsQ0FIMEMsQ0FzQjFDOztBQUNBLFdBQVNDLE1BQVQsQ0FBZ0JDLE9BQWhCLEVBQXlCQyxPQUF6QixFQUFrQztBQUM5QixTQUFLQSxPQUFMLEdBQWVwQixDQUFDLENBQUNxQixNQUFGLENBQVMsRUFBVCxFQUFhaEIsUUFBYixFQUF1QmUsT0FBdkIsQ0FBZjtBQUVBLFNBQUtFLFNBQUwsR0FBaUJqQixRQUFqQjtBQUNBLFNBQUtrQixLQUFMLEdBQWFuQixVQUFiO0FBRUEsU0FBS29CLEtBQUwsR0FBYSxLQUFLQyxJQUFMLENBQVVOLE9BQVYsRUFBbUJP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QUNIO0FBakljLEdBQW5CLENBbEcwQyxDQXNPMUM7QUFDQTs7QUFDQXhELEdBQUMsQ0FBQ3FGLEVBQUYsQ0FBS2pGLFVBQUwsSUFBbUIsVUFBVWdCLE9BQVYsRUFBbUI7QUFDbEMsV0FBTyxLQUFLa0UsSUFBTCxDQUFVLFlBQVc7QUFDeEIsVUFBSTlELEtBQUssR0FBR3hCLENBQUMsQ0FBQyxJQUFELENBQWI7O0FBQ0EsVUFBSSxDQUFDd0IsS0FBSyxDQUFDK0QsSUFBTixDQUFXLFlBQVluRixVQUF2QixDQUFMLEVBQXlDO0FBQ3JDLFlBQUlvRixRQUFRLEdBQUcsSUFBSXRFLE1BQUosQ0FBVyxJQUFYLEVBQWlCRSxPQUFqQixDQUFmO0FBQ0FvRSxnQkFBUSxDQUFDaEUsS0FBVCxDQUFlK0QsSUFBZixDQUFvQixZQUFZbkYsVUFBaEMsRUFBNENvRixRQUE1QztBQUNIO0FBQ0osS0FOTSxDQUFQO0FBT0gsR0FSRDtBQVVILENBbFBBLEVBa1BFQyxNQWxQRixFQWtQVXhGLE1BbFBWLEVBa1BrQkMsUUFsUGxCIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2FkbWluL2F1dG8tY29tcGxldGUtdGFnL21hYi1qcXVlcnktdGFnaW5wdXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogalF1ZXJ5IGxpZ2h0d2VpZ2h0IHBsdWdpbiBib2lsZXJwbGF0ZVxyXG4gKiBPcmlnaW5hbCBhdXRob3I6IEBhanBpYW5vXHJcbiAqIEZ1cnRoZXIgY2hhbmdlcywgY29tbWVudHM6IEBhZGR5b3NtYW5pXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuXHJcbjsoZnVuY3Rpb24gKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHRoZSBkZWZhdWx0cyBvbmNlXHJcbiAgICB2YXIgcGx1Z2luTmFtZSA9ICd0YWdJbnB1dCcsXHJcbiAgICAgICAgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIHRhZ0RhdGFTZXBhcmF0b3I6ICd8JyxcclxuICAgICAgICAgICAgYWxsb3dEdXBsaWNhdGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgdHlwZWFoZWFkOiBmYWxzZSxcclxuICAgICAgICAgICAgdHlwZWFoZWFkT3B0aW9uczogbnVsbCxcclxuICAgICAgICAgICAgdHlwZWFoZWFkRGF0YXNldE9wdGlvbnM6IG51bGwsXHJcbiAgICAgICAgICAgIG9uVGFnRGF0YUNoYW5nZWQ6IGZ1bmN0aW9uKGFkZGVkLCByZW1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXaXRoaW4gdGhlIGNhbGxiYWNrLCAndGhpcycgd2lsbCBiZSB0aGUgdGFnIGRhdGEgaW5wdXQgaW5zdGFuY2UsIFxyXG4gICAgICAgICAgICAgICAgLy8gc28gdXBkYXRlZCB0YWcgZGF0YSBjYW4gYmUgYWNjZXNzZWQgdXNpbmcgdGhpcy52YWwoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBMb29rdXAgdmFyaWFibGVzIHRvIG1ha2Uga2V5Y29kZSBoYW5kbGluZyBtb3JlIHJlYWRhYmxlXHJcbiAgICAgICAgS0VZQ09ERVMgPSB7XHJcbiAgICAgICAgICAgIEVOVEVSOiAxMyxcclxuICAgICAgICAgICAgVEFCOiA5LFxyXG4gICAgICAgICAgICBCQUNLU1BBQ0U6IDhcclxuICAgICAgICB9O1xyXG5cclxuICAgIC8vIFRoZSBhY3R1YWwgcGx1Z2luIGNvbnN0cnVjdG9yXHJcbiAgICBmdW5jdGlvbiBQbHVnaW4oZWxlbWVudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucykgO1xyXG5cclxuICAgICAgICB0aGlzLl9kZWZhdWx0cyA9IGRlZmF1bHRzO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBwbHVnaW5OYW1lO1xyXG5cclxuICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5pbml0KGVsZW1lbnQpLmZpbmQoJ2lucHV0Lm1hYi1qcXVlcnktdGFnaW5wdXQtZGF0YScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBhbGwgZW50cmllcyBmcm9tIGFuIGFycmF5IHdpdGggYSBzcGVjaWZpYyB2YWx1ZVxyXG4gICAgdmFyIF9jbGVhbkFycmF5ID0gZnVuY3Rpb24oYXJyLCBkZWxldGVWYWx1ZSkge1xyXG4gICAgICAgIC8vIElmIG5vIHZhbHVlIGhhcyBiZWVuIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBlbXB0eSBzdHJpbmdzXHJcbiAgICAgICAgaWYodHlwZW9mIGRlbGV0ZVZhbHVlID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgZGVsZXRlVmFsdWUgPSAnJztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFycltpXSA9PSBkZWxldGVWYWx1ZSkgeyAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBIVE1MIHJlcHJlc2VudGluZyB0aGUgdGFnIGlucHV0IGNvbnRyb2xcclxuICAgIHZhciBfY3JlYXRlVGFnSW5wdXQgPSBmdW5jdGlvbihpbnB1dCwgdGFnRGF0YVNlcGFyYXRvcikge1xyXG4gICAgICAgIHZhciB0YWdzID0gX2NsZWFuQXJyYXkoaW5wdXQudmFsKCkuc3BsaXQodGFnRGF0YVNlcGFyYXRvcikpO1xyXG4gICAgICAgIHZhciB0YWdMYWJlbHMgPSAkLm1hcCh0YWdzLCBfY3JlYXRlVGFnKS5qb2luKCcnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICQoJzxkaXYgY2xhc3M9XCJtYWItanF1ZXJ5LXRhZ2lucHV0JyArICgoaW5wdXQuYXR0cignY2xhc3MnKSkgPyAnICcgKyBpbnB1dC5hdHRyKCdjbGFzcycpIDogJycpICsgJ1wiPicgKyBcclxuICAgICAgICAgICAgICAgICB0YWdMYWJlbHMgKyBcclxuICAgICAgICAgICAgICAgICAnPGlucHV0IGNsYXNzPVwibWFiLWpxdWVyeS10YWdpbnB1dC1kYXRhXCIgdHlwZT1cImhpZGRlblwiIG5hbWU9XCInICsgaW5wdXQuYXR0cignbmFtZScpICsgJ1wiIGlkPVwiJyArIGlucHV0LmF0dHIoJ25hbWUnKSArICdcIiB2YWx1ZT1cIicgKyBpbnB1dC52YWwoKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICAnPGlucHV0IGNsYXNzPVwibWFiLWpxdWVyeS10YWdpbnB1dC1pbnB1dFwiIHR5cGU9XCJ0ZXh0XCInICsgKGlucHV0LmlzKCdbcGxhY2Vob2xkZXJdJykgPyAnIHBsYWNlaG9sZGVyPVwiJyArIGlucHV0LmF0dHIoJ3BsYWNlaG9sZGVyJykgOiAnJykgKyAnXCI+JyArIFxyXG4gICAgICAgICAgICAgICAgICc8L2Rpdj4nKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ3JlYXRlIEhUTUwgcmVwcmVzZW50aW5nIGEgdGFnXHJcbiAgICB2YXIgX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uKHRhZykge1xyXG4gICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1wcmltYXJ5XCIgZGF0YS10YWc9XCInICsgdGFnICsgJ1wiPicgKyB0YWcgKyAnIDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmVcIj48L3NwYW4+PC9zcGFuPic7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIGNsZWFyIHRleHQgZnJvbSB0aGUgdGFnIGlucHV0IGFuZCBjbG9zZSB0aGUgdHlwZWFoZWFkXHJcbiAgICB2YXIgX3Jlc2V0VGFnSW5wdXQgPSBmdW5jdGlvbihpbnB1dCwgdXNpbmdUeXBlYWhlYWQpIHtcclxuICAgICAgICBpZih1c2luZ1R5cGVhaGVhZCkge1xyXG4gICAgICAgICAgICBpbnB1dC50eXBlYWhlYWQoJ3ZhbCcsICcnKTtcclxuICAgICAgICAgICAgaW5wdXQudHlwZWFoZWFkKCdjbG9zZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlucHV0LnZhbCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2FkZFRhZ1RvRGF0YUZpZWxkID0gZnVuY3Rpb24odGFnRGF0YUZpZWxkLCBzZXBhcmF0b3IsIHRhZykge1xyXG4gICAgICAgIC8vIENvbmNhdGVuYXRlIHRoZSBleGlzdGluZyB0YWcgZGF0YSBzdHJpbmcgd2l0aCB0aGUgbmV3IHRhZ1xyXG4gICAgICAgIC8vIGlmIHRoZSBmaWVsZCB2YWx1ZSB3YXNuJ3QgYW4gZW1wdHkgc3RyaW5nXHJcbiAgICAgICAgaWYoJC50cmltKHRhZ0RhdGFGaWVsZC52YWwoKSkgPT09ICcnKVxyXG4gICAgICAgICAgICB0YWdEYXRhRmllbGQudmFsKHRhZyk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0YWdEYXRhRmllbGQudmFsKHRhZ0RhdGFGaWVsZC52YWwoKSArIHNlcGFyYXRvciArIHRhZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfcmVtb3ZlVGFnRnJvbURhdGFGaWVsZCA9IGZ1bmN0aW9uKHRhZ0RhdGFGaWVsZCwgc2VwYXJhdG9yLCB0YWcpIHtcclxuICAgICAgICAvLyBTbGlnaHRseSB3ZWlyZCBjb2RlLCBidXQgYmFzaWNhbGx5IHdlIHRhY2sgYSBwaXBlIGNoYXIgb250byB0aGUgZW5kXHJcbiAgICAgICAgLy8gb2YgdGhlIGN1cnJlbnQgdGFnIGRhdGEgc3RyaW5nIChzbyB0aGF0IG91ciByZXBsYWNlIHdvcmtzIGV2ZW4gaWYgdGhlIHRhZyBpc1xyXG4gICAgICAgIC8vIHRoZSBsYXN0IGluIHRoZSBzdHJpbmcpLCByZW1vdmUgdGhlIHRhZyBhbmQgcmV0dXJuIHRoZSBuZXcgc3RyaW5nIG1pbnVzIFxyXG4gICAgICAgIC8vIHRoZSBmaW5hbCBjaGFyYWN0ZXIgKHdoaWNoIHdpbGwgYWx3YXlzIGJlIGEgcGlwZSBjaGFyYWN0ZXIpXHJcbiAgICAgICAgdGFnRGF0YUZpZWxkLnZhbCgodGFnRGF0YUZpZWxkLnZhbCgpICsgc2VwYXJhdG9yKS5yZXBsYWNlKHRhZyArIHNlcGFyYXRvciwgJycpLnNsaWNlKDAsIC0xKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfcmVtb3ZlTGFzdFRhZ0Zyb21EYXRhRmllbGQgPSBmdW5jdGlvbih0YWdEYXRhRmllbGQsIHNlcGFyYXRvcikge1xyXG4gICAgICAgIC8vIFNwbGl0IHRoZSBkYXRhIGludG8gYW4gYXJyYXksIHJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IGFuZCBqb2luIGl0XHJcbiAgICAgICAgLy8gYmFjayB0b2dldGhlciBhZ2FpbiB3aXRoIHBpcGUgY2hhcmFjdGVyc1xyXG4gICAgICAgIHRhZ0RhdGFGaWVsZC52YWwodGFnRGF0YUZpZWxkLnZhbCgpLnNwbGl0KHNlcGFyYXRvcikuc2xpY2UoMCwgLTEpLmpvaW4oc2VwYXJhdG9yKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFBsdWdpbi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgLy8gQm9vbGVhbiB0byBkZXRlcm1pbmUgd2hldGhlciB0eXBlYWhlYWQuanMgaW50ZWdyYXRpb24gaXMgZW5hYmxlZFxyXG4gICAgICAgICAgICB2YXIgdXNpbmdUeXBlYWhlYWQgPSB0aGlzLm9wdGlvbnMudHlwZWFoZWFkO1xyXG4gICAgICAgICAgICAvLyBCb29sZWFuIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzYW1lIHRhZyBjYW4gYmUgYWRkZWQgdG8gdGhlIGlucHV0IG1vcmUgdGhhbiBvbmNlXHJcbiAgICAgICAgICAgIHZhciBhbGxvd0R1cGxpY2F0ZXMgPSB0aGlzLm9wdGlvbnMuYWxsb3dEdXBsaWNhdGVzO1xyXG4gICAgICAgICAgICAvLyBDaGFyYWN0ZXIgdG8gdXNlIGFzIGEgc2VwYXJhdG9yIGZvciB0aGUgdGFnIGRhdGEgKGRlZmF1bHQgaXMgcGlwZSAnfCcpXHJcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSB0aGlzLm9wdGlvbnMudGFnRGF0YVNlcGFyYXRvcjtcclxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZmlyZWQgb24gdGFnIGFkZC9yZW1vdmVcclxuICAgICAgICAgICAgdmFyIG9uVGFnRGF0YUNoYW5nZWQgPSB0aGlzLm9wdGlvbnMub25UYWdEYXRhQ2hhbmdlZDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIG9yaWdpbmFsIGlucHV0IHdpdGggdGhlIHRhZyBpbnB1dCBIVE1MXHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbElucHV0ID0gJChlbGVtZW50KTtcclxuICAgICAgICAgICAgdmFyIHRhZ0lucHV0Q29udGFpbmVyID0gX2NyZWF0ZVRhZ0lucHV0KG9yaWdpbmFsSW5wdXQsIHNlcGFyYXRvcik7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsSW5wdXQucmVwbGFjZVdpdGgodGFnSW5wdXRDb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHRleHQgaW5wdXQgZWxlbWVudCB3aXRoaW4gdGhlIHRhZyBjb250cm9sXHJcbiAgICAgICAgICAgIHZhciB0YWdJbnB1dCA9IHRhZ0lucHV0Q29udGFpbmVyLmZpbmQoJy5tYWItanF1ZXJ5LXRhZ2lucHV0LWlucHV0Jyk7XHJcbiAgICAgICAgICAgIC8vIFRoZSBoaWRkZW4gaW5wdXQgd2hpY2ggaXMgdXNlZCB0byBzdG9yZSBzZWxlY3RlZCB0YWcgZGF0YVxyXG4gICAgICAgICAgICB2YXIgdGFnRGF0YSA9IHRhZ0lucHV0Q29udGFpbmVyLmZpbmQoJy5tYWItanF1ZXJ5LXRhZ2lucHV0LWRhdGEnKTtcclxuICAgICAgICAgICAgLy8gS2VlcCBob2xkIG9mIHRoZSBvcmlnaW5hbCBwbGFjZWhvbGRlciB0ZXh0XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFBsYWNlSG9sZGVyID0gdGFnSW5wdXQuYXR0cigncGxhY2Vob2xkZXInKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgdHlwZWFoZWFkIGlmIHNwZWNpZmllZFxyXG4gICAgICAgICAgICBpZih1c2luZ1R5cGVhaGVhZClcclxuICAgICAgICAgICAgICAgIHRhZ0lucHV0LnR5cGVhaGVhZCh0aGlzLm9wdGlvbnMudHlwZWFoZWFkT3B0aW9ucywgdGhpcy5vcHRpb25zLnR5cGVhaGVhZERhdGFzZXRPcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBrZXlwcmVzcyBpbiB0aGUgdGFnIHRleHQgaW5wdXRcclxuICAgICAgICAgICAgdGFnSW5wdXQub24oJ2tleXByZXNzJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgc29tZW9uZSB0cmllcyB0byB0eXBlIHRoZSBjaGFyYWN0ZXIgd2UncmUgdXNpbmcgYXMgYSBkYXRhIHNlcGFyYXRvciwgXHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBsZXQgdGhlbSEgVGhpcyBhdm9pZHMgdGFncyBiZWluZyB1bmV4cGVjdGVkbHkgc3BsaXQgd2hlbiB0aGV5IGFyZSBzYXZlZC5cclxuICAgICAgICAgICAgICAgIGlmKGUua2V5Q29kZSA9PSBzZXBhcmF0b3IuY2hhckNvZGVBdCgwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIGtleWRvd24gZXZlbnRzIG9uIHRoZSB0YWcgdGV4dCBpbnB1dFxyXG4gICAgICAgICAgICB0YWdJbnB1dC5vbigna2V5ZG93biB0eXBlYWhlYWQ6c2VsZWN0ZWQnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBpbnB1dFxyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIGVudGVyIGlzIGhpdCwgYW5kIHRoZSBpbnB1dCBpcyAqbm90KiBlbXB0eSAoaWYgdGhlIGlucHV0ICppcyogZW1wdHksIFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiwgd2hpY2ggaXMgc3VibWl0dGluZyB0aGUgZm9ybSlcclxuICAgICAgICAgICAgICAgIGlmKGUudHlwZSA9PT0gJ3R5cGVhaGVhZDpzZWxlY3RlZCcgfHwgKGUua2V5Q29kZSA9PSBLRVlDT0RFUy5FTlRFUiAmJiAkLnRyaW0oaW5wdXQudmFsKCkpICE9PSAnJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIHRoZSBmb3JtIGJlaW5nIHN1Ym1pdHRlZCBhbmQgcHJldmVudCBldmVudCBidWJibGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdUYWcgPSAkLnRyaW0oaW5wdXQudmFsKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIHRhZyBpbiB0aGUgdGFnIGRhdGEgKC0xIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ0luZGV4ID0gJC5pbkFycmF5KG5ld1RhZywgdGFnRGF0YS52YWwoKS5zcGxpdChzZXBhcmF0b3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhbGxvdyB0aGUgYWRkaXRpb24gb2YgZHVwbGljYXRlIHRhZ3MgdW5sZXNzIGV4cGxpY2l0bHkgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYWxsb3dEdXBsaWNhdGVzIHx8ICh0YWdJbmRleCA9PT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBhIG5ldyB0YWcgc3BhbiBiZWZvcmUgdGhlIGhpZGRlbiBpbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdEYXRhLmJlZm9yZShfY3JlYXRlVGFnKG5ld1RhZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYWRkVGFnVG9EYXRhRmllbGQodGFnRGF0YSwgc2VwYXJhdG9yLCBuZXdUYWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGFnIGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNldFRhZ0lucHV0KGlucHV0LCB1c2luZ1R5cGVhaGVhZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmF0dHIoJ3BsYWNlaG9sZGVyJywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblRhZ0RhdGFDaGFuZ2VkLmNhbGwodGFnRGF0YSwgbmV3VGFnLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIaWdobGlnaHQgdGhlIGR1cGxpY2F0ZSB0YWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdGFnSW5wdXRDb250YWluZXIuZmluZCgnc3Bhbi5sYWJlbFtkYXRhLXRhZz1cIicgKyBuZXdUYWcgKyAnXCJdJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnJlbW92ZUNsYXNzKCdsYWJlbC1wcmltYXJ5JykuYWRkQ2xhc3MoJ2xhYmVsLWRhbmdlcicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGFnIGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNldFRhZ0lucHV0KGlucHV0LCB1c2luZ1R5cGVhaGVhZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5yZW1vdmVDbGFzcygnbGFiZWwtZGFuZ2VyJykuYWRkQ2xhc3MoJ2xhYmVsLXByaW1hcnknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTUwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgYmFja3NwYWNlIGlzIGhpdCBhbmQgdGhlcmUncyBub3RoaW5nIGluIHRoZSBpbnB1dCAoaWYgdGhlIGlucHV0ICppc24ndCogZW1wdHksIFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiwgd2hpY2ggaXMgZGVsZXRpbmcgYSBjaGFyYWN0ZXIpXHJcbiAgICAgICAgICAgICAgICBpZihlLmtleUNvZGUgPT0gS0VZQ09ERVMuQkFDS1NQQUNFICYmICQudHJpbShpbnB1dC52YWwoKSkgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IHRhZyBzcGFuIGJlZm9yZSB0aGUgaGlkZGVuIGRhdGEgaW5wdXRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnUmVtb3ZlZCA9ICQudHJpbSh0YWdEYXRhLnByZXYoJ3NwYW4ubGFiZWwnKS50ZXh0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ0RhdGEucHJldignc3Bhbi5sYWJlbCcpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZW1vdmVMYXN0VGFnRnJvbURhdGFGaWVsZCh0YWdEYXRhLCBzZXBhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB0YWcgaW5wdXRcclxuICAgICAgICAgICAgICAgICAgICBfcmVzZXRUYWdJbnB1dChpbnB1dCwgdXNpbmdUeXBlYWhlYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRhZ0RhdGEudmFsKCkgPT09ICcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5hdHRyKCdwbGFjZWhvbGRlcicsIG9yaWdpbmFsUGxhY2VIb2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9uVGFnRGF0YUNoYW5nZWQuY2FsbCh0YWdEYXRhLCBudWxsLCB0YWdSZW1vdmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgZm9jdXMgYW5kIGJsdXIgb24gdGhlIHRleHQgaW5wdXRcclxuICAgICAgICAgICAgdGFnSW5wdXRDb250YWluZXIub24oJ2ZvY3VzJywgJ2lucHV0W3R5cGU9dGV4dF0nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG5hcnJvd2luZyBjbGFzcywgcmVzdG9yaW5nIGlucHV0IHRvIGl0cyBvcmlnaW5hbCB3aWR0aFxyXG4gICAgICAgICAgICAgICAgdGFnSW5wdXRDb250YWluZXIuZmluZCgnaW5wdXRbdHlwZT10ZXh0XScpLnJlbW92ZUNsYXNzKCdoJyk7XHJcbiAgICAgICAgICAgIH0pLm9uKCdibHVyJywgJ2lucHV0W3R5cGU9dGV4dF0nLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSB0YWcgdGV4dCBpbnB1dCBsb3NlcyBmb2N1cywgYWRkIGEgY2xhc3Mgd2hpY2ggbmFycm93cyBpdFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gMXB4IHdpZGUgKHRoaXMgaXMgdG8gYXZvaWQgb2RkIHZpc3VhbCBlZmZlY3RzIHdoZW4gdGhlIHRhZ3MgaW4gXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29udHJvbCB3cmFwcyBvbnRvIG11bHRpcGxlIGxpbmVzKVxyXG4gICAgICAgICAgICAgICAgaWYodGFnRGF0YS52YWwoKSAhPT0gJycpXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnSW5wdXRDb250YWluZXIuZmluZCgnaW5wdXRbdHlwZT10ZXh0XScpLmFkZENsYXNzKCdoJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGFnIGlucHV0XHJcbiAgICAgICAgICAgICAgICBfcmVzZXRUYWdJbnB1dCh0YWdJbnB1dCwgdXNpbmdUeXBlYWhlYWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZvY3VzIHRoZSB0ZXh0IGlucHV0IHdoZW4gdGhlIGNvbnRyb2wgY29udGFpbmVyIGlzIGNsaWNrZWQsIHdoaWNoIHRyaWdnZXJzXHJcbiAgICAgICAgICAgIC8vIHRoZSBzaG93L2hpZGUgYmVoYXZpb3VycyBkZWZpbmVkIGluIHRoZSBoYW5kbGVycyBhYm92ZVxyXG4gICAgICAgICAgICB0YWdJbnB1dENvbnRhaW5lci5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICBpZih1c2luZ1R5cGVhaGVhZClcclxuICAgICAgICAgICAgICAgICAgICB0YWdJbnB1dENvbnRhaW5lci5maW5kKCdpbnB1dFt0eXBlPXRleHRdLnR0LWlucHV0JykuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0YWdJbnB1dENvbnRhaW5lci5maW5kKCdpbnB1dFt0eXBlPXRleHRdJykuZm9jdXMoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgdGFnIGRlbGV0ZSBpY29uIGNsaWNrXHJcbiAgICAgICAgICAgIHRhZ0lucHV0Q29udGFpbmVyLm9uKCdjbGljaycsICdzcGFuLmdseXBoaWNvbicsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSB0aGUgY2xpY2sgZXZlbnQgdXAgdG8gdGhlIGlucHV0IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSB0aGUgdGV4dCBpbnB1dCB0byBiZSBzaG93biBieSB0aGUgY29udGFpbmVyJ3MgY2xpY2sgZXZlbnRcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRleHQgb2YgdGhlIHRhZyB0byBiZSByZW1vdmVkIChwYXJlbnQgb2YgdGhpcyBpcyB0aGUgbGFiZWwgc3BhbilcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSAkKHRoaXMpLnBhcmVudCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZ1RleHQgPSAkLnRyaW0odGFnLnRleHQoKSk7XHJcbiAgICAgICAgICAgICAgICBfcmVtb3ZlVGFnRnJvbURhdGFGaWVsZCh0YWdEYXRhLCBzZXBhcmF0b3IsIHRhZ1RleHQpO1xyXG4gICAgICAgICAgICAgICAgdGFnLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgb25UYWdEYXRhQ2hhbmdlZC5jYWxsKHRhZ0RhdGEsIG51bGwsIHRhZ1RleHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb250cm9sIGFscmVhZHkgaGFzIHNvbWUgdGFncyBpbiBpdFxyXG4gICAgICAgICAgICBpZih0YWdEYXRhLnZhbCgpICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBwbGFjZWhvbGRlciB0ZXh0XHJcbiAgICAgICAgICAgICAgICB0YWdJbnB1dC5hdHRyKCdwbGFjZWhvbGRlcicsICcnKTtcclxuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxseSBibHVyIHRoZSB0ZXh0IGlucHV0IHNvIGl0J3MgaGlkZGVuIG9uIGxvYWRcclxuICAgICAgICAgICAgICAgIHRhZ0lucHV0Q29udGFpbmVyLmZpbmQoJ2lucHV0W3R5cGU9dGV4dF0nKS5ibHVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0YWdJbnB1dENvbnRhaW5lcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEEgcmVhbGx5IGxpZ2h0d2VpZ2h0IHBsdWdpbiB3cmFwcGVyIGFyb3VuZCB0aGUgY29uc3RydWN0b3IsXHJcbiAgICAvLyBwcmV2ZW50aW5nIGFnYWluc3QgbXVsdGlwbGUgaW5zdGFudGlhdGlvbnNcclxuICAgICQuZm5bcGx1Z2luTmFtZV0gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9ICQodGhpcyk7XHJcbiAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YShcInBsdWdpbl9cIiArIHBsdWdpbk5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgUGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5wdXQuZGF0YShcInBsdWdpbl9cIiArIHBsdWdpbk5hbWUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbn0pKGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/admin/auto-complete-tag/mab-jquery-taginput.js\n");

/***/ }),

/***/ "./resources/js/admin/form-browse.js":
/*!*******************************************!*\
  !*** ./resources/js/admin/form-browse.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*window.Cropper = require('cropperjs');\r\nwindow.Cropper = 'default' in window.Cropper ? window.Cropper['default'] : window.Cropper;*/\n// window.SimpleMDE = require('simplemde');\n\n/*window.DataTable = require('datatables');\r\nrequire('datatables-bootstrap3-plugin/media/js/datatables-bootstrap3');*/\n__webpack_require__(/*! dropzone */ \"./node_modules/dropzone/dist/dropzone.js\");\n\n__webpack_require__(/*! nestable2 */ \"./node_modules/nestable2/jquery.nestable.js\");\n\n__webpack_require__(/*! ./slugify */ \"./resources/js/admin/slugify.js\");\n\n__webpack_require__(/*! ./auto-complete-tag/mab-jquery-taginput.css */ \"./resources/js/admin/auto-complete-tag/mab-jquery-taginput.css\");\n\n__webpack_require__(/*! ./auto-complete-tag/mab-jquery-taginput.js */ \"./resources/js/admin/auto-complete-tag/mab-jquery-taginput.js\");\n\n$(document).ready(function () {\n  /********** MARKDOWN EDITOR **********/\n\n  /*    $('textarea.simplemde').each(function () {\r\n          var simplemde = new SimpleMDE({\r\n              element: this,\r\n          });\r\n          simplemde.render();\r\n      });*/\n\n  /********** END MARKDOWN EDITOR **********/\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYWRtaW4vZm9ybS1icm93c2UuanM/YzYwYiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiJCIsImRvY3VtZW50IiwicmVhZHkiXSwibWFwcGluZ3MiOiJBQUFBOztBQUdBOztBQUNBOztBQUdBQSxtQkFBTyxDQUFDLDBEQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsOERBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyxrREFBRCxDQUFQOztBQUVBQSxtQkFBTyxDQUFDLG1IQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsaUhBQUQsQ0FBUDs7QUFHQUMsQ0FBQyxDQUFDQyxRQUFELENBQUQsQ0FBWUMsS0FBWixDQUFrQixZQUFZO0FBSTFCOztBQUVBOzs7Ozs7O0FBT0E7QUFDSCxDQWREIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2FkbWluL2Zvcm0tYnJvd3NlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyp3aW5kb3cuQ3JvcHBlciA9IHJlcXVpcmUoJ2Nyb3BwZXJqcycpO1xyXG53aW5kb3cuQ3JvcHBlciA9ICdkZWZhdWx0JyBpbiB3aW5kb3cuQ3JvcHBlciA/IHdpbmRvdy5Dcm9wcGVyWydkZWZhdWx0J10gOiB3aW5kb3cuQ3JvcHBlcjsqL1xyXG5cclxuLy8gd2luZG93LlNpbXBsZU1ERSA9IHJlcXVpcmUoJ3NpbXBsZW1kZScpO1xyXG4vKndpbmRvdy5EYXRhVGFibGUgPSByZXF1aXJlKCdkYXRhdGFibGVzJyk7XHJcbnJlcXVpcmUoJ2RhdGF0YWJsZXMtYm9vdHN0cmFwMy1wbHVnaW4vbWVkaWEvanMvZGF0YXRhYmxlcy1ib290c3RyYXAzJyk7Ki9cclxuXHJcbnJlcXVpcmUoJ2Ryb3B6b25lJyk7XHJcbnJlcXVpcmUoJ25lc3RhYmxlMicpO1xyXG5yZXF1aXJlKCcuL3NsdWdpZnknKTtcclxuXHJcbnJlcXVpcmUoJy4vYXV0by1jb21wbGV0ZS10YWcvbWFiLWpxdWVyeS10YWdpbnB1dC5jc3MnKTtcclxucmVxdWlyZSgnLi9hdXRvLWNvbXBsZXRlLXRhZy9tYWItanF1ZXJ5LXRhZ2lucHV0LmpzJyk7XHJcblxyXG5cclxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xyXG5cclxuXHJcblxyXG4gICAgLyoqKioqKioqKiogTUFSS0RPV04gRURJVE9SICoqKioqKioqKiovXHJcblxyXG4gICAgLyogICAgJCgndGV4dGFyZWEuc2ltcGxlbWRlJykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzaW1wbGVtZGUgPSBuZXcgU2ltcGxlTURFKHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzaW1wbGVtZGUucmVuZGVyKCk7XHJcbiAgICAgICAgfSk7Ki9cclxuXHJcbiAgICAvKioqKioqKioqKiBFTkQgTUFSS0RPV04gRURJVE9SICoqKioqKioqKiovXHJcbn0pO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/admin/form-browse.js\n");

/***/ }),

/***/ "./resources/js/admin/slugify.js":
/*!***************************************!*\
  !*** ./resources/js/admin/slugify.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n * Slugify for Voyager v0.9.0\r\n *\r\n * Generates a slug for a given input element.\r\n * This script was created for Voyager, but works with any HTML structure.\r\n *\r\n * Default behavior is to auto generate a new slug, only if the input is empty.\r\n * If input isn't empty, the auto generation is disabled.\r\n * To force the auto generator, set the option \"forceUpdate: true\".\r\n *\r\n * Copyright 2017 Bruno Torrinha\r\n * License MIT\r\n *\r\n * Some credits:\r\n * Char map from: https://github.com/diegok/slugit-jquery\r\n */\n;\n\n(function ($, window, document, undefined) {\n  \"use strict\";\n\n  var pluginName = \"slugify\",\n      defaults = {\n    separator: '-',\n    input: false,\n    // The origin from where we generate the slug.\n    forceUpdate: false,\n    // Force update if input is not empty.\n    map: false // Provide an extra character map translator.\n\n  };\n\n  function Plugin(element, options) {\n    this.element = $(element); // The input where slug is placed.\n\n    this.settings = $.extend({}, defaults, options);\n    this._defaults = defaults;\n    this.chars = this._load_char_maps();\n\n    if (!this.settings.map) {\n      // Load extra character map translator\n      $.extend(this.chars, this.settings.map);\n    }\n\n    this.init();\n  } // Avoid Plugin.prototype conflicts\n\n\n  $.extend(Plugin.prototype, {\n    init: function init() {\n      this.input = this.settings.input || $(this.element).closest('form').find('input[name=\"' + this.element.attr(\"data-slug-origin\") + '\"]');\n      this.forceUpdate = this.element.data('slug-forceupdate') ? true : false;\n      this.input.on('keyup change', $.proxy(this.onChange, this));\n      this.refresh();\n    },\n    refresh: function refresh() {\n      this.element.update = this.element.val() === '';\n    },\n\n    /**\r\n     * When input changes\r\n     */\n    onChange: function onChange(ev) {\n      var code = ev.keyCode ? ev.keyCode : ev.which;\n\n      if (code > 34 && code < 41) {\n        return;\n      }\n\n      var strOrigin = $(ev.target).val(),\n          strTarget = this.element.val();\n\n      if (this.element.update || strTarget === '' || strTarget != '' && this.forceUpdate) {\n        this.element.val(this.slug(strOrigin));\n        this.element.update = true;\n      }\n\n      return;\n    },\n\n    /**\r\n     * Generate a slug\r\n     */\n    slug: function slug(str) {\n      str = str.toString().toLowerCase();\n      var _slug = '',\n          _sep = this.settings.separator; // Replace Char Map\n      //\n\n      for (var i = 0, l = str.length; i < l; i++) {\n        _slug += this.chars[str.charAt(i)] ? this.chars[str.charAt(i)] : str.charAt(i);\n      }\n\n      str = _slug.replace(/[^a-z0-9]/g, _sep).replace(new RegExp('\\\\' + _sep + '\\\\' + _sep + '+', 'g'), _sep).replace(new RegExp('^\\\\' + _sep + '+|\\\\' + _sep + '+$', 'g'), '');\n      return str;\n    },\n    _load_char_maps: function _load_char_maps() {\n      return $.extend(this._map_latin(), this._map_arabic(), this._map_greek(), this._map_turkish(), this._map_russian(), this._map_ukranian(), this._map_czech(), this._map_polish(), this._map_vietnam(), this._map_latvian(), this._map_lithuanian(), this._map_currency(), this._map_symbols());\n    },\n    _map_latin: function _map_latin() {\n      return {\n        'Ã€': 'A',\n        'Ã': 'A',\n        'Ã‚': 'A',\n        'Ãƒ': 'A',\n        'Ã„': 'A',\n        'Ã…': 'A',\n        'Ã†': 'AE',\n        'Ã‡': 'C',\n        'Ãˆ': 'E',\n        'Ã‰': 'E',\n        'ÃŠ': 'E',\n        'Ã‹': 'E',\n        'ÃŒ': 'I',\n        'Ã': 'I',\n        'ÃŽ': 'I',\n        'Ã': 'I',\n        'Ã': 'D',\n        'Ã‘': 'N',\n        'Ã’': 'O',\n        'Ã“': 'O',\n        'Ã”': 'O',\n        'Ã•': 'O',\n        'Ã–': 'O',\n        'Å': 'O',\n        'Ã˜': 'O',\n        'Ã™': 'U',\n        'Ãš': 'U',\n        'Ã›': 'U',\n        'Ãœ': 'U',\n        'Å°': 'U',\n        'Ã': 'Y',\n        'Ãž': 'TH',\n        'ÃŸ': 'ss',\n        'Ã ': 'a',\n        'Ã¡': 'a',\n        'Ã¢': 'a',\n        'Ã£': 'a',\n        'Ã¤': 'a',\n        'Ã¥': 'a',\n        'Ã¦': 'ae',\n        'Ã§': 'c',\n        'Ã¨': 'e',\n        'Ã©': 'e',\n        'Ãª': 'e',\n        'Ã«': 'e',\n        'Ã¬': 'i',\n        'Ã­': 'i',\n        'Ã®': 'i',\n        'Ã¯': 'i',\n        'Ã°': 'd',\n        'Ã±': 'n',\n        'Ã²': 'o',\n        'Ã³': 'o',\n        'Ã´': 'o',\n        'Ãµ': 'o',\n        'Ã¶': 'o',\n        'Å‘': 'o',\n        'Ã¸': 'o',\n        'Ã¹': 'u',\n        'Ãº': 'u',\n        'Ã»': 'u',\n        'Ã¼': 'u',\n        'Å±': 'u',\n        'Ã½': 'y',\n        'Ã¾': 'th',\n        'Ã¿': 'y'\n      };\n    },\n    _map_arabic: function _map_arabic() {\n      return {\n        'Ø§': 'a',\n        'Ø£': 'a',\n        'Ø¥': 'i',\n        'Ø¢': 'aa',\n        'Ø¤': 'u',\n        'Ø¦': 'e',\n        'Ø¡': 'a',\n        'Ø¨': 'b',\n        'Øª': 't',\n        'Ø«': 'th',\n        'Ø¬': 'j',\n        'Ø­': 'h',\n        'Ø®': 'kh',\n        'Ø¯': 'd',\n        'Ø°': 'th',\n        'Ø±': 'r',\n        'Ø²': 'z',\n        'Ø³': 's',\n        'Ø´': 'sh',\n        'Øµ': 's',\n        'Ø¶': 'dh',\n        'Ø·': 't',\n        'Ø¸': 'z',\n        'Ø¹': 'a',\n        'Øº': 'gh',\n        'Ù': 'f',\n        'Ù‚': 'q',\n        'Ùƒ': 'k',\n        'Ù„': 'l',\n        'Ù…': 'm',\n        'Ù†': 'n',\n        'Ù‡': 'h',\n        'Ùˆ': 'w',\n        'ÙŠ': 'y',\n        'Ù‰': 'a',\n        'Ø©': 'h',\n        'ï»»': 'la',\n        'ï»·': 'laa',\n        'ï»¹': 'lai',\n        'ï»µ': 'laa'\n      };\n    },\n    _map_greek: function _map_greek() {\n      return {\n        'Î±': 'a',\n        'Î²': 'b',\n        'Î³': 'g',\n        'Î´': 'd',\n        'Îµ': 'e',\n        'Î¶': 'z',\n        'Î·': 'h',\n        'Î¸': '8',\n        'Î¹': 'i',\n        'Îº': 'k',\n        'Î»': 'l',\n        'Î¼': 'm',\n        'Î½': 'n',\n        'Î¾': '3',\n        'Î¿': 'o',\n        'Ï€': 'p',\n        'Ï': 'r',\n        'Ïƒ': 's',\n        'Ï„': 't',\n        'Ï…': 'y',\n        'Ï†': 'f',\n        'Ï‡': 'x',\n        'Ïˆ': 'ps',\n        'Ï‰': 'w',\n        'Î¬': 'a',\n        'Î­': 'e',\n        'Î¯': 'i',\n        'ÏŒ': 'o',\n        'Ï': 'y',\n        'Î®': 'h',\n        'ÏŽ': 'w',\n        'Ï‚': 's',\n        'ÏŠ': 'i',\n        'Î°': 'y',\n        'Ï‹': 'y',\n        'Î': 'i',\n        'Î‘': 'A',\n        'Î’': 'B',\n        'Î“': 'G',\n        'Î”': 'D',\n        'Î•': 'E',\n        'Î–': 'Z',\n        'Î—': 'H',\n        'Î˜': '8',\n        'Î™': 'I',\n        'Îš': 'K',\n        'Î›': 'L',\n        'Îœ': 'M',\n        'Î': 'N',\n        'Îž': '3',\n        'ÎŸ': 'O',\n        'Î ': 'P',\n        'Î¡': 'R',\n        'Î£': 'S',\n        'Î¤': 'T',\n        'Î¥': 'Y',\n        'Î¦': 'F',\n        'Î§': 'X',\n        'Î¨': 'PS',\n        'Î©': 'W',\n        'Î†': 'A',\n        'Îˆ': 'E',\n        'ÎŠ': 'I',\n        'ÎŒ': 'O',\n        'ÎŽ': 'Y',\n        'Î‰': 'H',\n        'Î': 'W',\n        'Îª': 'I',\n        'Î«': 'Y'\n      };\n    },\n    _map_turkish: function _map_turkish() {\n      return {\n        'ÅŸ': 's',\n        'Åž': 'S',\n        'Ä±': 'i',\n        'Ä°': 'I',\n        'Ã§': 'c',\n        'Ã‡': 'C',\n        'Ã¼': 'u',\n        'Ãœ': 'U',\n        'Ã¶': 'o',\n        'Ã–': 'O',\n        'ÄŸ': 'g',\n        'Äž': 'G'\n      };\n    },\n    _map_russian: function _map_russian() {\n      return {\n        'Ð°': 'a',\n        'Ð±': 'b',\n        'Ð²': 'v',\n        'Ð³': 'g',\n        'Ð´': 'd',\n        'Ðµ': 'e',\n        'Ñ‘': 'yo',\n        'Ð¶': 'zh',\n        'Ð·': 'z',\n        'Ð¸': 'i',\n        'Ð¹': 'j',\n        'Ðº': 'k',\n        'Ð»': 'l',\n        'Ð¼': 'm',\n        'Ð½': 'n',\n        'Ð¾': 'o',\n        'Ð¿': 'p',\n        'Ñ€': 'r',\n        'Ñ': 's',\n        'Ñ‚': 't',\n        'Ñƒ': 'u',\n        'Ñ„': 'f',\n        'Ñ…': 'h',\n        'Ñ†': 'c',\n        'Ñ‡': 'ch',\n        'Ñˆ': 'sh',\n        'Ñ‰': 'sh',\n        'ÑŠ': '',\n        'Ñ‹': 'y',\n        'ÑŒ': '',\n        'Ñ': 'e',\n        'ÑŽ': 'yu',\n        'Ñ': 'ya',\n        'Ð': 'A',\n        'Ð‘': 'B',\n        'Ð’': 'V',\n        'Ð“': 'G',\n        'Ð”': 'D',\n        'Ð•': 'E',\n        'Ð': 'Yo',\n        'Ð–': 'Zh',\n        'Ð—': 'Z',\n        'Ð˜': 'I',\n        'Ð™': 'J',\n        'Ðš': 'K',\n        'Ð›': 'L',\n        'Ðœ': 'M',\n        'Ð': 'N',\n        'Ðž': 'O',\n        'ÐŸ': 'P',\n        'Ð ': 'R',\n        'Ð¡': 'S',\n        'Ð¢': 'T',\n        'Ð£': 'U',\n        'Ð¤': 'F',\n        'Ð¥': 'H',\n        'Ð¦': 'C',\n        'Ð§': 'Ch',\n        'Ð¨': 'Sh',\n        'Ð©': 'Sh',\n        'Ðª': '',\n        'Ð«': 'Y',\n        'Ð¬': '',\n        'Ð­': 'E',\n        'Ð®': 'Yu',\n        'Ð¯': 'Ya'\n      };\n    },\n    _map_ukranian: function _map_ukranian() {\n      return {\n        'Ð„': 'Ye',\n        'Ð†': 'I',\n        'Ð‡': 'Yi',\n        'Ò': 'G',\n        'Ñ”': 'ye',\n        'Ñ–': 'i',\n        'Ñ—': 'yi',\n        'Ò‘': 'g'\n      };\n    },\n    _map_czech: function _map_czech() {\n      return {\n        'Ä': 'c',\n        'Ä': 'd',\n        'Ä›': 'e',\n        'Åˆ': 'n',\n        'Å™': 'r',\n        'Å¡': 's',\n        'Å¥': 't',\n        'Å¯': 'u',\n        'Å¾': 'z',\n        'ÄŒ': 'C',\n        'ÄŽ': 'D',\n        'Äš': 'E',\n        'Å‡': 'N',\n        'Å˜': 'R',\n        'Å ': 'S',\n        'Å¤': 'T',\n        'Å®': 'U',\n        'Å½': 'Z'\n      };\n    },\n    _map_polish: function _map_polish() {\n      return {\n        'Ä…': 'a',\n        'Ä‡': 'c',\n        'Ä™': 'e',\n        'Å‚': 'l',\n        'Å„': 'n',\n        'Ã³': 'o',\n        'Å›': 's',\n        'Åº': 'z',\n        'Å¼': 'z',\n        'Ä„': 'A',\n        'Ä†': 'C',\n        'Ä˜': 'e',\n        'Å': 'L',\n        'Åƒ': 'N',\n        'Ã“': 'o',\n        'Åš': 'S',\n        'Å¹': 'Z',\n        'Å»': 'Z'\n      };\n    },\n    _map_vietnam: function _map_vietnam() {\n      return {\n        'áº¡': 'a',\n        'áº£': 'a',\n        'áº§': 'a',\n        'áº¥': 'a',\n        'áº­': 'a',\n        'áº©': 'a',\n        'áº«': 'a',\n        'áº±': 'a',\n        'áº¯': 'a',\n        'áº·': 'a',\n        'áº³': 'a',\n        'áºµ': 'a',\n        'áº¹': 'e',\n        'áº»': 'e',\n        'áº½': 'e',\n        'á»': 'e',\n        'áº¿': 'e',\n        'á»‡': 'e',\n        'á»ƒ': 'e',\n        'á»…': 'e',\n        'á»‹': 'i',\n        'á»‰': 'i',\n        'á»': 'o',\n        'á»': 'o',\n        'á»“': 'o',\n        'á»‘': 'o',\n        'á»™': 'o',\n        'á»•': 'o',\n        'á»—': 'o',\n        'á»': 'o',\n        'á»›': 'o',\n        'á»£': 'o',\n        'á»Ÿ': 'o',\n        'á»¡': 'o',\n        'á»¥': 'u',\n        'á»§': 'u',\n        'á»«': 'u',\n        'á»©': 'u',\n        'á»±': 'u',\n        'á»­': 'u',\n        'á»¯': 'u',\n        'á»³': 'y',\n        'á»µ': 'y',\n        'á»·': 'y',\n        'á»¹': 'y',\n        'áº ': 'A',\n        'áº¢': 'A',\n        'áº¦': 'A',\n        'áº¤': 'A',\n        'áº¬': 'A',\n        'áº¨': 'A',\n        'áºª': 'A',\n        'áº°': 'A',\n        'áº®': 'A',\n        'áº¶': 'A',\n        'áº²': 'A',\n        'áº´': 'A',\n        'áº¸': 'E',\n        'áºº': 'E',\n        'áº¼': 'E',\n        'á»€': 'E',\n        'áº¾': 'E',\n        'á»†': 'E',\n        'á»‚': 'E',\n        'á»„': 'E',\n        'á»Š': 'I',\n        'á»ˆ': 'I',\n        'á»Œ': 'O',\n        'á»Ž': 'O',\n        'á»’': 'O',\n        'á»': 'O',\n        'á»˜': 'O',\n        'á»”': 'O',\n        'á»–': 'O',\n        'á»œ': 'O',\n        'á»š': 'O',\n        'á»¢': 'O',\n        'á»ž': 'O',\n        'á» ': 'O',\n        'á»¤': 'U',\n        'á»¦': 'U',\n        'á»ª': 'U',\n        'á»¨': 'U',\n        'á»°': 'U',\n        'á»¬': 'U',\n        'á»®': 'U',\n        'á»²': 'Y',\n        'á»´': 'Y',\n        'Ä‘': 'd',\n        'Ä': 'D',\n        'á»¶': 'Y',\n        'á»¸': 'Y',\n        'Äƒ': 'a',\n        'Ä‚': 'a'\n      };\n    },\n    _map_latvian: function _map_latvian() {\n      return {\n        'Ä': 'a',\n        'Ä': 'c',\n        'Ä“': 'e',\n        'Ä£': 'g',\n        'Ä«': 'i',\n        'Ä·': 'k',\n        'Ä¼': 'l',\n        'Å†': 'n',\n        'Å¡': 's',\n        'Å«': 'u',\n        'Å¾': 'z',\n        'Ä€': 'A',\n        'ÄŒ': 'C',\n        'Ä’': 'E',\n        'Ä¢': 'G',\n        'Äª': 'i',\n        'Ä¶': 'k',\n        'Ä»': 'L',\n        'Å…': 'N',\n        'Å ': 'S',\n        'Åª': 'u',\n        'Å½': 'Z'\n      };\n    },\n    _map_lithuanian: function _map_lithuanian() {\n      return {\n        'Ä…': 'a',\n        'Ä': 'c',\n        'Ä™': 'e',\n        'Ä—': 'e',\n        'Ä¯': 'i',\n        'Å¡': 's',\n        'Å³': 'u',\n        'Å«': 'u',\n        'Å¾': 'z',\n        'Ä„': 'A',\n        'ÄŒ': 'C',\n        'Ä˜': 'E',\n        'Ä–': 'E',\n        'Ä®': 'I',\n        'Å ': 'S',\n        'Å²': 'U',\n        'Åª': 'U',\n        'Å½': 'Z'\n      };\n    },\n    _map_currency: function _map_currency() {\n      return {\n        'â‚¬': 'euro',\n        '$': 'dollar',\n        'â‚¢': 'cruzeiro',\n        'â‚£': 'french franc',\n        'Â£': 'pound',\n        'â‚¤': 'lira',\n        'â‚¥': 'mill',\n        'â‚¦': 'naira',\n        'â‚§': 'peseta',\n        'â‚¨': 'rupee',\n        'â‚©': 'won',\n        'â‚ª': 'new shequel',\n        'â‚«': 'dong',\n        'â‚­': 'kip',\n        'â‚®': 'tugrik',\n        'â‚¯': 'drachma',\n        'â‚°': 'penny',\n        'â‚±': 'peso',\n        'â‚²': 'guarani',\n        'â‚³': 'austral',\n        'â‚´': 'hryvnia',\n        'â‚µ': 'cedi',\n        'Â¢': 'cent',\n        'Â¥': 'yen',\n        'å…ƒ': 'yuan',\n        'å††': 'yen',\n        'ï·¼': 'rial',\n        'â‚ ': 'ecu',\n        'Â¤': 'currency',\n        'à¸¿': 'baht'\n      };\n    },\n    _map_symbols: function _map_symbols() {\n      return {\n        'Â©': '(c)',\n        'Å“': 'oe',\n        'Å’': 'OE',\n        'âˆ‘': 'sum',\n        'Â®': '(r)',\n        'â€ ': '+',\n        'â€œ': '\"',\n        'â€': '\"',\n        'â€˜': \"'\",\n        'â€™': \"'\",\n        'âˆ‚': 'd',\n        'Æ’': 'f',\n        'â„¢': 'tm',\n        'â„ ': 'sm',\n        'â€¦': '...',\n        'Ëš': 'o',\n        'Âº': 'o',\n        'Âª': 'a',\n        'â€¢': '*',\n        'âˆ†': 'delta',\n        'âˆž': 'infinity',\n        'â™¥': 'love',\n        '&': 'and'\n      };\n    }\n  });\n\n  $.fn[pluginName] = function (options) {\n    return this.each(function () {\n      if (!$.data(this, pluginName)) {\n        $.data(this, pluginName, new Plugin(this, options));\n      }\n    });\n  };\n})(jQuery, window, document);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYWRtaW4vc2x1Z2lmeS5qcz9jZDA4Il0sIm5hbWVzIjpbIiQiLCJ3aW5kb3ciLCJkb2N1bWVudCIsInVuZGVmaW5lZCIsInBsdWdpbk5hbWUiLCJkZWZhdWx0cyIsInNlcGFyYXRvciIsImlucHV0IiwiZm9yY2VVcGRhdGUiLCJtYXAiLCJQbHVnaW4iLCJlbGVtZW50Iiwib3B0aW9ucyIsInNldHRpbmdzIiwiZXh0ZW5kIiwiX2RlZmF1bHRzIiwiY2hhcnMiLCJfbG9hZF9jaGFyX21hcHMiLCJpbml0IiwicHJvdG90eXBlIiwiY2xvc2VzdCIsImZpbmQiLCJhdHRyIiwiZGF0YSIsIm9uIiwicHJveHkiLCJvbkNoYW5nZSIsInJlZnJlc2giLCJ1cGRhdGUiLCJ2YWwiLCJldiIsImNvZGUiLCJrZXlDb2RlIiwid2hpY2giLCJzdHJPcmlnaW4iLCJ0YXJnZXQiLCJzdHJUYXJnZXQiLCJzbHVnIiwic3RyIiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsIl9zbHVnIiwiX3NlcCIsImkiLCJsIiwibGVuZ3RoIiwiY2hhckF0IiwicmVwbGFjZSIsIlJlZ0V4cCIsIl9tYXBfbGF0aW4iLCJfbWFwX2FyYWJpYyIsIl9tYXBfZ3JlZWsiLCJfbWFwX3R1cmtpc2giLCJfbWFwX3J1c3NpYW4iLCJfbWFwX3VrcmFuaWFuIiwiX21hcF9jemVjaCIsIl9tYXBfcG9saXNoIiwiX21hcF92aWV0bmFtIiwiX21hcF9sYXR2aWFuIiwiX21hcF9saXRodWFuaWFuIiwiX21hcF9jdXJyZW5jeSIsIl9tYXBfc3ltYm9scyIsImZuIiwiZWFjaCIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7O0FBQUMsQ0FBRSxVQUFVQSxDQUFWLEVBQWFDLE1BQWIsRUFBcUJDLFFBQXJCLEVBQStCQyxTQUEvQixFQUEyQztBQUUxQzs7QUFFSSxNQUFJQyxVQUFVLEdBQUcsU0FBakI7QUFBQSxNQUNJQyxRQUFRLEdB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QXNSb0JDLFFBdFJwQiIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9hZG1pbi9zbHVnaWZ5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogU2x1Z2lmeSBmb3IgVm95YWdlciB2MC45LjBcclxuICpcclxuICogR2VuZXJhdGVzIGEgc2x1ZyBmb3IgYSBnaXZlbiBpbnB1dCBlbGVtZW50LlxyXG4gKiBUaGlzIHNjcmlwdCB3YXMgY3JlYXRlZCBmb3IgVm95YWdlciwgYnV0IHdvcmtzIHdpdGggYW55IEhUTUwgc3RydWN0dXJlLlxyXG4gKlxyXG4gKiBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGF1dG8gZ2VuZXJhdGUgYSBuZXcgc2x1Zywgb25seSBpZiB0aGUgaW5wdXQgaXMgZW1wdHkuXHJcbiAqIElmIGlucHV0IGlzbid0IGVtcHR5LCB0aGUgYXV0byBnZW5lcmF0aW9uIGlzIGRpc2FibGVkLlxyXG4gKiBUbyBmb3JjZSB0aGUgYXV0byBnZW5lcmF0b3IsIHNldCB0aGUgb3B0aW9uIFwiZm9yY2VVcGRhdGU6IHRydWVcIi5cclxuICpcclxuICogQ29weXJpZ2h0IDIwMTcgQnJ1bm8gVG9ycmluaGFcclxuICogTGljZW5zZSBNSVRcclxuICpcclxuICogU29tZSBjcmVkaXRzOlxyXG4gKiBDaGFyIG1hcCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZGllZ29rL3NsdWdpdC1qcXVlcnlcclxuICovXHJcbjsoIGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XHJcblxyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIHZhciBwbHVnaW5OYW1lID0gXCJzbHVnaWZ5XCIsXHJcbiAgICAgICAgICAgIGRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yOiAgICctJyxcclxuICAgICAgICAgICAgICAgIGlucHV0OiAgICAgICBmYWxzZSwgLy8gVGhlIG9yaWdpbiBmcm9tIHdoZXJlIHdlIGdlbmVyYXRlIHRoZSBzbHVnLlxyXG4gICAgICAgICAgICAgICAgZm9yY2VVcGRhdGU6IGZhbHNlLCAvLyBGb3JjZSB1cGRhdGUgaWYgaW5wdXQgaXMgbm90IGVtcHR5LlxyXG4gICAgICAgICAgICAgICAgbWFwOiAgICAgICAgIGZhbHNlICAvLyBQcm92aWRlIGFuIGV4dHJhIGNoYXJhY3RlciBtYXAgdHJhbnNsYXRvci5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gUGx1Z2luICggZWxlbWVudCwgb3B0aW9ucyApIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50ICAgPSAkKGVsZW1lbnQpOyAgLy8gVGhlIGlucHV0IHdoZXJlIHNsdWcgaXMgcGxhY2VkLlxyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzICA9ICQuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMgKTtcclxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdHMgPSBkZWZhdWx0cztcclxuICAgICAgICAgICAgdGhpcy5jaGFycyAgICAgPSB0aGlzLl9sb2FkX2NoYXJfbWFwcygpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MubWFwKSB7ICAgICAgLy8gTG9hZCBleHRyYSBjaGFyYWN0ZXIgbWFwIHRyYW5zbGF0b3JcclxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRoaXMuY2hhcnMsIHRoaXMuc2V0dGluZ3MubWFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF2b2lkIFBsdWdpbi5wcm90b3R5cGUgY29uZmxpY3RzXHJcbiAgICAgICAgJC5leHRlbmQoIFBsdWdpbi5wcm90b3R5cGUsIHtcclxuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5zZXR0aW5ncy5pbnB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICQodGhpcy5lbGVtZW50KS5jbG9zZXN0KCdmb3JtJykuZmluZCgnaW5wdXRbbmFtZT1cIicgKyB0aGlzLmVsZW1lbnQuYXR0cihcImRhdGEtc2x1Zy1vcmlnaW5cIikgKyAnXCJdJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSA9ICh0aGlzLmVsZW1lbnQuZGF0YSgnc2x1Zy1mb3JjZXVwZGF0ZScpKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQub24oJ2tleXVwIGNoYW5nZScsICQucHJveHkodGhpcy5vbkNoYW5nZSwgdGhpcykpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnVwZGF0ZSA9IHRoaXMuZWxlbWVudC52YWwoKSA9PT0gJyc7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZW4gaW5wdXQgY2hhbmdlc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IGV2LmtleUNvZGUgPyBldi5rZXlDb2RlIDogZXYud2hpY2g7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPiAzNCAmJiBjb2RlIDwgNDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHN0ck9yaWdpbiA9ICQoZXYudGFyZ2V0KS52YWwoKSxcclxuICAgICAgICAgICAgICAgICAgICBzdHJUYXJnZXQgPSB0aGlzLmVsZW1lbnQudmFsKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC51cGRhdGVcclxuICAgICAgICAgICAgICAgICAgICB8fCBzdHJUYXJnZXQgPT09ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgKHN0clRhcmdldCAhPSAnJyAmJiB0aGlzLmZvcmNlVXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudmFsKHRoaXMuc2x1ZyhzdHJPcmlnaW4pKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2VuZXJhdGUgYSBzbHVnXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzbHVnOiBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0clxyXG4gICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIF9zbHVnID0gJycsXHJcbiAgICAgICAgICAgICAgICAgICAgX3NlcCA9IHRoaXMuc2V0dGluZ3Muc2VwYXJhdG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgQ2hhciBNYXBcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGw9c3RyLmxlbmd0aCA7IGk8bCA7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zbHVnICs9ICh0aGlzLmNoYXJzW3N0ci5jaGFyQXQoaSldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5jaGFyc1tzdHIuY2hhckF0KGkpXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc3RyLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzdHIgPSBfc2x1Z1xyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1teYS16MC05XS9nLCBfc2VwKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXCcrX3NlcCsnXFxcXCcrX3NlcCsnKycsICdnJyksIF9zZXApXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKCdeXFxcXCcrX3NlcCsnK3xcXFxcJytfc2VwKycrJCcsICdnJyksICcnKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgX2xvYWRfY2hhcl9tYXBzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcF9sYXRpbigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwX2FyYWJpYygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwX2dyZWVrKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBfdHVya2lzaCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwX3J1c3NpYW4oKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcF91a3JhbmlhbigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwX2N6ZWNoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBfcG9saXNoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBfdmlldG5hbSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwX2xhdHZpYW4oKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcF9saXRodWFuaWFuKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBfY3VycmVuY3koKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcF9zeW1ib2xzKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX21hcF9sYXRpbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICfDgCc6ICdBJywgJ8OBJzogJ0EnLCAnw4InOiAnQScsICfDgyc6ICdBJywgJ8OEJzogJ0EnLCAnw4UnOiAnQScsICfDhic6ICdBRScsICfDhyc6XHJcbiAgICAgICAgICAgICAgICAgICAgJ0MnLCAnw4gnOiAnRScsICfDiSc6ICdFJywgJ8OKJzogJ0UnLCAnw4snOiAnRScsICfDjCc6ICdJJywgJ8ONJzogJ0knLCAnw44nOiAnSScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ8OPJzogJ0knLCAnw5AnOiAnRCcsICfDkSc6ICdOJywgJ8OSJzogJ08nLCAnw5MnOiAnTycsICfDlCc6ICdPJywgJ8OVJzogJ08nLCAnw5YnOlxyXG4gICAgICAgICAgICAgICAgICAgICdPJywgJ8WQJzogJ08nLCAnw5gnOiAnTycsICfDmSc6ICdVJywgJ8OaJzogJ1UnLCAnw5snOiAnVScsICfDnCc6ICdVJywgJ8WwJzogJ1UnLFxyXG4gICAgICAgICAgICAgICAgICAgICfDnSc6ICdZJywgJ8OeJzogJ1RIJywgJ8OfJzogJ3NzJywgJ8OgJzonYScsICfDoSc6J2EnLCAnw6InOiAnYScsICfDoyc6ICdhJywgJ8OkJzpcclxuICAgICAgICAgICAgICAgICAgICAnYScsICfDpSc6ICdhJywgJ8OmJzogJ2FlJywgJ8OnJzogJ2MnLCAnw6gnOiAnZScsICfDqSc6ICdlJywgJ8OqJzogJ2UnLCAnw6snOiAnZScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ8OsJzogJ2knLCAnw60nOiAnaScsICfDric6ICdpJywgJ8OvJzogJ2knLCAnw7AnOiAnZCcsICfDsSc6ICduJywgJ8OyJzogJ28nLCAnw7MnOlxyXG4gICAgICAgICAgICAgICAgICAgICdvJywgJ8O0JzogJ28nLCAnw7UnOiAnbycsICfDtic6ICdvJywgJ8WRJzogJ28nLCAnw7gnOiAnbycsICfDuSc6ICd1JywgJ8O6JzogJ3UnLFxyXG4gICAgICAgICAgICAgICAgICAgICfDuyc6ICd1JywgJ8O8JzogJ3UnLCAnxbEnOiAndScsICfDvSc6ICd5JywgJ8O+JzogJ3RoJywgJ8O/JzogJ3knXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbWFwX2FyYWJpYzogIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAn2KcnOiAnYScsXHJcbiAgICAgICAgICAgICAgICAn2KMnOiAnYScsXHJcbiAgICAgICAgICAgICAgICAn2KUnOiAnaScsXHJcbiAgICAgICAgICAgICAgICAn2KInOiAnYWEnLFxyXG4gICAgICAgICAgICAgICAgJ9ikJzogJ3UnLFxyXG4gICAgICAgICAgICAgICAgJ9imJzogJ2UnLFxyXG4gICAgICAgICAgICAgICAgJ9ihJzogJ2EnLFxyXG4gICAgICAgICAgICAgICAgJ9ioJzogJ2InLFxyXG4gICAgICAgICAgICAgICAgJ9iqJzogJ3QnLFxyXG4gICAgICAgICAgICAgICAgJ9irJzogJ3RoJyxcclxuICAgICAgICAgICAgICAgICfYrCc6ICdqJyxcclxuICAgICAgICAgICAgICAgICfYrSc6ICdoJyxcclxuICAgICAgICAgICAgICAgICfYric6ICdraCcsXHJcbiAgICAgICAgICAgICAgICAn2K8nOiAnZCcsXHJcbiAgICAgICAgICAgICAgICAn2LAnOiAndGgnLFxyXG4gICAgICAgICAgICAgICAgJ9ixJzogJ3InLFxyXG4gICAgICAgICAgICAgICAgJ9iyJzogJ3onLFxyXG4gICAgICAgICAgICAgICAgJ9izJzogJ3MnLFxyXG4gICAgICAgICAgICAgICAgJ9i0JzogJ3NoJyxcclxuICAgICAgICAgICAgICAgICfYtSc6ICdzJyxcclxuICAgICAgICAgICAgICAgICfYtic6ICdkaCcsXHJcbiAgICAgICAgICAgICAgICAn2LcnOiAndCcsXHJcbiAgICAgICAgICAgICAgICAn2LgnOiAneicsXHJcbiAgICAgICAgICAgICAgICAn2LknOiAnYScsXHJcbiAgICAgICAgICAgICAgICAn2LonOiAnZ2gnLFxyXG4gICAgICAgICAgICAgICAgJ9mBJzogJ2YnLFxyXG4gICAgICAgICAgICAgICAgJ9mCJzogJ3EnLFxyXG4gICAgICAgICAgICAgICAgJ9mDJzogJ2snLFxyXG4gICAgICAgICAgICAgICAgJ9mEJzogJ2wnLFxyXG4gICAgICAgICAgICAgICAgJ9mFJzogJ20nLFxyXG4gICAgICAgICAgICAgICAgJ9mGJzogJ24nLFxyXG4gICAgICAgICAgICAgICAgJ9mHJzogJ2gnLFxyXG4gICAgICAgICAgICAgICAgJ9mIJzogJ3cnLFxyXG4gICAgICAgICAgICAgICAgJ9mKJzogJ3knLFxyXG4gICAgICAgICAgICAgICAgJ9mJJzogJ2EnLFxyXG4gICAgICAgICAgICAgICAgJ9ipJzogJ2gnLFxyXG4gICAgICAgICAgICAgICAgJ++7uyc6ICdsYScsXHJcbiAgICAgICAgICAgICAgICAn77u3JzogJ2xhYScsXHJcbiAgICAgICAgICAgICAgICAn77u5JzogJ2xhaScsXHJcbiAgICAgICAgICAgICAgICAn77u1JzogJ2xhYScsXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX21hcF9ncmVlazogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICfOsSc6J2EnLCAnzrInOidiJywgJ86zJzonZycsICfOtCc6J2QnLCAnzrUnOidlJywgJ862JzoneicsICfOtyc6J2gnLCAnzrgnOic4JyxcclxuICAgICAgICAgICAgICAgICAgICAnzrknOidpJywgJ866JzonaycsICfOuyc6J2wnLCAnzrwnOidtJywgJ869JzonbicsICfOvic6JzMnLCAnzr8nOidvJywgJ8+AJzoncCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJ8+BJzoncicsICfPgyc6J3MnLCAnz4QnOid0JywgJ8+FJzoneScsICfPhic6J2YnLCAnz4cnOid4JywgJ8+IJzoncHMnLCAnz4knOid3JyxcclxuICAgICAgICAgICAgICAgICAgICAnzqwnOidhJywgJ86tJzonZScsICfOryc6J2knLCAnz4wnOidvJywgJ8+NJzoneScsICfOric6J2gnLCAnz44nOid3JywgJ8+CJzoncycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ8+KJzonaScsICfOsCc6J3knLCAnz4snOid5JywgJ86QJzonaScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ86RJzonQScsICfOkic6J0InLCAnzpMnOidHJywgJ86UJzonRCcsICfOlSc6J0UnLCAnzpYnOidaJywgJ86XJzonSCcsICfOmCc6JzgnLFxyXG4gICAgICAgICAgICAgICAgICAgICfOmSc6J0knLCAnzponOidLJywgJ86bJzonTCcsICfOnCc6J00nLCAnzp0nOidOJywgJ86eJzonMycsICfOnyc6J08nLCAnzqAnOidQJyxcclxuICAgICAgICAgICAgICAgICAgICAnzqEnOidSJywgJ86jJzonUycsICfOpCc6J1QnLCAnzqUnOidZJywgJ86mJzonRicsICfOpyc6J1gnLCAnzqgnOidQUycsICfOqSc6J1cnLFxyXG4gICAgICAgICAgICAgICAgICAgICfOhic6J0EnLCAnzognOidFJywgJ86KJzonSScsICfOjCc6J08nLCAnzo4nOidZJywgJ86JJzonSCcsICfOjyc6J1cnLCAnzqonOidJJyxcclxuICAgICAgICAgICAgICAgICAgICAnzqsnOidZJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX21hcF90dXJraXNoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ8WfJzoncycsICfFnic6J1MnLCAnxLEnOidpJywgJ8SwJzonSScsICfDpyc6J2MnLCAnw4cnOidDJywgJ8O8JzondScsICfDnCc6J1UnLFxyXG4gICAgICAgICAgICAgICAgICAgICfDtic6J28nLCAnw5YnOidPJywgJ8SfJzonZycsICfEnic6J0cnXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfbWFwX3J1c3NpYW46IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAn0LAnOidhJywgJ9CxJzonYicsICfQsic6J3YnLCAn0LMnOidnJywgJ9C0JzonZCcsICfQtSc6J2UnLCAn0ZEnOid5bycsICfQtic6J3poJyxcclxuICAgICAgICAgICAgICAgICAgICAn0LcnOid6JywgJ9C4JzonaScsICfQuSc6J2onLCAn0LonOidrJywgJ9C7JzonbCcsICfQvCc6J20nLCAn0L0nOiduJywgJ9C+JzonbycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ9C/JzoncCcsICfRgCc6J3InLCAn0YEnOidzJywgJ9GCJzondCcsICfRgyc6J3UnLCAn0YQnOidmJywgJ9GFJzonaCcsICfRhic6J2MnLFxyXG4gICAgICAgICAgICAgICAgICAgICfRhyc6J2NoJywgJ9GIJzonc2gnLCAn0YknOidzaCcsICfRiic6JycsICfRiyc6J3knLCAn0YwnOicnLCAn0Y0nOidlJywgJ9GOJzoneXUnLFxyXG4gICAgICAgICAgICAgICAgICAgICfRjyc6J3lhJyxcclxuICAgICAgICAgICAgICAgICAgICAn0JAnOidBJywgJ9CRJzonQicsICfQkic6J1YnLCAn0JMnOidHJywgJ9CUJzonRCcsICfQlSc6J0UnLCAn0IEnOidZbycsICfQlic6J1poJyxcclxuICAgICAgICAgICAgICAgICAgICAn0JcnOidaJywgJ9CYJzonSScsICfQmSc6J0onLCAn0JonOidLJywgJ9CbJzonTCcsICfQnCc6J00nLCAn0J0nOidOJywgJ9CeJzonTycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ9CfJzonUCcsICfQoCc6J1InLCAn0KEnOidTJywgJ9CiJzonVCcsICfQoyc6J1UnLCAn0KQnOidGJywgJ9ClJzonSCcsICfQpic6J0MnLFxyXG4gICAgICAgICAgICAgICAgICAgICfQpyc6J0NoJywgJ9CoJzonU2gnLCAn0KknOidTaCcsICfQqic6JycsICfQqyc6J1knLCAn0KwnOicnLCAn0K0nOidFJywgJ9CuJzonWXUnLFxyXG4gICAgICAgICAgICAgICAgICAgICfQryc6J1lhJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX21hcF91a3JhbmlhbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICfQhCc6J1llJywgJ9CGJzonSScsICfQhyc6J1lpJywgJ9KQJzonRycsICfRlCc6J3llJywgJ9GWJzonaScsICfRlyc6J3lpJywgJ9KRJzonZydcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF9tYXBfY3plY2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAnxI0nOidjJywgJ8SPJzonZCcsICfEmyc6J2UnLCAnxYgnOiAnbicsICfFmSc6J3InLCAnxaEnOidzJywgJ8WlJzondCcsICfFryc6J3UnLFxyXG4gICAgICAgICAgICAgICAgICAgICfFvic6J3onLCAnxIwnOidDJywgJ8SOJzonRCcsICfEmic6J0UnLCAnxYcnOiAnTicsICfFmCc6J1InLCAnxaAnOidTJywgJ8WkJzonVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJ8WuJzonVScsICfFvSc6J1onXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfbWFwX3BvbGlzaDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICfEhSc6J2EnLCAnxIcnOidjJywgJ8SZJzonZScsICfFgic6J2wnLCAnxYQnOiduJywgJ8OzJzonbycsICfFmyc6J3MnLCAnxbonOid6JyxcclxuICAgICAgICAgICAgICAgICAgICAnxbwnOid6JywgJ8SEJzonQScsICfEhic6J0MnLCAnxJgnOidlJywgJ8WBJzonTCcsICfFgyc6J04nLCAnw5MnOidvJywgJ8WaJzonUycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ8W5JzonWicsICfFuyc6J1onXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfbWFwX3ZpZXRuYW06IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAn4bqhJzogJ2EnLCfhuqMnOiAnYScsJ+G6pyc6ICdhJywn4bqlJzogJ2EnLCfhuq0nOiAnYScsJ+G6qSc6ICdhJywn4bqrJzogJ2EnLCfhurEnOiAnYScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ+G6ryc6ICdhJywn4bq3JzogJ2EnLCfhurMnOiAnYScsJ+G6tSc6ICdhJywn4bq5JzogJ2UnLCfhursnOiAnZScsJ+G6vSc6ICdlJywn4buBJzogJ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgICfhur8nOiAnZScsJ+G7hyc6ICdlJywn4buDJzogJ2UnLCfhu4UnOiAnZScsJ+G7iyc6ICdpJywn4buJJzogJ2knLCfhu40nOiAnbycsJ+G7jyc6ICdvJyxcclxuICAgICAgICAgICAgICAgICAgICAn4buTJzogJ28nLCfhu5EnOiAnbycsJ+G7mSc6ICdvJywn4buVJzogJ28nLCfhu5cnOiAnbycsJ+G7nSc6ICdvJywn4bubJzogJ28nLCfhu6MnOiAnbycsXHJcbiAgICAgICAgICAgICAgICAgICAgJ+G7nyc6ICdvJywn4buhJzogJ28nLCfhu6UnOiAndScsJ+G7pyc6ICd1Jywn4burJzogJ3UnLCfhu6knOiAndScsJ+G7sSc6ICd1Jywn4butJzogJ3UnLFxyXG4gICAgICAgICAgICAgICAgICAgICfhu68nOiAndScsJ+G7syc6ICd5Jywn4bu1JzogJ3knLCfhu7cnOiAneScsJ+G7uSc6ICd5Jywn4bqgJzogJ0EnLCfhuqInOiAnQScsJ+G6pic6ICdBJyxcclxuICAgICAgICAgICAgICAgICAgICAn4bqkJzogJ0EnLCfhuqwnOiAnQScsJ+G6qCc6ICdBJywn4bqqJzogJ0EnLCfhurAnOiAnQScsJ+G6ric6ICdBJywn4bq2JzogJ0EnLCfhurInOiAnQScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ+G6tCc6ICdBJywn4bq4JzogJ0UnLCfhuronOiAnRScsJ+G6vCc6ICdFJywn4buAJzogJ0UnLCfhur4nOiAnRScsJ+G7hic6ICdFJywn4buCJzogJ0UnLFxyXG4gICAgICAgICAgICAgICAgICAgICfhu4QnOiAnRScsJ+G7iic6ICdJJywn4buIJzogJ0knLCfhu4wnOiAnTycsJ+G7jic6ICdPJywn4buSJzogJ08nLCfhu5AnOiAnTycsJ+G7mCc6ICdPJyxcclxuICAgICAgICAgICAgICAgICAgICAn4buUJzogJ08nLCfhu5YnOiAnTycsJ+G7nCc6ICdPJywn4buaJzogJ08nLCfhu6InOiAnTycsJ+G7nic6ICdPJywn4bugJzogJ08nLCfhu6QnOiAnVScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ+G7pic6ICdVJywn4buqJzogJ1UnLCfhu6gnOiAnVScsJ+G7sCc6ICdVJywn4busJzogJ1UnLCfhu64nOiAnVScsJ+G7sic6ICdZJywn4bu0JzogJ1knLFxyXG4gICAgICAgICAgICAgICAgICAgICfEkSc6ICdkJywnxJAnOiAnRCcsJ+G7tic6ICdZJywn4bu4JzogJ1knLCfEgyc6ICdhJywnxIInOiAnYSdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF9tYXBfbGF0dmlhbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICfEgSc6J2EnLCAnxI0nOidjJywgJ8STJzonZScsICfEoyc6J2cnLCAnxKsnOidpJywgJ8S3JzonaycsICfEvCc6J2wnLCAnxYYnOiduJyxcclxuICAgICAgICAgICAgICAgICAgICAnxaEnOidzJywgJ8WrJzondScsICfFvic6J3onLCAnxIAnOidBJywgJ8SMJzonQycsICfEkic6J0UnLCAnxKInOidHJywgJ8SqJzonaScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ8S2JzonaycsICfEuyc6J0wnLCAnxYUnOidOJywgJ8WgJzonUycsICfFqic6J3UnLCAnxb0nOidaJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgX21hcF9saXRodWFuaWFuOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ8SFJzonYScsICfEjSc6J2MnLCAnxJknOidlJywgJ8SXJzonZScsICfEryc6J2knLCAnxaEnOidzJywgJ8WzJzondScsICfFqyc6J3UnLFxyXG4gICAgICAgICAgICAgICAgICAgICfFvic6J3onLCAnxIQnOidBJywgJ8SMJzonQycsICfEmCc6J0UnLCAnxJYnOidFJywgJ8SuJzonSScsICfFoCc6J1MnLCAnxbInOidVJyxcclxuICAgICAgICAgICAgICAgICAgICAnxaonOidVJywgJ8W9JzonWicsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfbWFwX2N1cnJlbmN5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ+KCrCc6ICdldXJvJywgJyQnOiAnZG9sbGFyJywgJ+KCoic6ICdjcnV6ZWlybycsICfigqMnOiAnZnJlbmNoIGZyYW5jJywgJ8KjJzogJ3BvdW5kJyxcclxuICAgICAgICAgICAgICAgICAgICAn4oKkJzogJ2xpcmEnLCAn4oKlJzogJ21pbGwnLCAn4oKmJzogJ25haXJhJywgJ+KCpyc6ICdwZXNldGEnLCAn4oKoJzogJ3J1cGVlJyxcclxuICAgICAgICAgICAgICAgICAgICAn4oKpJzogJ3dvbicsICfigqonOiAnbmV3IHNoZXF1ZWwnLCAn4oKrJzogJ2RvbmcnLCAn4oKtJzogJ2tpcCcsICfigq4nOiAndHVncmlrJyxcclxuICAgICAgICAgICAgICAgICAgICAn4oKvJzogJ2RyYWNobWEnLCAn4oKwJzogJ3Blbm55JywgJ+KCsSc6ICdwZXNvJywgJ+KCsic6ICdndWFyYW5pJywgJ+KCsyc6ICdhdXN0cmFsJyxcclxuICAgICAgICAgICAgICAgICAgICAn4oK0JzogJ2hyeXZuaWEnLCAn4oK1JzogJ2NlZGknLCAnwqInOiAnY2VudCcsICfCpSc6ICd5ZW4nLCAn5YWDJzogJ3l1YW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICflhoYnOiAneWVuJywgJ++3vCc6ICdyaWFsJywgJ+KCoCc6ICdlY3UnLCAnwqQnOiAnY3VycmVuY3knLCAn4Li/JzogJ2JhaHQnXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfbWFwX3N5bWJvbHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAnwqknOicoYyknLCAnxZMnOiAnb2UnLCAnxZInOiAnT0UnLCAn4oiRJzogJ3N1bScsICfCric6ICcociknLCAn4oCgJzogJysnLFxyXG4gICAgICAgICAgICAgICAgICAgICfigJwnOiAnXCInLCAn4oCdJzogJ1wiJywgJ+KAmCc6IFwiJ1wiLCAn4oCZJzogXCInXCIsICfiiIInOiAnZCcsICfGkic6ICdmJywgJ+KEoic6ICd0bScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ+KEoCc6ICdzbScsICfigKYnOiAnLi4uJywgJ8uaJzogJ28nLCAnwronOiAnbycsICfCqic6ICdhJywgJ+KAoic6ICcqJyxcclxuICAgICAgICAgICAgICAgICAgICAn4oiGJzogJ2RlbHRhJywgJ+KInic6ICdpbmZpbml0eScsICfimaUnOiAnbG92ZScsICcmJzogJ2FuZCdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJC5mblsgcGx1Z2luTmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCAhJC5kYXRhKCB0aGlzLCBwbHVnaW5OYW1lICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJC5kYXRhKCB0aGlzLCBwbHVnaW5OYW1lLCBuZXcgUGx1Z2luKHRoaXMsIG9wdGlvbnMpICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gKTtcclxuICAgICAgICB9O1xyXG5cclxufSApKCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/admin/slugify.js\n");

/***/ }),

/***/ 2:
/*!*************************************************!*\
  !*** multi ./resources/js/admin/form-browse.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! C:\wamp64\www\voyagerfinal\resources\js\admin\form-browse.js */"./resources/js/admin/form-browse.js");


/***/ })

/******/ });